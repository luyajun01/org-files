
coxLasso <- function(x, y, nfolds, stdbeta=TRUE)
{
  #foldid <- coxsplit(y,nfolds)
  #fit <- Coxnet(x, y ,penalty="Lasso", foldid=foldid, isd=stdbeta)
  #beta <- fit$Beta
  n = dim(z)[1]
  p = dim(z)[2]
  if (is.null(foldid)) {
    foldid <-randomly_assign(n,nfolds)
  }
  ##
  prep0=coxprep(z,y)
  wbeta=rep(1, p)
  rlambda=NULL
  N0=nrow(z)
  alpha=1
  ### Lambda path
  if (is.null(lambda)) {
    lambda_max=max_lambdaC(prep0$x, prep0$tevent, prep0$N, prep0$nevent, prep0$nevent1, prep0$loc1, prep0$n, alpha, wbeta, N0)
    lambda_min=ifelse(is.null(rlambda), ifelse(N0>p, lambda_max*0.0001, lambda_max*0.01), lambda_max*rlambda)
    lambda=lambda_max*(lambda_min/lambda_max)^(c(0:(nlambda-1))/(nlambda-1))
  } else {
    nlambda=length(lambda)
  }
  cv_model=list()
  cverror<-matrix(NA,nr=nfolds,nc=nlambda)
  train_z=list()
  train_y=list()
  prep1=list()
  for (i in 1:nfolds) {
    train_z<- z[foldid!=i, ]
    train_y<- y[foldid!=i,]
    cv_model[[i]]<-sapply(lambda,cox.lasso,y=train_y,z=train_z)
   dt <- data.frame(cbind(train_y,train_z))
  dt <- dt[order(dt[,1]),]
  z <- dt[,3:ncol(dt)]
  event <- subset(dt, dt[,2]==1 & dt[,1] <= y[,2])
  unique_time <- unique(event[,1])
  R <- sapply(unique_time, function(t){
    which(dt[,1]>=y[,2])})
  h0 <- sum(sapply(1:length(unique_time), function(i){
    temp <- z[R[[i]],]
    1/sum((exp(as.matrix(temp) %*% as.matrix(beta))))
  }))
  s0 <- exp(-h0)
  # Fetch the evaluation metrics
  for (j in 1:length(lambda)) {
  eval_metrics[i,j]<-eval(x,y,cv_model[[i]][,j],h0,s0,foldid,nfolds)
  }
  # Append the evaluation metrics to the Coxnet object and return
  return(c(fit, s0=s0, unlist(eval_metrics)))
}