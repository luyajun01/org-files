library(survival)
library(glmnet)
library(rqPen)
library(Coxnet)
library(matrixcalc)
source("cox.lasso4.r")
source("plr.r")
source("coxloglik.r")
sourceCpp("pletaCm.cpp")
# LoglikPen <- function(z,y,beta,lambda)
# {
#   time=y[,1]
#   status=y[,2]
#   w <- norm(as.matrix(beta),"1")
#   beta.prime <- beta*w
#   eta <- z%*%beta.prime
#   # LOG-LIKELIHOOD
#   L <- sum(status*(eta-log(cumsum(exp(eta)))))
#   # THE OBJECTIVE FUNCTION
#   L.pen <- -2*L/nrow(z) + lambda*sum(w)
#   return(L.pen)
# }
LoglikPen = function(y,z,beta,lambda){
  n=nrow(z)
  delta <- y[,2]
  w <- norm(as.matrix(beta),"1")
  L <- delta%*%(z%*%as.matrix(beta)) -
    delta%*%log(sapply(y[,1], function(p){
      # find instances of R
      # foreach j in R
      R <- z[which(y[,1] >= p),]
      sum(exp(R %*% beta))
    }))
  return(-2*L/n+lambda*sum(w))
}


max_lambdaC <- function(X, tevent, N, nevent, nevent1, loc1, n, alpha, wbeta, N0) {
  .Call('Coxnet_max_lambdaC', PACKAGE = 'Coxnet', X, tevent, N, nevent, nevent1, loc1, n, alpha, wbeta, N0)
}
cv.coxlasso<-function(y,z,lambda=NULL,nlambda=50) 
{
  n = dim(z)[1]
  p = dim(z)[2]
  prep0=coxprep(z,y)
  wbeta=rep(1, p)
  rlambda=NULL
  N0=nrow(z)
  alpha=1
  ### Lambda path
  if (is.null(lambda)) {
    lambda_max=max_lambdaC(prep0$x, prep0$tevent, prep0$N, prep0$nevent, prep0$nevent1, prep0$loc1, prep0$n, alpha, wbeta, N0)
    lambda_min=ifelse(is.null(rlambda), ifelse(N0>p, lambda_max*0.0001, lambda_max*0.01), lambda_max*rlambda)
    lambda=lambda_max*(lambda_min/lambda_max)^(c(0:(nlambda-1))/(nlambda-1))
  } else {
    nlambda=length(lambda)
  }
  cv_model=list()
  cverror<-rep(NA,nlambda)
  train_z=list()
  train_y=list()
  prep1=list()
    for (i in 1:nlambda){
      #prep1[[i]]=coxprep(train_z[[i]],train_y[[i]])
      #cverror[i,j]<-coxloglik(z=z,y=y,beta=as.double(cv_model[[i]][,j]))-coxloglik(z=train_z[[i]],y=train_y[[i]],beta=as.double(cv_model[[i]][,j]))
      #cverror[i,j]<-pletaCm(xb=prep0$x%*%as.double(cv_model[[i]][,j]),exb=exp(prep0$x%*%as.double(cv_model[[i]][,j])),prep0$nevent,prep0$nevent1,prep0$loc1,prep0$n)-pletaCm(xb=prep1[[i]]$x%*%as.double(cv_model[[i]][,j]),exb=exp(prep1[[i]]$x%*%as.double(cv_model[[i]][,j])),prep1[[i]]$nevent,prep1[[i]]$nevent1,prep1[[i]]$loc1,prep1[[i]]$n)
      #cverror[i,j]=plr(x=z,y=y,beta=as.double(cv_model[[i]][,j]))-plr(x=train_z[[i]],y=train_y[[i]],beta=as.double(cv_model[[i]][,j]))
      cv_model<-sapply(lambda,cox.lasso,y=y,z=z)
      eta=matrix(as.numeric(unlist(z)),nc=ncol(z),nr=nrow(z))%*%as.matrix(cv_model[,i])
      exb=exp(eta)
      de=dletaCm(exb,prep0$tevent,prep0$N,prep0$nevent,prep0$nevent1,prep0$loc1,prep0$n)
      dl2=de$pl2
      w=rep(NA,ncol(z))
      if(all(cv_model[,i]!=0)){w=diag(1/cv_model[,i])}  
      else {
        w[which(cv_model[,i]!=0)]=1/(cv_model[,i][which(cv_model[,i]!=0)])
        w[which(cv_model[,i]==0)]=0
        w=diag(w)
        }
      p=matrix.trace(z%*%solve(t(z)%*%diag(dl2)%*%z+lambda[i]*w)%*%t(z)%*%diag(dl2))
      #cverror[i]=LoglikPen(z=z,y=y,beta=as.double(cv_model[,i]),lambda=lambda[i])/n*((1-p)/n)^2 #GCV
      cverror[i]=n^{1/(2+length(as.double(cv_model[,i])!=0))-1}+LoglikPen(z=z,y=y,beta=as.double(cv_model[,i]),lambda=lambda[i])#adjust BIC
      }
  lam.opt=lambda[which.min(cverror)]
  coef=cox.lasso(z=z,y=y,lambda=lam.opt)
  return(list(coef=coef,lambda=lam.opt))
}


