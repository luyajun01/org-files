library(survival)
library(glmnet)
library(rqPen)
library(Coxnet)
source("cox.lasso4.r")
source("plr.r")
source("coxloglik.r")
sourceCpp("pletaCm.cpp")
max_lambdaC <- function(X, tevent, N, nevent, nevent1, loc1, n, alpha, wbeta, N0) {
  .Call('Coxnet_max_lambdaC', PACKAGE = 'Coxnet', X, tevent, N, nevent, nevent1, loc1, n, alpha, wbeta, N0)
}

coxenetC <- function(X, tevent, alpha, lambda, nlambda, wbeta, N, nevent, nevent1, loc1, n, p, N0, thresh, maxit, ifast) {
  .Call('Coxnet_coxenetC', PACKAGE = 'Coxnet', X, tevent, alpha, lambda, nlambda, wbeta, N, nevent, nevent1, loc1, n, p, N0, thresh, maxit, ifast)
}
cvcoxenetC <- function(X, tevent, alpha, lambda, nlambda, wbeta, N, nevent, nevent1, loc1, n, p, N0, thresh, maxit, ifast, XF, NF, neventF, nevent1F, loc1F, nF) {
  .Call('Coxnet_cvcoxenetC', PACKAGE = 'Coxnet', X, tevent, alpha, lambda, nlambda, wbeta, N, nevent, nevent1, loc1, n, p, N0, thresh, maxit, ifast, XF, NF, neventF, nevent1F, loc1F, nF)
}
cvcoxnetC <- function(X, tevent, alpha, lambda, nlambda, wbeta, Omega, loc, nadj, N, nevent, nevent1, loc1, n, p, N0, thresh, maxit, ifast, XF, NF, neventF, nevent1F, loc1F, nF) {
  .Call('Coxnet_cvcoxnetC', PACKAGE = 'Coxnet', X, tevent, alpha, lambda, nlambda, wbeta, Omega, loc, nadj, N, nevent, nevent1, loc1, n, p, N0, thresh, maxit, ifast, XF, NF, neventF, nevent1F, loc1F, nF)
}
alpha=1;lambda=NULL;nlambda=50;rlambda=NULL;nfolds=10;foldid=NULL;itrunc=TRUE;adaptive=FALSE;aini=NULL;isd=FALSE;ifast=TRUE;keep.beta=FALSE;
thresh=1e-7;maxit=1e+5
cvtrimC <- function(beta, nn, nn2, loco, XF, NF, neventF, nevent1F, loc1F, nF, X, N, nevent, nevent1, loc1, n, ifast, itwo) {
  .Call('Coxnet_cvtrimC', PACKAGE = 'Coxnet', beta, nn, nn2, loco, XF, NF, neventF, nevent1F, loc1F, nF, X, N, nevent, nevent1, loc1, n, ifast, itwo)
}
cv.coxlasso<-function(y,z,foldid=NULL,nfolds=10,lambda=NULL,nlambda=50) 
{
  n = dim(z)[1]
  p = dim(z)[2]
  if (is.null(foldid)) {
    foldid <-randomly_assign(n,nfolds)
  }
 ##
  prep0=coxprep(z,y)
  wbeta=rep(1, p)
  rlambda=NULL
  N0=nrow(z)
  alpha=1
  ### Lambda path
  if (is.null(lambda)) {
    lambda_max=max_lambdaC(prep0$x, prep0$tevent, prep0$N, prep0$nevent, prep0$nevent1, prep0$loc1, prep0$n, alpha, wbeta, N0)
    lambda_min=ifelse(is.null(rlambda), ifelse(N0>p, lambda_max*0.0001, lambda_max*0.01), lambda_max*rlambda)
    lambda=lambda_max*(lambda_min/lambda_max)^(c(0:(nlambda-1))/(nlambda-1))
  } else {
    nlambda=length(lambda)
  }
  out=coxenetC(prep0$x, prep0$tevent, alpha, lambda, nlambda, wbeta, prep0$N, prep0$nevent, prep0$nevent1, prep0$loc1, prep0$n, p, N0, thresh, maxit, ifast)
  nlambdai=out$nlambda
  if (nlambdai==0)
    return(NULL)
  lambdai=lambda[1:nlambdai]
  cv_model=list()
  cverror<-matrix(NA,nr=nfolds,nc=nlambda)
  train_z=list()
  train_y=list()
  prep1=list()
  prepk=list()
  for (i in 1:nfolds) {
    temid=which(foldid!=i)
    prepk[[i]]=coxprep(x[temid, ], y[temid, ])
  }
  for (i in 1:nfolds) {
    train_z[[i]] <- z[foldid!=i, ]
    train_y[[i]] <- y[foldid!=i,]
    cv_model[[i]]<-sapply(lambda,cox.lasso,y=train_y[[i]],z=train_z[[i]])
  }
  for (i in 1:nfolds) {
    for (j in 1:length(lambda)){
      #prep1[[i]]=coxprep(train_z[[i]],train_y[[i]])
      cverror[i,j]<-coxloglik(z=z,y=y,beta=as.double(cv_model[[i]][,j]))-coxloglik(z=train_z[[i]],y=train_y[[i]],beta=as.double(cv_model[[i]][,j]))
      #cverror[i,j]<-pletaCm(xb=prep0$x%*%as.double(cv_model[[i]][,j]),exb=exp(prep0$x%*%as.double(cv_model[[i]][,j])),prep0$nevent,prep0$nevent1,prep0$loc1,prep0$n)-pletaCm(xb=prep1[[i]]$x%*%as.double(cv_model[[i]][,j]),exb=exp(prep1[[i]]$x%*%as.double(cv_model[[i]][,j])),prep1[[i]]$nevent,prep1[[i]]$nevent1,prep1[[i]]$loc1,prep1[[i]]$n)
      #cverror[i,j]=plr(x=z,y=y,beta=as.double(cv_model[[i]][,j]))-plr(x=train_z[[i]],y=train_y[[i]],beta=as.double(cv_model[[i]][,j]))
      #cverror[i,j]<-plr(x=prep0$x,y=train_y[[i]],beta=as.double(cv_model[[i]][,j]))/n*((1-length(as.double(cv_model[[i]][,j]))!=0)/n)^2 #GCV
  }
  }
  weighti=as.vector(tapply(y[, "status"], foldid, sum))
  cvraw=cverror/weighti;nfoldi=apply(!is.na(cvraw), 2, sum);rm(cverror) #
  cvm=apply(cvraw, 2, weighted.mean, w=weighti, na.rm=TRUE)
  cvse=sqrt(apply(sweep(cvraw, 2, cvm, "-")^2, 2, weighted.mean, w=weighti, na.rm=TRUE)/(nfoldi-1))
  #lam.opt=lambda[which.min(cvse)]
  #lam.opt=lambda[which.max((apply(cverror,2,mean)))]
  #lam.opt=lambda[which.min((apply(cverror,2,mean)))]
  #coef=cox.lasso(z=z,y=y,lambda=lam.opt)
  #return(list(coef=coef,lambda=lam.opt))
  out=sapply(lambda,cox.lasso,y=y,z=z)
  nzero<-apply(out!=0, 2, sum)
  indexi=which.max(cvm)##find the maxi cvm /lambda
  indexij=which(cvm>=(cvm[indexi]-cvse[indexi]))[1]
  #####  Cross-validation Trimming  #####
  il0=indexi;cvm=list();cv.max=rep(NA,nlambdai)
  repeat{
    numi=nzero[il0]#原始数据跑出来系数为0个数在i10个lambda时候
    Betai=sapply(cv_model,function(x){x[, il0]})##将10折迭代出来的第i10列系数萃取出来 
    Betao=apply(Betai!=0,2,sum)##每列不为0的个数
    numi2=min(max(Betao),numi)
    if (numi2>0) {
      cvPL=matrix(NA, nrow=nfolds, ncol=numi2)
      for (i in 1:nfolds) {
        Betaj=Betai[,i]
        numj=min(Betao[i],numi)
        if (numj==0) {
          cvPL[i,]=cvtrimC(c(0.0,0.0),numj,numi2,c(0,0),prep0$x, prep0$N, prep0$nevent, prep0$nevent1, prep0$loc1, prep0$n, prepk[[i]]$x, prepk[[i]]$N, prepk[[i]]$nevent, prepk[[i]]$nevent1, prepk[[i]]$loc1, prepk[[i]]$n, 0, 1)
        } else {
          temo=rank(-abs(Betaj),ties.method="min") #对Betaj进行绝对值排序
          temo=data.frame(temo[which(temo<=numj)], which(temo<=numj))###惊奇发现0系数变量消失了
          temo=temo[order(temo[, 1]), ]##对变量按照系数大小进行重新排序
          cvPL[i, ]=cvtrimC(Betaj[temo[, 2]], numj, numi2, temo[, 2]-1, prep0$x, prep0$N, prep0$nevent, prep0$nevent1, prep0$loc1, prep0$n, prepk[[i]]$x, prepk[[i]]$N, prepk[[i]]$nevent, prepk[[i]]$nevent1, prepk[[i]]$loc1, prepk[[i]]$n, 0, 1)
        }
      }
    } 
    else {
      cvPL=matrix(NA, nrow=nfolds,ncol=1)
      for (i in 1:nfolds)
        cvPL[i, ]=cvtrimC(c(0.0, 0.0),0,0, c(0, 0), prep0$x, prep0$N, prep0$nevent, prep0$nevent1, prep0$loc1, prep0$n, prepk[[i]]$x, prepk[[i]]$N, prepk[[i]]$nevent, prepk[[i]]$nevent1, prepk[[i]]$loc1, prepk[[i]]$n, 0, 1)
    }
    cvraw=cvPL/weighti;nfoldi=apply(!is.na(cvraw),2,sum);rm(cvPL) #
    cvm[[il0]]=apply(cvraw,2,weighted.mean, w=weighti, na.rm=TRUE)
    cv.max[il0]=max(cvm[[il0]])
    il1=c(il0-1,il0+1)
    for (j in 1:2) {
      if (il1[j]>=1 & il1[j]<=nlambdai) {
        if (is.na(cv.max[il1[j]])) {
          numi=nzero[il1[j]]
          Betai=sapply(cv_model, function(x){x[, il1[j]]})
          Betao=apply(Betai!=0, 2, sum)
          numi2=min(max(Betao), numi)
          if (numi2>0) {
            cvPL=matrix(NA, nrow=nfolds, ncol=numi2)
            for (i in 1:nfolds ){
              Betaj=Betai[, i]
              numj=min(Betao[i], numi)
              if (numj==0) {
                cvPL[i, ]=cvtrimC(c(0.0, 0.0), numj, numi2, c(0, 0), prep0$x, prep0$N, prep0$nevent, prep0$nevent1, prep0$loc1, prep0$n, prepk[[i]]$x, prepk[[i]]$N, prepk[[i]]$nevent, prepk[[i]]$nevent1, prepk[[i]]$loc1, prepk[[i]]$n, 0, 1)
              } else {
                temo=rank(-abs(Betaj), ties.method="min")
                temo=data.frame(temo[which(temo<=numj)], which(temo<=numj))
                temo=temo[order(temo[, 1]), ]
                cvPL[i, ]=cvtrimC(Betaj[temo[, 2]], numj, numi2, temo[, 2]-1, prep0$x, prep0$N, prep0$nevent, prep0$nevent1, prep0$loc1, prep0$n, prepk[[i]]$x, prepk[[i]]$N, prepk[[i]]$nevent, prepk[[i]]$nevent1, prepk[[i]]$loc1, prepk[[i]]$n, 0, 1)
              }
            }
          } else {
            cvPL=matrix(NA, nrow=nfolds, ncol=1)
            for(i in 1:nfolds)
              cvPL[i, ]=cvtrimC(c(0.0, 0.0), 0, 0, c(0, 0), prep0$x, prep0$N, prep0$nevent, prep0$nevent1, prep0$loc1, prep0$n, prepk[[i]]$x, prepk[[i]]$N, prepk[[i]]$nevent, prepk[[i]]$nevent1, prepk[[i]]$loc1, prepk[[i]]$n, 0, 1)
          }
          cvraw=cvPL/weighti;nfoldi=apply(!is.na(cvraw),2,sum)
          rm(cvPL)
          cvm[[il1[j]]]=apply(cvraw, 2, weighted.mean, w=weighti, na.rm=TRUE)
          cv.max[il1[j]]=max(cvm[[il1[j]]])
        }
      } else {
        break
      }
    }
    if (il1[j]==1 | il1[j]==nlambdai)
      break
    if (il0==which.max(cv.max)) {
      break
    } else {
      il0=which.max(cv.max)
    }
  }  
  index0=which.max(cv.max)
  Beta0=out[,index0]
  cuti=which.max(cvm[[index0]])
  Beta0[abs(Beta0)<=sort(abs(Beta0),TRUE)[cuti+1]]=0
  return(Beta0)
  }
  
  
