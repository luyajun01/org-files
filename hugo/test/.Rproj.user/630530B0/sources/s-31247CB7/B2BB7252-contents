coxr.ple <- function(beta, time, status, z, nrow, ncol) {
  eps <- 1e-06
  iter.max <- 100
  l <- 0.8;
  for (i in 1:iter.max) {
    
    res <- .C("ple", as.double(beta), as.double(time),
              as.integer(status), as.double(z), as.integer(nrow),
              as.integer(ncol), res = double(1), gradient = double(ncol),
              hessian = double(ncol*ncol))
    
    hess <- matrix(res$hessian, ncol, ncol)
    hessinv <- chol2inv(chol(hess))
    beta_new <- beta - l*(res$gradient %*% hessinv)
    minimum_new <- res$res
    
    norm <- sqrt(sum((beta - beta_new)^2))
    
    if ( norm <= eps ) {
      beta <- beta_new
      res <- .C("ple", as.double(beta), as.double(time),
                as.integer(status), as.double(z), as.integer(nrow),
                as.integer(ncol), res = double(1), gradient = double(ncol),
                hessian = double(ncol*ncol), PACKAGE = "coxrobust")
      
      hess <- matrix(res$hessian, ncol, ncol)
      hessinv <- chol2inv(chol(hess))
      break
    } else if ( i>1 && minimum_new > minimum ) {
      beta <- (beta + beta_new) / 2
    } else {
      beta <- beta_new
      minimum <- minimum_new
    }
    
  }
  
  return(list(beta = as.double(beta), hess = hess, hessinv = hessinv))
  
}