* C/C++_wiki                                                            :toc:
  - [[#常见问题][常见问题]]
  - [[#注释][注释]]
  - [[#一个典型-c-语言程序][一个典型 C 语言程序]]
  - [[#clion][clion]]
  - [[#存储类][存储类]]
  - [[#标识符][标识符]]
  - [[#关键字][关键字]]
  - [[#空格][空格]]
  - [[#修饰符][修饰符]]
  - [[#运算符][运算符]]
  - [[#存储类-1][存储类]]
  - [[#判断][判断]]
  - [[#struct][struct]]
  - [[#union][union]]
  - [[#typedef][typedef]]
  - [[#循环][循环]]
  - [[#函数][函数]]
  - [[#getchar][getchar]]
  - [[#gets][gets]]
  - [[#scanf][scanf]]
  - [[#类型变换][类型变换]]
  - [[#错误处理][错误处理]]
  - [[#c-数据类型][C 数据类型]]
  - [[#作用域规则][作用域规则]]
  - [[#类][类]]
  - [[#继承][继承]]
  - [[#重载运算符和重载函数][重载运算符和重载函数]]
  - [[#变量][变量]]
  - [[#常量][常量]]
  - [[#数组][数组]]
  - [[#字符串][字符串]]
  - [[#enum枚举][enum(枚举)]]
  - [[#指针][指针]]
  - [[#includestdioh][#include<stdio.h>]]
  - [[#int-mainvoid][int main(void)]]
  - [[#c-11][C++ 11]]
  - [[#变量与常量数据][变量与常量数据]]
  - [[#数组-1][数组]]
  - [[#sizeof][sizeof]]
  - [[#基本输入与输出][基本输入与输出]]
  - [[#c-语言特点][C++ 语言特点]]
  - [[#命名空间][命名空间]]
  - [[#常用数据类型][常用数据类型]]
  - [[#rcpp][Rcpp]]
  - [[#print][print]]

** 常见问题

- fatal error: RcppEigen.h: No such file or directory

https://stackoverflow.com/questions/22596370/fatal-error-rcppeigen-h-no-such-file-or-directory

   #+begin_src c
#include <Rcpp.h>
#include <RcppEigen.h>
// [[Rcpp::depends(RcppEigen)]]
   #+end_src

** 注释
C++包含两种注释，注释界定符/**/通常用于多行注释，而双斜杠//通常用于单行或半行注释。

clion 里面注释的快捷键是 shift+command+/.

** 一个典型 C 语言程序

#+begin_src c :includes <stdio.h>
     #include <stdio.h> //包含标准库的信息
     int main() //定义名为main 的函数，它不接受参数值，main 函数的语句都被括在花括号里
{
    printf("hello, world\n"); //main 函数调用库函数printf 以显示字符序列；\n 代表换行符
}
#+end_src

程序的第一行 #include <stdio.h> 是预处理器指令，告诉 C 编译器在实际编译之前要包含 stdio.h 文件。下一行 int main() 是主函数，程序从这里开始执行。下一行 /*...*/ 将会被编译器忽略，这里放置程序的注释内容。它们被称为程序的注释。下一行 printf(...) 是 C 中另一个可用的函数，会在屏幕上显示消息 "Hello, World!"。下一行 return 0; 终止 main() 函数，并返回值 0。

在 C 程序中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。C 语言有两种注释方式：以 // 开始的单行注释，这种注释可以单独占一行。/* */ 这种格式的注释可以单行或多行。

** clion
windows 里使用 clion, new project -> c  executable, 然后就可以愉快编程了。

** 存储类
https://www.runoob.com/cprogramming/c-storage-classes.html
C 语言中可用的存储类：

- auto

auto 存储类是所有局部变量默认的存储类。

- register

register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

- static

static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

- extern

extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

** 标识符
C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是区分大小写的编程语言。因此，在 C 中，Manpower 和 manpower 是两个不同的标识符。

** 关键字

| 关键字   | 说明                                                          |
| auto     | 声明自动变量                                                  |
| break    | 跳出当前循环                                                  |
| case     | 开关语句分支                                                  |
| char     | 声声明字符型变量或函数返回值类型                              |
| const    | 定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变 |
| continue | 结束当前循环，开始下一轮循环                                  |
| default  | 开关语句中的"其它"分支                                        |
| do       | 循环语句的循环体                                              |
| double   | 声明双精度浮点型变量或函数返回值类型                          |
| else     | 条件语句否定分支（与 if 连用）                                |
| eenum    | 声明枚举类型                                                  |
| eextern  | 声明变量或函数是在其它文件或本文件的其他位置定义              |
| float    | 声明浮点型变量或函数返回值类型                                |
| for      | 一一种循环语句                                                |
| ggoto    | 无条件跳转语句                                                |
| if       | 条件语句                                                      |
| int      | 声明整型变量或函数                                            |
| long     | 声明长整型变量或函数返回值类型                                |
| register | 声明寄存器变量                                                |
| return   | 子程序返回语句（可以带参数，也可不带参数）                    |
| short    | 声明短整型变量或函数                                          |
| signed   | 声明有符号类型变量或函数                                      |
| sizeof   | 计算数据类型或变量长度（即所占字节数）                        |
| static   | 声明静态变量                                                  |
| struct   | 声明结构体类型                                                |
| switch   | 用于开关语句                                                  |
| typedef  | 用以给数据类型取别名                                          |
| unsigned | 声明无符号类型变量或函数                                      |
| union    | 声明共用体类型                                                |
| void     | 声明函数无返回值或无参数，声明无类型指针                      |
| volatile | 说明变量在程序执行中可被隐含地改变                            |
| while    | 循环语句的循环条件                                            |
|          |                                                               |

** 空格
在 C 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。

int age;

在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。

** 修饰符
C++ 允许在char,int 和 double 数据类型放置修饰符，修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。

数据类型修饰符：

- unsigned

- signed

- long

- short

修饰符 signed，unsigned，long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型。修饰符signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀，例如，unsigned long int.

在C++ 中有符号整数和无符号整数修饰符之间是有差别的。

#+begin_src c :includes <stdio.h>
  int main() {
    short int i; //有符号短整数
    short unsigned int j;//无符号短整数

    j = 50000;

    i = j;

    std::cout << i << " " << j;

    return 0;
  }
  /* -15536 50000 */
#+end_src

上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。

** 运算符

- 算术运算符

+\-\*\/\%\++\--

- 关系运算符

==\!=\>\<\>=\<=

- 逻辑运算符

&&\||\!


|运算符	| 描述 |	实例 |
|&&|	称为逻辑与运算符。如果两个操作数都非零，则条件为真。 |	(A && B) 为假。 |
||||    称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 |
|!|	称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。| (A || B) 为真。|


- 位运算符

- 赋值运算符
- 杂项运算符

|运算符 |	描述 |	实例 |
|+ |	把两个操作数相加 |	A + B 将得到 30 |
|-10 |  从第一个操作数中减去第二个操作数 |	A - B 将得到 -10|
|*|	把两个操作数相乘 |	A * B 将得到 200|
|/|	分子除以分母|	B / A 将得到 2|
|%|	取模运算符，整除后的余数|	B % A 将得到 0|
|++|	自增运算符，整数值增加 1|	A++ 将得到 11|
|--|	自减运算符，整数值减少 1|	A-- 将得到 9|

** 存储类
存储类定义C++ 程序中变量/函数的范围（可见性）和生命周期，这些说明符放置在它们所修饰的类型之前。

- auto

#+begin_src c :includes <stdio.h>
auto f=3.14;      //double
auto s("hello") //const char*
auto z = new auto(9) //int*
#+end_src

以下是错误例子：

#+begin_src c :includes <stdio.h>
  auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型
#+end_src

- register

- static

- extern

- mutable

- thread_local

** 判断
1.if 语句。一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。

2.if...else 语句。一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。

3.嵌套 if 语句。可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。

4.switch 语句。一个 switch 语句允许测试一个变量等于多个值时的情况。

5.嵌套 switch 语句。您可以在一个 switch 语句内使用另一个 switch 语句。
在 C 中，if else 还可以用以下代码表示。
#+begin_src c :includes <stdio.h>
  int main()
{
    int num;
    printf("输入一个数字 ： ");
    scanf("%d", &num);
    (num%2==0)?printf("偶数"):printf("奇数");
}
#+end_src

*** switch
意思是先计算表达式的值，再逐个和 case 后的常量表达式比较，若不等则继续往下比较，若一直不等，则执行 default 后的语句；若等于某一个常量表达式，则从这个表达式后的语句开始执行，并执行后面所有 case 后的语句。

与 if 语句的不同：if 语句中若判断为真则只执行这个判断后的语句，执行完就跳出 if 语句，不会执行其他 if 语句；而 switch 语句不会在执行判断为真后的语句之后跳出循环，而是继续执行后面所有 case 语句。在每一 case 语句之后增加 break 语句，使每一次执行之后均可跳出 switch 语句，从而避免输出不应有的结果。
    #+begin_src c :includes <stdio.h>
      #include <stdio.h>
int main()
{
    int a;
    printf("input integer number: ");
    scanf("%d",&a);
    switch(a)
    {
    case 1:printf("Monday\n");
        break;
    case 2:printf("Tuesday\n");
        break;
    case 3:printf("Wednesday\n");
        break;
    case 4:printf("Thursday\n");
        break;
    case 5:printf("Friday\n");
        break;
    case 6:printf("Saturday\n");
        break;
    case 7:printf("Sunday\n");
        break;
    default:printf("error\n");
    }
}
    #+end_src

** struct
C 数组允许定义可存储相同类型数据项的变量,结构是 c 编程中另一种用户自定义的可用的
数据类型,它允许可以存储不同类型的数据项.

为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：

#+begin_src c :includes <stdio.h>
struct tag {
    member-list
    member-list
    member-list
    ...
} variable-list ;
#+end_src
tag 是结构体标签。member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。


#+begin_src c :includes <stdio.h>
#include <string.h>
#include <stdio.h>//引入头文件
struct Books{
    char title[50];
    char author[50];
    char subject[100];
    int book_id;
};
int main()
{
    struct Books Book1;
    struct Books Book2;

    /*Book1 详述*/
    strcpy(Book1.title, "c programming");
    strcpy(Book1.author, "nuha ali");
    strcpy(Book1.subject, "c programming tutorial");
    Book1.book_id = 6495407;
    printf("Book 1 title: %s\n", Book1.title);
    printf("Book 1 author: %s\n", Book1.author);
    printf("Book 1 subject: %s\n", Book1.subject);
    printf("Book 1 book_id: %s\n", Book1.book_id);
    return 0;
}
#+end_src

struct 还可以表示位域.位域声明的形式如下:

#+begin_src c
struct
{
    type [member_name] : width ;
};
#+end_src
type:只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型，决定了如何解释位域的值。

member_name:位域的名称。width:位域中位的数量。宽度必须小于或等于指定类型的位宽度。

带有预定义宽度的变量被称为位域。位域可以存储多于 1 位的数，例如，需要一个变量来存储从 0 到 7 的值，您可以定义一个宽度为 3 位的位域，如下：

#+begin_src c
struct
{
  unsigned int age : 3;
} Age;
#+end_src
上面的结构定义指示 C 编译器，age 变量将只使用 3 位来存储这个值，如果您试图使用超过 3 位，则无法完成。

#+begin_src c :includes <stdio.h>
#include <string.h>
#include <stdio.h>//引入头文件
struct {
    unsigned int age : 3;
} Age;
int main(){
    Age.age = 4;
    printf("Sizeof(Age) : %d\n", sizeof(Age));
    printf("Age.age : %d\n", Age.age);
    Age.age = 8;
    printf("Age.age : %d\n", Age.age);
    return 0;
}
#+end_src

** union

共同体是一种特殊的数据类型,允许可以在相同的内存位置存储不同的数据类型.

#+begin_src c :includes <stdio.h>
union Data
{
    int i;
    float f;
    char  str[20];
} data;
#+end_src
现在，Data 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。

#+begin_src c :includes <stdio.h>
#include <string.h>
#include <stdio.h>//引入头文件
union Data{
    int i;
    float f;
    char str[20];
};

int main(){
    union Data data;
    data.i = 10;
    data.f = 220.5;
    strcpy(data.str, "c programming");
    printf("data.i :%d\n",data.i);
    printf("data.f :%f\n",data.f);
    printf("data.str :%s\n",data.str);
    return 0;
}
#+end_src

** typedef
C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字.按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母，如下：

#+begin_src c :includes <stdio.h>
typedef unsigned char byte;
#+end_src

您也可以使用 typedef 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量.
#+begin_src c :includes <stdio.h>
typedef struct Books
{
    char  title[50];
    char  author[50];
    char  subject[100];
    int   book_id;
} Book;

int main( )
{
    Book book;

    strcpy( book.title, "C 教程");
    strcpy( book.author, "Runoob");
    strcpy( book.subject, "编程语言");
    book.book_id = 12345;

    printf( "书标题 : %s\n", book.title);
    printf( "书作者 : %s\n", book.author);
    printf( "书类目 : %s\n", book.subject);
    printf( "书 ID : %d\n", book.book_id);

    return 0;
}

#+end_src

** 循环
我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。

- 循环类型

1.while 循环。当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。

2.for 循环。多次执行一个语句序列，简化管理循环变量的代码。

3.do...while 循环。除了它是在循环主体结尾测试条件外，其他与 while 语句类似。

4.嵌套循环。您可以在 while、for 或 do..while 循环内使用一个或多个循环。

- 循环控制语句

1.break 语句。终止循环或 switch 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。

2.continue 语句。告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。

3.goto 语句。将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。

如果条件永远不为假，则循环将变成无限循环。for 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。

#+begin_src c :includes <stdio.h>
  #include <stdio.h>//引入头文件
int main()
{
    for ( ; ; ) {
        printf("该循环会永远执行下去！\n");
    }
    return 0;
}
#+end_src

*** while
 #+begin_src c :includes <stdio.h>
   #include <stdio.h>//引入头文件
 int main(){
     int sum = 0;
     int num = 1;
     int sum2 = 0;
     int num2 = 2;
     while (num<100){
         sum = sum + num;
         num = num + 2;
     }
     printf("奇数和为:%d\n",sum);
     while (num2 <= 100){
         sum2 = sum2 + num2;
         num2 = num2 + 2;
     }
     printf("偶数和为：%d\n",sum2);
 }
 #+end_src

*** for

  #+begin_src c :includes <stdio.h>
    int main(){
        int sum=0;
        int sum2=0;
        int num,num2;
        for (num = 1; num < 100; num = num+2){
            sum = sum + num;
        }
        printf("奇数和为：%d\n",sum);
        for (num2=2;num2<=100;num2=num2+2){
            sum2 = sum2 + num2;
        }
        printf("偶数和为：%d\n",sum2);
    }

  #+end_src

#+begin_src c
  #include <iostream>
#include <iomanip>
using namespace std;

int main(){
  int i,j;
  for(i = 1; i < 10; i++){
    for (int j = 1; j <= i; j++) {
      cout << j << " x " << i << " = " << setw(2) << i * j << " ";
    }
    cout << endl << endl;
  }
}
#+end_src

** 函数
函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。

您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。

C 语言函数形式如下：

#+begin_src c :includes <stdio.h>
  return_type function_name( parameter list )
{
   body of the function
}
#+end_src

在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：

- 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。

- 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。

- 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。

- 函数主体：函数主体包含一组定义函数执行任务的语句。

#+begin_src c :includes <stdio.h>
/*函数声明*/
  int max(int num1, int num2);
int main()
{
    /*局部变量定义*/
    int a = 100;
    int b = 200;
    int  ret;

    /*调用函数来获取最大值*/
    ret = max(a, b);
    printf("Max value is : %d\n", ret);
    return 0;
}

  /*函数返回两个数中较大的那个数*/
int max(int num1, int num2){
    /*局部变量声明*/
    int result;
    if (num1 > num2)
        result = num1;
    else
        result = num2;
    return result;
}
#+end_src

- 函数参数

如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。当调用函数时，有两种向函数传递参数的方式：

1.传值调用。该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。

2.引用调用。通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。

c++11 提供了匿名函数的支持，称为lambda 函数（也叫Lambda 表达式）。

Lambda 表达式具体形式如下：

[capture](parameterw)->return-type{body}

例如：

[](int x, int y){return x < y ;}

** getchar
int getchar(void) 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。

int putchar(int c)函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。

#+begin_src c :includes <stdio.h>
//#include <stdlib.h>
#include <string.h>
#include <stdio.h>
int main()
{
    int c;
    printf("enter a value:");
    c = getchar();
    printf("\n You entered:");
    putchar(c);
    printf("\n");
    return 0;
}
#+end_src

** gets

char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区，直到一个终止符或 EOF。int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。

#+begin_src c :includes <stdio.h>
#include <string.h>
#include <stdio.h>
int main()
{
    char str[100];
    printf("enter a value:");
    gets(str);

    printf("\n you entered: ");
    puts(str);
    return 0;
}

#+end_src

** scanf
int scanf(const char *format, ...) 函数从标准输入流 stdin 读取输入，并根据提供的 format 来浏览输入。int printf(const char *format, ...) 函数把输出写入到标准输出流 stdout ，并根据提供的格式产。format 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。还有许多其他可用的格式选项，可以根据需要使用。如需了解完整的细节，可以查看这些函数的参考手册。现在让我们通过下面这个简单的实例来加深理解：

#+begin_src c :includes <stdio.h>
//#include <stdlib.h>
#include <string.h>
#include <stdio.h>
int main(){
    char str[100];
    int i;
    printf("enter a value:");
    scanf("%s %d", str, &i);
    printf("\nyou entered:%s %d", str, i);
    printf("\n");
    return 0;
}

#+end_src


#+begin_src c :includes <stdio.h>
#include<stdio.h>
#+end_src

** 类型变换
在 c 中，可以很方便地强制类型转换运算符号。
语法是 (type_name) expression.

   #+begin_src c
     int main()
{
    int sum = 17, count = 5;
    double mean;

    mean = (double) sum / count;
    printf("Value of mean : %f\n", mean );

}
   #+end_src

** 错误处理

   C 语言提供了 perror() 和 strerror() 函数来显示与 errno 相关的文本消息。perror()

   函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用 stderr 文件流来输出所有的错误。

#+begin_src c :includes <stdio.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>

extern int errno ;

int main ()
{
    FILE * pf;
    int errnum;
    pf = fopen ("unexist.txt", "rb");
    if (pf == NULL)
    {
        errnum = errno;
        fprintf(stderr, "错误号: %d\n", errno);
        perror("通过 perror 输出错误");
        fprintf(stderr, "打开文件错误: %s\n", strerror( errnum ));
    }
    else
    {
        fclose (pf);
    }
    return 0;
}
   #+end_src

** C 数据类型

1.基本类型：它们是算术类型，包括两种类型：整数类型和浮点类型。

2.枚举类型：它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。

3.void 类型：类型说明符 void 表明没有可用的值。

4.派生类型：它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。

- 整数类型：

| 类型           | 存储大小           | 值范围                                               |
| char           | 1 字节             | -128 到 127 或 0 到 255                              |
| unsigned char  | 1 字节	0 到 255 |                                                      |
| signed char    | 1 字节             | -128 到 127                                          |
| int            | 2 或 4 字节        | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| uunsigned int  | 2 或 4 字节        | 0 到 65,535 或 0 到 4,294,967,295                    |
| short          | 2 字节             | -32,768 到 32,767                                    |
| unsigned short | 2 字节             | 0 到 65,535                                          |
| long           | 4 字节             | -2,147,483,648 到 2,147,483,647                      |
| unsigned long  | 4 字节             | 0 到 4,294,967,295                                   |

- 浮点类型

| 类型        |         | 存储大小               | 值范围    | 精度 |
| float       | 4 字节  | 1.2E-38 到 3.4E+38     | 6 位小数  |      |
| ddouble     | 8 字节  | 2.3E-308 到 1.7E+308   | 15 位小数 |      |
| long double | 16 字节 | 3.4E-4932 到 1.1E+4932 | 19 位小数 |      |

- void

void 类型指定没有可用的值。它通常用于以下三种情况下：


1.函数返回为空 C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);
2.函数参数为空 C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);
3.指针指向 void 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。

** 作用域规则
任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：

1.在函数或块内部的局部变量

2.在所有函数外部的全局变量

3.在形式参数的函数参数定义中

在程序中，局部变量和全局变量的名称可以相同，但是在函数内， *如果两个名字相同，会使用局部变量值，全局变量不会被使用。*

#+begin_src c :includes <stdio.h>
 #include <stdio.h>//引入头文件
/*全局变量声明*/
int g = 20;
static int max(int num1, int num2);
int main()
{
    /*局部变量声明 */
    int a = 100;
    int b = 200;
    int  ret;
    ret = max(a, b);
    printf("Max value is : %d\n", ret);
    return 0;
}
#+end_src

- 形式参数

函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用。
#+begin_src c :includes <stdio.h>
 #include <stdio.h>//引入头文件
/*全局变量声明*/
int a = 20;
int main ()
{
    /* 在主函数中的局部变量声明 */
    int a = 10;
    int b = 20;
    int c = 0;
    int sum(int, int);

    printf ("value of a in main() = %d\n",  a);
    c = sum( a, b);
    printf ("value of c in main() = %d\n",  c);

    return 0;
}

/* 添加两个整数的函数 */
int sum(int a, int b)
{
    printf ("value of a in sum() = %d\n",  a);
    printf ("value of b in sum() = %d\n",  b);

    return a + b;
}

#+end_src

#+begin_src python
 #include <stdio.h>//引入头文件
/*全局变量声明*/
int test(int,int); // 形参，只声明

int main()
{
    int a,b;
    printf("%d",test(5,3)); // 实参，已赋值
}

int test(int a,int b) // 形参
{
    a=a+b;
    return a;
}
#+end_src

** 类

自己对类的理解：其实就是一些已经封装好的函数。

关键字public 确定了类成员的访问属性，在类对象作用域内，公共成员在类的外部是可访问的，您也可以指定类的成员为private 或 protected.

#+begin_src c
  #include <iostream>
using namespace std;

class Box
{
 public:
  double length;   // 长度
  double breadth;  // 宽度
  double height;   // 高度
};

int main( )
{
  Box Box1;        // 声明 Box1，类型为 Box
  Box Box2;        // 声明 Box2，类型为 Box
  double volume = 0.0;     // 用于存储体积

  // box 1 详述
  Box1.height = 5.0;
  Box1.length = 6.0;
  Box1.breadth = 7.0;

  // box 2 详述
  Box2.height = 10.0;
  Box2.length = 12.0;
  Box2.breadth = 13.0;

  // box 1 的体积
  volume = Box1.height * Box1.length * Box1.breadth;
  cout << "Box1 的体积：" << volume <<endl;

  // box 2 的体积
  volume = Box2.height * Box2.length * Box2.breadth;
  cout << "Box2 的体积：" << volume <<endl;
  return 0;
}
#+end_src

概念	描述

类成员函数	类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。

类访问修饰符	类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。

构造函数 & 析构函数	类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。

C++ 拷贝构造函数	拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。

C++ 友元函数	友元函数可以访问类的 private 和 protected 成员。

C++ 内联函数	通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。

C++ 中的 this 指针	每个对象都有一个特殊的指针 this，它指向对象本身。

C++ 中指向类的指针	指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。

C++ 类的静态成员	类的数据成员和函数成员都可以被声明为静态的。

** 继承

面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。

当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。

*这个已有的类称为基类，新建的类称为派生类。*

继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。

一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：
class derived-class: access-specifier base-class.

#+begin_src c
  #include <iostream>

using namespace std;

// 基类
class Shape
{
 public:
  void setWidth(int w)
  {
    width = w;
  }
  void setHeight(int h)
  {
    height = h;
  }
 protected:
  int width;
  int height;
};

// 派生类
class Rectangle: public Shape
{
 public:
  int getArea()
  {
    return (width * height);
  }
};

int main(void)
{
  Rectangle Rect;

  Rect.setWidth(5);
  Rect.setHeight(7);

  // 输出对象的面积
  cout << "Total area: " << Rect.getArea() << endl;

  return 0;
}
#+end_src


访问控制和继承

派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。我们可以根据访问权限总结出不同的访问类型，如下所示：

访问	public	protected	private

同一个类	yes	yes	yes

派生类	yes	yes	no

外部的类	yes	no	no

一个派生类继承了所有的基类方法，但下列情况除外：

- 基类的构造函数、析构函数和拷贝构造函数。
- 基类的重载运算符。
- 基类的友元函数。

继承类型

当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。

我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则：

- 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。

- 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。

- 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。

多继承

多继承即一个子类可以有多个父类，它继承了多个父类的特性。C++ 类可以从多个类继承成员，语法如下：

#+begin_src python
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…
{
<派生类类体>
};
#+end_src

其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例。

#+begin_src c
#include <iostream>

using namespace std;

// 基类 Shape
class Shape
{
 public:
  void setWidth(int w)
  {
    width = w;
  }
  void setHeight(int h)
  {
    height = h;
  }
 protected:
  int width;
  int height;
};

// 基类 PaintCost
class PaintCost
{
 public:
  int getCost(int area)
  {
    return area * 70;
  }
};

// 派生类
class Rectangle: public Shape, public PaintCost
{
 public:
  int getArea()
  {
    return (width * height);
  }
};

int main(void)
{
  Rectangle Rect;
  int area;

  Rect.setWidth(5);
  Rect.setHeight(7);

  area = Rect.getArea();

  // 输出对象的面积
  cout << "Total area: " << Rect.getArea() << endl;

  // 输出总花费
  cout << "Total paint cost: $" << Rect.getCost(area) << endl;

  return 0;
}
#+end_src

另外多继承(环状继承),A->D, B->D, C->(A，B)，例如：

#+begin_src c
class D{......};
class B: public D{......};
class A: public D{......};
class C: public B, public A{.....};
#+end_src

这个继承会使D创建两个对象,要解决上面问题就要用虚拟继承格式
格式：class 类名: virtual 继承方式 父类名

#+begin_src c
class D{......};
class B: virtual public D{......};
class A: virtual public D{......};
class C: public B, public A{.....};
#+end_src

虚继承--（在创建对象的时候会创建一个虚表）在创建父类对象的时候
#+begin_src c
A:virtual public D
B:virtual public D
#+end_src

#+begin_src c
  #include <iostream>

using namespace std;
//基类

class D
{
 public:
  D(){cout<<"D()"<<endl;}
  ~D(){cout<<"~D()"<<endl;}
 protected:
  int d;
};

class B:virtual public D
{
 public:
  B(){cout<<"B()"<<endl;}
  ~B(){cout<<"~B()"<<endl;}
 protected:
  int b;
};

class A:virtual public D
{
 public:
  A(){cout<<"A()"<<endl;}
  ~A(){cout<<"~A()"<<endl;}
 protected:
  int a;
};

class C:public B, public A
{
 public:
  C(){cout<<"C()"<<endl;}
  ~C(){cout<<"~C()"<<endl;}
 protected:
  int c;
};

int main()
{
  cout << "Hello World!" << endl;
  C c;   //D, B, A ,C
  cout<<sizeof(c)<<endl;
  return 0;
}
#+end_src

** 重载运算符和重载函数
C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为 *函数重载和运算符重载。*

重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。

当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。

#+begin_src c
#include <iostream>
using namespace std;

class printData
{
public:
void print(int i) {
cout << "整数为: " << i << endl;
}

void print(double  f) {
cout << "浮点数为: " << f << endl;
}

void print(char c[]) {
cout << "字符串为: " << c << endl;
}
};

int main(void)
{
printData pd;

// 输出整数
pd.print(5);
// 输出浮点数
pd.print(500.263);
// 输出字符串
char c[] = "Hello C++";
pd.print(c);

return 0;
}
#+end_src

C++ 中的运算符重载

您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

#+begin_src c
Box operator+(const Box&);
#+end_src

#+begin_src c
#include <iostream>
using namespace std;

class Box
{
public:

    double getVolume(void)
    {
        return length * breadth * height;
    }
    void setLength( double len )
    {
        length = len;
    }

    void setBreadth( double bre )
    {
        breadth = bre;
    }

    void setHeight( double hei )
    {
        height = hei;
    }
    // 重载 + 运算符，用于把两个 Box 对象相加
    Box operator+(const Box& b)
    {
        Box box;
        box.length = this->length + b.length;
        box.breadth = this->breadth + b.breadth;
        box.height = this->height + b.height;
        return box;
    }
private:
    double length;      // 长度
    double breadth;     // 宽度
    double height;      // 高度
};
// 程序的主函数
int main( )
{
    Box Box1;                // 声明 Box1，类型为 Box
    Box Box2;                // 声明 Box2，类型为 Box
    Box Box3;                // 声明 Box3，类型为 Box
    double volume = 0.0;     // 把体积存储在该变量中

    // Box1 详述
    Box1.setLength(6.0);
    Box1.setBreadth(7.0);
    Box1.setHeight(5.0);

    // Box2 详述
    Box2.setLength(12.0);
    Box2.setBreadth(13.0);
    Box2.setHeight(10.0);

    // Box1 的体积
    volume = Box1.getVolume();
    cout << "Volume of Box1 : " << volume <<endl;

    // Box2 的体积
    volume = Box2.getVolume();
    cout << "Volume of Box2 : " << volume <<endl;

    // 把两个对象相加，得到 Box3
    Box3 = Box1 + Box2;

    // Box3 的体积
    volume = Box3.getVolume();
    cout << "Volume of Box3 : " << volume <<endl;

    return 0;
}
#+end_src

** 变量
变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。

变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：

type variable_list;

在这里，type 必须是一个有效的 C 数据类型，可以是 char、w_char、int、float、double 或任何用户自定义的对象，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：

int    i, j, k;
char   c, ch;
float  f, salary;
double d;

变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：

type variable_name = value;

一些实例：

extern int d = 3, f = 5;    // d 和 f 的声明与初始化
int d = 3, f = 5;           // 定义并初始化 d 和 f
byte z = 22;                // 定义并初始化 z
char x = 'x';               // 变量 x 的值为 'x'

- C 中的变量声明

变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。

变量的声明有两种情况：

1.一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。
2.另一种是不需要建立存储空间的，通过使用 extern 关键字声明变量名而不定义它。例如：extern int a 其中变量 a 可以在别的文件中定义的。
3. 除非有 extern 关键字，否则都是变量的定义。

#+begin_src c :includes <stdio.h>
  #include <stdio.h>//引入头文件
// 函数外定义变量x和y
int x;
int y;
int addtwosum()
{
// 函数内声明变量x和y为外部变量
extern int x;
extern int y;
// 给外部变量（全局变量）x和y赋值
x = 1;
y = 2;
    return x+y;
}

int main(){
    int result;
    result = addtwosum();
    printf("result 为：%d", result);
    return 0;
}
#+end_src

** 常量
常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。常量就像是常规的变量，只不过常量的值在定义后不能进行修改。

- 整数常量

整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。

- 浮点常量

浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。

- 字符常量

字符常量是括在单引号中，例如，'x' 可以存储在 char 类型的简单变量中。字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：

|转转义序列 |	含义 |
|\\\ |	\ 字符 |
|\\' |	'字符 |
|\\" |	"字符 |
|\?|	? 字符 |
|\a|	警报铃声 |
|\b|	退格键|
|\f|	换页符|
|\n|	换行符|
|\r|	回车|
|\t|	水平制表符|
|\v|	垂直制表符 |
|\ooo|	一到三位的八进制数 |
|\\xhh... |	一个或多个数字的十六进制数 |

#+begin_src c
  int main(){
      printf("Hello\tWorld\n\n");
      return 0;
  }
#+end_src

定义常量，在 c 中，有 2 种简单的定义常量的方式：

1.使用 #define 预处理器。2.使用 const 关键字。

#+begin_src c :includes <stdio.h>
#include <stdio.h>//引入头文件
// 函数外定义变量x和y
#define x 10
#define y 10

int main(){
    int z;
    z = x * y;
    printf("value of z : %d", z);
    return 0;
}
#+end_src

#+begin_src c :includes <stdio.h>
  int main(){
    const int x = 10;
    const int y = 10;
    int z;
    z = x * y;
    printf("value of z : %d", z);
    return 0;
}
#+end_src

** 数组
在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：
type arrayName [ arraySize ].

- 多维数组：C 支持多维数组。多维数组最简单的形式是二维数组。

- 传递数组给函数：您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。

- 从函数返回数组：C 允许从函数返回数组。

- 指向数组的指针：您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。

#+begin_src c :includes <stdio.h>
 #include <stdio.h>//引入头文件
/*全局变量声明*/
int test(int,int); // 形参，只声明

int main()
{
    int n[10];
    int i,j;
    /*初始化数组元素*/
    for (int i = 0; i < 10; ++i) {
        n[i] = i + 100;
    }

/*输出数组中每个元素的值*/
    for (int k = 0; k < 10; ++k) {
        printf("element [%d] = %d\n",k,n[k]);
    }
    return 0;
}
#+end_src

** 字符串
在 C 语言中，字符串实际上是使用 null 字符 '\0' 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。下面的声明和初始化创建了一个 "Hello" 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 "Hello" 的字符数多一个。

#+begin_src c :includes <stdio.h>
#include <stdio.h>//引入头文件
int main()
{
    char greeting[6] = {'h', 'e', '\0'};
    printf("greeting message: %s\n", greeting);
    return 0;
}
#+end_src

strcpy(s1, s2):复制字符串 s2 到字符串 s1。

strcat(s1, s2):连接字符串 s2 到字符串 s1 的末尾。

strlen(s1):返回字符串 s1 的长度。

strcmp(s1, s2):如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。

strchr(s1, ch):返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。

strstr(s1, s2):返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。

#+begin_src c :includes <stdio.h>
#include <string.h>
#include <stdio.h>//引入头文件
int main()
{
    char str1[12] = 'hello';
    char str2[12] = 'world';
    char str3[13];
    int len;
    /*复制 str1 到 str3*/
    strcpy(str3, str1);
    printf("strcpy(str3, str1): %s\n", str3);
    /*连接str1 和 str2*/
    strcat(str1, str2);
    printf("strcat(str1, str2): %s\n", str1);
    /*连接后，str1 的总长度*/
    len = strlen(str1);
    printf("strlen(str1) : %d\n", len);
    return 0;
}
#+end_src

** enum(枚举)

   #+begin_src python

#include <stdio.h>
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};

int main()
{
    enum DAY day;
    day = WED;
    printf("%d",day);
    return 0;
}

//2
#+end_src

输出的是2.

** 指针
C 语言是比较偏低层的语言，因为他的很多操作都是直接针对内存操作的。

通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。 正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。

#+begin_src c
#include <stdio.h>//引入头文件
int main(){
    int var1;
    char var2[10];
    printf("var1 变量的地址：%p\n", &var1);
    printf("var2 变量的地址：%p\n", &var2);
}
// var1 变量的地址：0x7ffee2361818
//var2 变量的地址：0x7ffee236181e
#+end_src

*** 什么是指针？

指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：type *var-name.

在这里，type 是指针的基类型，它必须是一个有效的 C 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：

int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;     /* 一个字符型的指针 */

*** 如何使用指针？
使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：

通过 *ip 返回指定地址的变量的值。

#+begin_src c
 #include <stdio.h>//引入头文件
int main()
{
    int var = 20; /* 实际变量的声明 此时的 VAR 这个变量是存在某个地址的，地址对应某个内存单元，该单元中存储了数据20 */
    int *ip; /* 指针变量的声明 定义了一个指针 即一个内存单元的地址变量 */
    ip = &var;  /* 在指针变量中存储 var 的地址 就是将地址值赋值给指针这个变量*/
/* 在指针变量中存储的地址 利用&符号直接输出了var所存储的数据的内存单元的地址*/
    printf("address of var variable: %p\n", &var);
    /*在指针变量中存储的地址*/
/* 在指针变量中存储的地址 ip代表的是这个赋值到的地址的值 所以输出的是地址值 */
    printf("address stored in ip variable:%p \n",ip);
    /*使用指针访问值*/
 /* 使用指针访问值 *ip代表的是定义到这个内存单元之后，内存单元中所存储的数据的值也就是将20赋值给var中20这个值 */
    printf("value of *ip variable: %d\n",*ip);
}
/* address of var variable: 0x7ffee973584c */
/* address stored in ip variable:0x7ffee973584c  */
/* value of *ip variable: 20 */
#+end_src

#+begin_src python
 int main()
{
    int *ptr = NULL;
    printf("ptr 的地址是 %p\n", ptr);
    return 0;
}
#+end_src

当上面的代码被编译和执行时，它会产生下列结果：ptr 的地址是 0x0.在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。

- 指针的算术运算：可以对指针进行四种算术运算：++、--、+、-

- 指针数组：可以定义用来存储指针的数组。

- 指向指针的指针：C 允许指向指针的指针。

- 传递指针给函数：通过引用或地址传递参数，使传递的参数在调用函数中被改变。

- 从函数返回指针：C 允许函数返回指针到局部变量、静态变量和动态内存分配。

指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。要理解指针就要先理解计算机的内存。计算机内存会被划分为按顺序编号的内存单元。每个变量都是存储在内存单元中的，称之为地址。

*** 函数指针
函数指针是指向函数的指针变量。通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。函数指针可以像一般函数一样，用于调用函数、传递参数。函数指针变量的声明：

#+begin_quote
typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型
#+end_quote

以下实例声明了函数指针变量 p，指向函数 max.

#+begin_src c :includes <stdio.h>
#include <stdio.h>//引入头文件
int max(int x, int y){
    return x > y ? x : y;
}
int main(void)
{
    /*p 是函数指针*/
    int (*p)(int, int) = & max;//
    int a, b, c, d;
    printf("请输入三个数字：");
    scanf("%d %d %d", &a, &b, &c);
    d = p(p(a, b), c);
    printf("最大的数字是:%d\n",d);
    return 0;
}
#+end_src

*** 回调函数
函数指针作为某个函数的参数函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。

简单讲：回调函数是由别人的函数执行时调用你实现的函数。

#+begin_src c :includes <stdio.h>
#include <stdlib.h>
#include <stdio.h>//引入头文件
//回调函数
void populate_array (int *array, size_t arraySize, int (*getNextValue)(void))
{
    for (size_t i = 0; i<arraySize;i++)
        array[i] = getNextValue();
}
//获取随机值
int getNextRandomValue(void)
{
    return rand();
}

int main(void){
    int myarray[10];
    populate_array(myarray, 10, getNextRandomValue);
    for (int i = 0; i < 10; i++){
        printf("%d\n", myarray[i]);
    }
    printf("\n");
    return 0;
}
#+end_src

一直纠结为啥 int *array, 因为array 是数组。

** #include<stdio.h>

这行代码在 c 语言中真的是十分常见。stdio.h 文件是所有 c 语言编译器的标准部分，用来提供输入和输出的支持。

stdio.h 的含义是 standard input/output header.

** int main(void)
主函数，c 程序规定一个程序中有一个或多个函数，他们是 c 程序的基本模块。但必须有且只有一个 main 函数。因为 c 程序的执行将从 main 函数开始，到 main 函数结束而停止。

在 main(void) 的函数申明中，前面的 int 表示 main() 这个函数在执行完成后返回一个
整数。main 括号里的 void 表示空。

一个 c 程序总是从 main() 函数开始执行的。

***  printf

d,i	以十进制形式输出有符号整数(正数不输出符号)
O	以八进制形式输出无符号整数(不输出前缀 0)
x	以十六进制形式输出无符号整数(不输出前缀 0x)
U	以十进制形式输出无符号整数
f	以小数形式输出单、双精度类型实数
e	以指数形式输出单、双精度实数
g	以%f 或%e 中较短输出宽度的一种格式输出单、双精度 fr实数
C	输出单个字符
S	输出字符串

#+begin_src c
#include <stdio.h>
int main()
{
    int a=12;
    float b=3.1415;
    char c='A';
    printf("%d\n",a);
    printf("o%o\n",a);
    printf("0x%x\n",a);
    printf("%3.2f\n",b);
    printf("%c\n",c);
    getchar();
    return 0;
}
    #+end_src

*** 算术运算符
二元算术运算符包括：＋\-\*\/\%(取模运算符)
#+begin_src c :includes <stdio.h>
  int main(){
      int year=2000;
      if ((year % 4 == 0 && year % 100 !=0 ) || year % 400 == 0)
          printf("%d is a leap year \n", year);
      else
          printf("%d is not a leap year \n", year);

  }
#+end_src

在 c 语言中，运算符&& 的优先级比||的优先级高。

** C++ 11

C++ 仍以C 为基础，区块（blocks），语句（statements），预处理器（preprocessor），内置数据类型（built-in data types），数组（array），指针等均来自C.

C,object-oriented C++,template C++,STL.

*** auto
可以用 auto 直接自动定义变量的类型。
#+begin_src c
  int square2() {
      auto x = 4;
      return x;
}
#+end_src

** 变量与常量数据
| 类型名称       | 占字节数 | 其他叫法           | 表示的数据范围                 |
| char           |        1 | signed char        | -128 ～ 127                    |
| unsigned char  |        1 | none               | 0 ~255                         |
| int            |        4 | signed int         | -2,147,483,648 ~ 2,147,483,647 |
| unsigned int   |        4 | unsigned           | 0 ~ 4,294,967,295              |
| short          |        2 | short int          | -32,768 ~ 32,767               |
| unsigned short |        2 | unsigned short int | 0 ~ 65535                      |
| long           |        4 | long int           | -2,147,483,648 ~ 2,147,483,647 |
| unsigned long  |        4 | unsigned long      | 0 ~ 4,294,967,295              |
| float          |        4 | none               | 3.4E +/- 38 (7 digits)         |
| double         |        8 | none               | 1.7E +/- 308 (15 digits)       |
| long double    |       10 | none               | 1.2E +/- 4932 (19 digits)      |

** 数组
   #+begin_src c

   #+end_src

** sizeof
内存大小。
#+begin_src c :includes <stdio.h>
  int main(){
    printf("hello, world! \n");
    printf("int 存储大小：%lu \n", sizeof(int));
    return 0;
}
#+end_src

** 基本输入与输出
   #+begin_src c
     int main(void)
{
    //char c;
    //c = getchar()
    putchar('A');
}
   #+end_src

** C++ 语言特点

- In the C++ function each line must be terminated with ; In R, we use ; only
  when we have multiple statements on the same line.

- We must declare object types in the C++ version. In particular we need to
  declare the types of the function arguments, return value and any intermediate
  objects we create.

- The function must have an explicit return statement. Similar to R, there can be multiple returns, but the function will terminate when it hits it’s first return statement.

- You do not use assignment when creating a function.Object assignment must use = sign. The <- operator isn’t valid.

- One line comments can be created using //. Multi-line comments are created using /*...*/
** 命名空间
为什么要写 using namespace std; 这句话呢？

这是 c++ 新引入的一个机制，主要为了解决多个模块间命名冲突的问题，就像现实中的两
个人重名一个道理，c++ 把相同的名字都放在不同的空间里，来防止名字的冲突。 好像 r也有这样的机制！

** 常用数据类型
| Type | Description |
|      |             |
char	A single character.char 字符型，占用一个字节，可以存放本地字符集中的一个
字符；
int	An integer. 整型，通常反映了所用机器中的整数自然长度
float	A single precision floating point number.
double	A double-precision floating point number.
void	A valueless quantity.

ANSI C 语言中的全部转义字符序列如下：

\a 响铃符 \\ 反斜杠
\b 回退符 \? 问号
\f 换页符 \' 单引号
\n 换行符 \" 双引号
\r 回车符 \ooo 八进制数
\t 横向制表符 \xhh 十六进制数
\v 纵向制表符 \0 值为 0 的字符

*** const

限定符。任何变量的声明都可以使用 const 限定符限定，该限定符指定变量的值不能被修改。对数组而言，const 限定符指定数组所有元素的值都不能被修改。
const 变量必须被初始化。

#+begin_src python :results output
#include <stdio.h>
#include <iostream>
#include <string.h>
using namespace std;
int main(){
    const int x = 10;
    const int y = 10;
    int z;
    z = x * y;
    printf("value of z : %d", z);
    return 0;
}
#+end_src

*** Vector

#+begin_src C++
 NumericVector V1(n);//创立了一个长度为n的默认初始化的数值型向量V1
 NumericVector V2=NumericVector::create(1, 2, 3); //创立了一个数值型向量V2，并初始化使其含有三个数1，2，3。
 LogicalVector V3=LogicalVector::create(true,false,R_NaN);//创立了一个逻辑型变量V3。如果将其转化为R Object，则其含有三个值TRUE, FALSE, NA。
#+end_src

**** size

向量的大小用 a.size() 来表达。

#+begin_src C++
#include <Rcpp.h>
using namespace Rcpp;
//[[Rcpp::export]]
NumericVector convolveCpp(NumericVector a, NumericVector b){
    int na = a.size(),nb = b.size();
    int nab = na + nb - 1;
    NumericVector xab(nab);

    for(int i=0; i< na; i++)
        for(int j=0; j < nb; j++)
            xab[i+j] += a[i] * b[j];
    return xab;
}
     #+end_src

*** Matrix
#+begin_src c++ :exports code :eval never
NumericMatrix M1(nrow,ncol);//创立了一个nrow*ncol的默认初始化的数值型矩阵。
#+end_src
*** Multidimensional Array

#+begin_src C++ :includes <Rcpp.h>
NumericVector out=NumericVector(Dimension(2,2,3));//创立了一个多维数组。然而我不知道有什么卵用。
#+end_src

*** List

#+begin_src c++ :includes <Rcpp.h>
NumericMatrix y1(2,2);
NumericVector y2(5);
List L=List::create(Named("y1")=y1,
                    Named("y2")=y2);
#+end_src

more examples:

#+begin_src c
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export()]]

List a8(int n, int r, double v){
    arma::mat x1;
    x1.print();
    x1.reshape(n, r);
    x1.fill(v);
    List ret;
    ret["x1"] = x1;
    return(ret);
}
#+end_src


*** DataFrame

    #+begin_src R :results output graphics :file fig_1.png :exports both
      NumericVector a=NumericVector::create(1,2,3);
      CharacterVector b=CharacterVector::create("a","b","c");
      std::vector<std::string> c(3);
      c[0]="A";c[1]="B";c[2]="C";
      DataFrame DF=DataFrame::create(Named("col1")=a,
                                     Named("col2")=b,
                                     Named("col3")=c);
    #+end_src

*** for 循环

#+begin_src c
#include <Rcpp.h>
using namespace Rcpp;
//[[Rcpp::export]]
NumericVector convolveCpp(NumericVector a, NumericVector b){
  int na = a.size(), nb = b.size();
  int nab = na + nb - 1;
  NumericVector xab(nab);

  for(int i=0; i< na; i++)
    for(int j=0; j < nb; j++)
      xab[i+j] += a[i] * b[j];
  return xab;
}

convolveCpp(1:5, 1:3)
#+end_src

从上面的例子可以看出，在 c++ 中，变量函数必须给定数据类型。

函数 convolveCpp 是向量， a.size 是向量的大小。

*** while

while 循环语句的执行方式是这样的：首先测试圆括号中的条件，如果条件为真（fahr<=upper），则执行循环体，然后再重新测试圆括号中的条件，如果为真，则再次执 行循环体；当圆括号中的条件为假，则停止程序。

#+begin_src c :includes <stdio.h>
      double main(){
          int fahr, celsius;
          int lower, upper, step;
          lower = 0;/*温度表的下限*/
          upper = 300;/*温度表的上限*/
          step = 20; /*步长*/

          fahr = lower;
          while(fahr <= upper){
              celsius = 5 * (fahr - 32) / 9;
              printf("%d\t%d\n", fahr, celsius);
              fahr = fahr + step;
          }
      }
    #+end_src

** Rcpp
*** Mac 配置坑
之前，mac 一直编译不通，通过 google，发现~/R/ 目录下没有 Makevars 文件，通过寻
找，可以在 RcppArmadillo 文件下找到类似的文件，然后在增加如下文件。

#+begin_src
 VER=-7
CC=gcc$(VER)
CXX=g++$(VER)
CFLAGS=-mtune=native -g -O2 -Wall -pedantic -Wconversion
CXXFLAGS=-mtune=native -g -O2 -Wall -pedantic -Wconversion
FLIBS=-L/usr/local/Cellar/gcc/7.3.0/lib/gcc/5
CXX1X=g++${VER}
FC=gfortran${VER}
F77=gfortran${VER}
MAKE=make -j4
#+end_src

*** RcppArmadillo
这个包的程序和 matlab 很像。如何将 Rcpp 语法转换为 RcppArmadillo?

| 数据类型  | name   |
| vector    | vec    |
| rowvector | rowvec |
| martix    | mat    |
|           |        |


**** as<arma::>
     #+begin_src c
       arma::mat M1(NumericMatrix x, NumericVector y){
           arma::mat x_ = as<arma::mat>(x);
           arma::vec y_ = as<arma::vec>(y);
           arma::mat z = inv(x_) + y_*y_.t();
           return(arma::diagvec(z));
       }
     #+end_src

**** matrix
矩阵的表示。
#+begin_src C++
  arma::mat betahat = {{1, 3},
                       {2, 4}};
#+end_src

#+begin_src C++
  arma::mat a1 (arma::mat x){
    return x;
}
#+end_src
***** randu 生成
也可以通过 arma::mat X(2,2,arma::fill::randu) 这种方式生成 matrix。
#+begin_src C++
  void test(){
    arma::mat A = {{2,3},{2,4}};
    arma::mat B={{1,2,3},{4,5,6}};
    //arma::mat X = randu<mat>(5,5);
    arma::mat X(2,2,arma::fill::randu);
    Rcpp::Rcout << X << "\n";
    //Rcpp::Rcout << R << "\n";
}
#+end_src

类似地有，arma::mat Y(2,2,arma::fill::randn);
**** 转置
#+begin_src C++
  arma::mat betahat = {{1, 3},
                       {2, 4}};
 betahat.t()
#+end_src
**** as_col/as_row
可以将矩阵变成向量，当然有两种方式，一是行向量，一是列向量。
#+begin_src C++
  void test(){
    arma::mat A = {{1,2},{1,1}};
    arma::mat B = {1, 3};
    //arma::mat X = randu<mat>(5,5);
    //arma::mat X(2,2,arma::fill::randu);
    arma::mat C = arma::solve(A, B.t());
    arma::vec v = A.as_col();
    //arma::mat R;
    //arma::mat Q;
    //arma::qr(Q,R,A);
    // arma::vec a = A.diag();
    // A.resize(1,4);
    // B.copy_size(A);
    // B.set_size(1,4);
    // B.reshape(1,4);
    // B.ones(2,3);
    // B.zeros(2,3);
    // B.randu(3,4);
    // B.randn(3,4);
    // double y = B.is_empty();
    // double y = B.is_finite();//
      // double y = B.is_square();
      // double y = B.is_vec();
    // double y = B.is_sorted();
    // double y = B.has_inf();
    // double y = B.has_nan();
    // arma::mat val = ones<arma::mat>(6, 5);
    //A.for_each([](mat::elem_type& val)
    //   {val += 123.0});
    // arma::vec v = arma::linspace<arma::vec>(10, 15, 6);
    // val.each_col() +=v;
    // A.for_each( [](arma::mat::elem_type& val) { std::cout << val << std::endl; } );
    Rcpp::Rcout << v << "\n";
    //Rcpp::Rcout << R << "\n";
}
#+end_src
**** 求解方程
如果需要求解 AX=B，
#+begin_src C++
  void test(){
    arma::mat A = {{1,2},{1,1}};
    arma::mat B = {1, 3};
    arma::mat C = arma::solve(A, B.t());
    Rcpp::Rcout << v << "\n";
}
#+end_src

**** 求内积
#+begin_src C++
 double g(arma::vec x, arma::vec y) {
  arma::mat d = x.t()*y;
   return d(0);
 }
#+end_src
**** QR 分解
QR 分解 常被用于计算 AX=b 的问题，因为样本量过小的时候(a*a')^-1 计算会变得极其不稳定，这时候就需要用 QR 分解来解决问题。
参考链接为：https://www.zhihu.com/search?type=content&q=QR%20%E5%88%86%E8%A7%A3

QR 分解数学表达式为：$A=QR$, Q 是正交矩阵，R是上三角矩阵。

#+begin_src C++
void test(){
  arma::mat A = {{2,3},{2,4}};
  arma::mat B={{1,2,3},{4,5,6}};
  //arma::mat X = randu<mat>(5,5);
  arma::mat R;
  arma::mat Q;
  arma::qr(Q,R,A);
  // arma::vec a = A.diag();
  // A.resize(1,4);
  // B.copy_size(A);
  // B.set_size(1,4);
  // B.reshape(1,4);
  // B.ones(2,3);
  // B.zeros(2,3);
  // B.randu(3,4);
  // B.randn(3,4);
  // double y = B.is_empty();
  // double y = B.is_finite();//
  // double y = B.is_square();
  // double y = B.is_vec();
  // double y = B.is_sorted();
  // double y = B.has_inf();
  // double y = B.has_nan();
  // arma::mat val = ones<arma::mat>(6, 5);
//A.for_each([](mat::elem_type& val)
//   {val += 123.0});
  // arma::vec v = arma::linspace<arma::vec>(10, 15, 6);
  // val.each_col() +=v;
  // A.for_each( [](arma::mat::elem_type& val) { std::cout << val << std::endl; } );
 Rcpp::Rcout << Q << "\n";
 Rcpp::Rcout << R << "\n";
}
#+end_src
**** eigen value

     #+begin_src c :includes <stdio.h>
       arma::vec getEigenValues(arma::mat M) {
  return arma::eig_sym(M);
}
     #+end_src
**** cholesky 分解
     #+begin_src c
       #include <RcppArmadillo.h>
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat chol(){
  arma::mat x = {{10, 2, 7},
  {2,10,4},
  {7,4,10}};
  arma::mat chol_x = arma::chol(x);
  return chol_x;
}
     #+end_src

**** 矩阵计算
#+begin_src C++
  Rcpp::List a1 (arma::mat x){
    int R = x.n_rows; //矩阵的行数
    int C = x.n_cols; //矩阵的列数
    arma:: vec y = vectorise(x); //矩阵向量化
    Rcpp::NumericMatrix new_x = Rcpp::wrap(x);//arma::mat 转化为Rcpp::NumericMatrix
    Rcpp::Rcout << "Rows:" << R << std::endl; //display R
    Rcpp::Rcout << "cols:" << C << std::endl; //display C
    x.print();
    x.print("Note");
    return Rcpp::List::create(Rcpp::Named("y") = y,
                              Rcpp::Named("newx") = new_x);
}
#+end_src

**** (i)
access the i-th element, assuming a column-by-column layout.
返回的是第 i 个元素。
     #+begin_src matlab
       void test_randu(){
  arma::mat A = arma::randu<arma::mat>(4,5);
  arma::vec a = A.diag();
  double b = a(2);
  Rcpp::Rcout << b << "\n";
}
     #+end_src

**** fill(k)
set all elements to be equal to k.
     #+begin_src matlab
void test_randu(){
  arma::mat A = {{2,3},{2,4}};
  arma::vec a = A.diag();
  arma::mat b = A.fill(2);
  Rcpp::Rcout << b << "\n";
}
     #+end_src

**** abs
绝对值。
#+begin_src c++
  void test(){
arma::mat z = {-1,2};
// Rcpp::Rcout << inv_log(z) << "\n";
//while(change > tol)
//{
 // arma::mat eta = x * beta;
  //Rcpp::Rcout << "a 的值：" << a << "\n";
//  change++;
//}
Rcpp::Rcout << "a 的值：" << arma::abs(z) << "\n";
  }
#+end_src

**** resize
可以对矩阵进行 resize。
     #+begin_src matlab
void test_randu(){
  arma::mat A = {{2,3},{2,4}};
  arma::vec a = A.diag();
  A.resize(1,4);
  Rcpp::Rcout << A << "\n";
}
     #+end_src
*****  reshape

#+begin_src C++
  Rcpp::List a1 (arma::mat x,int n, int r, double v){
    x.print();
    x.reshape(n,r);
    x.fill(v);
    arma:: mat x2 = x;
    x2.reshape(r,n);
    Rcpp::List ret;
    ret["x1"] = x;
    ret["x2"] = x2;
    return(ret);
}
#+end_src

*****  ones/zeros
生成全为 1 或 0 的矩阵。

#+begin_src C++
arma::mat a1 (arma::mat x){
arma::mat y = x.ones();
return y;
#+end_src

*****  index

index the matrix value.
#+begin_src C++
double a1 (arma::mat x, int i, int j){
arma::mat y = x.ones();
return(y(i, j));
#+end_src


#+begin_src C++
  arma::rowvec matrix_locs(arma::mat M,
                           arma::umat locs){
    arma::uvec eids = sub2ind(size(M), locs);
    arma::vec v = M.elem(eids);
    return(v.t());
}
#+end_src

*****  index entire rows
这块内容比较容易错误的是输出的类型是 matrix，而不是 vec。
#+begin_src C++
arma::mat a1 (arma::mat x, int i, int j){
arma::mat y = x.ones();
return(y.row(i);
#+end_src

- index entire columns
这块内容比较容易错误的是输出的类型是 matrix，而不是 vec。
#+begin_src C++
arma::mat a1 (arma::mat x, int i, int j){
arma::mat y = x.ones();
return(y.col(i);
#+end_src

- index multiple rows/columns
可以一次性索引多行/列。
#+begin_src C++
  arma::mat a1 (arma::mat x, int i){
    arma::mat y = x.ones();
    return(y.cols(0,1));
#+end_src


- index multiple rows/columns
可以一次性索引多行/列。

#+begin_src C++
arma::mat a1 (arma::mat x){
return(x + x);
}
#+end_src

#+begin_src C++
arma::mat a1 (arma::mat x){
  return(exp(x));
}
#+end_src

#+begin_src C++
arma::mat a1 (arma::mat x){
  return(x.t());
}
#+end_src

#+begin_src C++
arma::mat a1 (arma::mat x){
  return(x.t()*x);
}
#+end_src

#+begin_src C++
arma::mat a1 (arma::mat x){
  return(inv(x.t()*x));
}
#+end_src

#+begin_src C++
arma::mat a1 (arma::mat x){
  return(chol(x*x.t()));
}
#+end_src

- svd 分解

#+begin_src C++
  Rcpp::List a1 (arma::mat x){
    arma::mat xtx = x.t()*x;
    arma::mat U;
    arma::vec s;
    arma::mat V;
    svd(U, s, V, xtx);
    Rcpp::List ret;
    ret["U"] = U;
    ret["s"] = s;
    ret["V"] = V;
    return(ret);
}
#+end_src

*****  行列式

#+begin_src C++
  double lma(arma::mat X,
             arma::mat y){
    arma::mat betahat;
    double z=arma::det(X); //matrix
                               double x_norm = norm(X);
                               betahat = (X.t()*X).i()*X.t() *y;
                               return(x_norm);
}
#+end_src

**** set_size
change size to specified dimensions, without preserving data.
     #+begin_src matlab
void test_randu(){
  arma::mat A = {{2,3},{2,4},{5,6}};
  arma::mat B={{1,2,3},{4,5,6}};
  arma::vec a = A.diag();
  // A.resize(1,4);
  // B.copy_size(A);
  B.set_size(1,4);
  A.for_each( [](arma::mat::elem_type& val) { std::cout << val << std::endl; } );
  Rcpp::Rcout << B << "\n";
}
     #+end_src

**** 向量操作
***** head/tail
类似 head/tail。
#+begin_src C++
  arma::vec b1(10, arma::fill::randu);
  b1.tail(5) += 123;
  b1.head(3) += 20;
#+end_src

最后 5 个元素和前 3 个元素分别增加 123 和 20.

***** 向量表示
#+begin_src C++
  arma::vec A = {1, 2, 3};
#+end_src
***** Row

vec a(5); a = 123;
vec a(5); a.fill(123);

上面两行代码含义完全不同，第一行的意思只是填充一个值，而第二行代码可以实现 5 个数值均为 123.

#+begin_src C++
  arma::vec a = arma::linspace(0, 5);
  arma::vec a = arma::linspace(0, 5, 6);
#+end_src

***** linspace
这个函数类似于 python 中的 range, 生成一个向量。
linspace(start, end) #如果不指定 N，默认值为 100
linspace(start, end, N)

#+begin_src C++
  arma::vec a = arma::linspace(0, 5);
  arma::vec a = arma::linspace(0, 5, 6);
#+end_src

c++ 真是太严格了，数据的类型必须是严格定义。
linspace 默认输出列向量，可以通过以下代码将其转成行向量。
#+begin_src C++
  arma::vec a = arma::linspace(0, 5);
  arma::vec a = arma::linspace(0, 5, 6);
  arma::rowvec a2 = arma::linspace<arma::rowvec>(0, 5, 6); //转换为行向量
#+end_src
***** regspace
比 linspace 生成更加“标准的”数据。
regspace(0,9) #默认步长是 1;
regspace(0, 3, 9) #步长为 3;

#+begin_src C++
  arma::vec a3 = arma::regspace(0, 9);
#+end_src

***** rbind/cbind
rbind: join_vert(A,B) or join_cols(A,B)

cbind: join_horiz(A,B) or join_rows(A,B)
***** which
which(x>2) 相当于 find(x>2).finite(x) 相当于 find_finite(x)

从以下代码可以看出，A.elem 函数可以遍历 A 的每个数值。

#+begin_src C++
  arma::vec find_equal(arma::vec A,
                       double b){
    arma::uvec idx = arma::find(A == b);
    arma::vec out = A.elem(idx);
    return(out);
}
  //arma::vec lma(arma::vec y,
//    double replace_val = 1.5,
//             double find_val = 3){
//arma::uvec idx = find(y >= find_val);
//y.elem(idx).fill(replace_val);
//arma::mat betahat;
//arma::mat bind_row=arma::join_vert(y, y); //bind_rows操作
//double z=arma::det(X); // 矩阵
                            //double x_norm = norm(X);//
//int rank_x =arma::rank(X);
//arma::mat min_x = arma::min(X, 1);
  //betahat = (X.t()*X).i()*X.t() *y;
//return(y);
  //}
#+end_src
**** member function & variable
**** for loop
iterators are used extensively in the STL, iterators have three main operators:

     #+begin_src matlab
for(const auto& val : A)
  {
  std::cout  << val << std::endl;
  }
  arma::mat::iterator it_end = A.end();
  for(arma::mat::iterator it = A.begin(); it != it_end; ++it)
  {
    std::cout  << (*it) << std::endl;
  }
     #+end_src

     #+begin_src
double sum3(NumericVector x){
  double total = 0;
  NumericVector::iterator it;
  for(it = x.begin(); it != x.end(); ++it){
   total += *it;
  }
  return total;
}

     #+end_src

     #+begin_src c++
void test(){
arma::mat z = {-1,2};
double a = 2;
// Rcpp::Rcout << inv_log(z) << "\n";
//while(change > tol)
//{
 // arma::mat eta = x * beta;
  //Rcpp::Rcout << "a 的值：" << a << "\n";
//  change++;
//}
double N = z.n_cols;
double i;
arma::mat r = {0, 0};
for (i = 0; i < N; i++){
  if(z(0, i) > 0) {
    double b = z(0, i);
    r(0, i) = abs(b) -a;
  }
  else{
    double b = z(0, i);
    r(0, i) = abs(b) + a;
  }
  Rcpp::Rcout <<  r << "\n";
  }
Rcpp::Rcout <<  N << "\n";
//Rcpp::Rcout << "a 的值：" << arma::abs(z) -a << "\n";
}
     #+end_src

C11 标准。

#+begin_src c :includes <stdio.h>
  double sums1(){
  IntegerVector v {1,2,3};
  int sum = 0;
  for(auto& x:v){
    sum += x;
  }
  return(sum);
}
#+end_src

**** for_each
     #+begin_src matlab
void test_randu(){
  arma::mat A = {{2,3},{2,4},{5,6}};
  arma::mat B={{1,2,3},{4,5,6}};
  arma::vec a = A.diag();
  // A.resize(1,4);
  B.copy_size(A);
  A.for_each( [](arma::mat::elem_type& val) { std::cout << val << std::endl; } );
  Rcpp::Rcout << B << "\n";
}
     #+end_src
**** while

     #+begin_src c++
       while(change > tol)
{
  arma::mat eta = x * beta;
  //Rcpp::Rcout << "a 的值：" << a << "\n";
  change++;
}
     #+end_src
**** eye

     #+begin_src c :includes <stdio.h>
       arma::mat chol(){
  arma::mat x = arma::eye(5,5);
  return x;
}
     #+end_src

*** Rcpp
**** attributes
可以生成属性信息。

#+begin_src c :includes <stdio.h>
  #include <Rcpp.h>
// [[Rcpp::export]]
Rcpp::NumericVector attribs(){
  Rcpp::NumericVector out = Rcpp::NumericVector::create(1, 2, 3);
  out.names() = Rcpp::CharacterVector::create("a", "b", "c");
  out.attr("my-attr") = "my-value";
  out.attr("class") = "my-class";
  return out;
  }
#+end_src
**** NA

     #+begin_src c :includes <stdio.h>
       List scalar_missings(){
  int int_s = NA_INTEGER;
  String chr_s = NA_STRING;
  bool lgl_s = NA_LOGICAL;
  double num_s = NA_REAL;
  return List::create(int_s, chr_s, lgl_s, num_s);
}
     #+end_src
**** map
map 类似于 python 中的 set,有一个 value,对应一个 key.

A map is similar to a set, but instead of storing presence or absence, it can
store additional data. It’s useful for functions like table() or match() that need to look up a value.

#+begin_src c :includes <stdio.h>
  #include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export()]]
std::map<double, int> tableC(arma::vec x){
  std::map<double, int> counts;
  int n = x.size();
  for (int i = 0; i < n; i++){
    counts[x[i]]++;
  }
  return counts;
  }

#+end_src
**** List

     #+begin_src R :results output graphics :file fig_1.png :exports both
       List fx(List input){
           std::vector<double> x = input["x"];
           return List::create(_["front"] = x.front(),
                               _["back"] = x.back());
       }
       ## > input <-list(x =seq(1,10,by =0.5) )
       ## > fx(input)
       ## $front
       ## [1] 1
       ## $back
       ## [1] 10
     #+end_src
***** list2data.frame
下面的代码可以很快地实现 as.data.frame
      #+begin_src c :includes <stdio.h>
        List CheapDataFrameBuilder(List a) {
  List returned_frame = clone(a);
  GenericVector sample_row = returned_frame(0);

  StringVector row_names(sample_row.length());
  for (int i = 0; i < sample_row.length(); ++i) {
    char name[5];
    sprintf(&(name[0]), "%d", i);
    row_names(i) = name;
  }
  returned_frame.attr("row.names") = row_names;

  StringVector col_names(returned_frame.length());
  for (int j = 0; j < returned_frame.length(); ++j) {
    char name[6];
    sprintf(&(name[0]), "X.%d", j);
    col_names(j) = name;
  }
  returned_frame.attr("names") = col_names;
  returned_frame.attr("class") = "data.frame";

  return returned_frame;
}
      #+end_src

**** surgar
可以让 R 中现成的函数应用在 C 中。可以用 R 风格编写 C++ 代码。
***** pow
surgar 可以让很多复杂的事情简单化。

 #+begin_src R :results output graphics :file fig_1.png :exports both
   arma::vec res_c(arma::vec x, arma::vec y){
       return pow(x - y, 2);
   }
 #+end_src

 #+begin_src R :results output graphics :file fig_1.png :exports both
   arma::vec res_c(arma::vec x, arma::vec y){
       int i;
       int n = x.size();
       arma::vec residuals(n);
       for(i = 0; i < n; i++){
           residuals[i] = pow(x[i] - y[i], 2);
       }
       return residuals;
   }
 #+end_src
***** is_true

      #+begin_src c :includes <stdio.h>
        #include <RcppArmadillo.h>
#include <Rcpp.h>
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]

bool all_sug(Rcpp::LogicalVector x){
  return Rcpp::is_true(all(x == TRUE));
}

      #+end_src

***** all

      #+begin_src R :results output graphics :file fig_1.png :exports both
        #include <RcppArmadillo.h>
                                        #include <Rcpp.h>
        // [[Rcpp::depends(RcppArmadillo)]]
        // [[Rcpp::export]]

        bool all_sug(Rcpp::LogicalVector x){
            return Rcpp::is_true(all(x == TRUE));
        }
        // [[Rcpp::export]]
        void check_equal(Rcpp::NumericVector x, Rcpp::NumericVector y){
            if (all_sug(x == y)){
                Rcpp::Rcout << "Success! The input vectors are equal!" << std::endl;
            }else{
                Rcpp::Rcout << "Fail!" << std::endl;
            }
        }

      #+end_src

***** is_na

      #+begin_src R :results output graphics :file fig_1.png :exports both
        bool check_na(Rcpp::NumericVector x){
            //Rcpp::NumericVector x = seq_len(10);
            return Rcpp::is_na(any(x<2));
        }
      #+end_src
***** seq_len

      #+begin_src c :includes <stdio.h>
        Rcpp::IntegerVector seq_length(double x){
  //Rcpp::NumericVector x = seq_len(10);
  return Rcpp::seq_len(x);
}
      #+end_src
***** ifelse
      #+begin_src c :includes <stdio.h>
        Rcpp::IntegerVector if_else_plus(Rcpp::IntegerVector x,
                                 Rcpp::IntegerVector y){
  //Rcpp::NumericVector x = seq_len(10);
  //return Rcpp::seq_len(x);
  return Rcpp::ifelse(x < y, x, (x+y)*y);
}
      #+end_src
***** sign

      #+begin_src c :includes <stdio.h>
        Rcpp::IntegerVector sign_plus(Rcpp::IntegerVector x){
  //Rcpp::NumericVector x = seq_len(10);
  //return Rcpp::seq_len(x);
  return Rcpp::sign(x);
}
      #+end_src
***** diff
插值。
      #+begin_src c :includes <stdio.h>
        Rcpp::IntegerVector diff_plus(Rcpp::IntegerVector x){
  //Rcpp::NumericVector x = seq_len(10);
  //return Rcpp::seq_len(x);
  return Rcpp::diff(x);
}
      #+end_src
**** SEXP
将一个 C++ 对象转换为 R 对象。

#+begin_src R :results output graphics :file fig_1.png :exports both
  SEXP M2(arma::mat x){
      arma::mat z = chol(x);
      int n = x.n_rows;
      int m = x.n_cols;
      arma::mat ONE = arma::ones(m,n);
      arma::mat y = z+ONE;
      return (wrap(arma::det(y)));
  }

#+end_src
**** date
Rcpp 中的时间如何显示。请见下面的例子。
     #+begin_src c :includes <stdio.h>
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export]]
Datetime rcpp_datetime(){
  // Creating Datetime object by specifying date and time to
  Datetime dt("2000-01-01 00:00:00");

  // Displaying parts of the Datetime object in Coordinated Universal Time
  Rcout << "getYear " << dt.getYear() << "\n";
  Rcout << "getMonth " << dt.getMonth() << "\n";
  Rcout << "getDay " << dt.getDay() << "\n";

  Rcout << "getHours " << dt.getHours() << "\n";
  Rcout << "getMinutes " << dt.getMinutes() << "\n";
  Rcout << "getSeconds " << dt.getSeconds() << "\n";

  Rcout << "getMicroSeconds " << dt.getMicroSeconds() << "\n";
  Rcout << "getWeekday " << dt.getWeekday() << "\n";
  Rcout << "getYearday " << dt.getYearday() << "\n";
  Rcout << "getFractionalTimestamp " << dt.getFractionalTimestamp() << "\n";

  return dt;
}
     #+end_src

     #+begin_src c :includes <stdio.h>
       DataFrame rcpp_dataframe(DataFrame Dsexp){
  // Creating Datetime object by specifying date and time to
  DataFrame DF = DataFrame(Dsexp);
  IntegerVector a = DF["a"];
  DateVector c = DF["b"];
  return c;
}
     #+end_src


**** transform/lambda
C++ 里面也有 lambda 函数，想不到吧？？

#+begin_src c :includes <stdio.h>

arma::vec transformEx(const arma::vec x){
  arma::vec y(x.size());
  std::transform(x.begin(), x.end(), y.begin(),
                 [](double x) {return x*x;});
  return y;
}
#+end_src

other version
下面这个例子说明，// [[Rcpp::export()]] 这个命令不是乱放的！
#+begin_src c :includes <stdio.h>
  inline double square(double x) { return x*x;}
// [[Rcpp::export()]]
arma::vec transformEx(const arma::vec x) {
  arma::vec y(x.size());
  std::transform(x.begin(), x.end(), y.begin(), square);
  return y;
}
#+end_src

#+begin_src c :includes <stdio.h>
  #include <RcppArmadillo.h>
#include <cmath>
using namespace Rcpp;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export()]]
Rcpp::NumericMatrix matrixSqrt(Rcpp::NumericMatrix orig) {
  Rcpp::NumericMatrix mat(orig.nrow(), orig.ncol());
  std::transform(orig.begin(), orig.end(), mat.begin(),::sqrt);
  return mat;
}
  /* m <- matrix(c(1,2,3, 11,12,13), nrow = 2, ncol=3) */
/* matrixSqrt(m) */
#+end_src

**** call R function
可以从 C++ 调用 R 函数。
     #+begin_src c :includes <stdio.h>
       NumericVector callFunction(NumericVector x, Function f){
  NumericVector res = f(x);
  return res;
}
       set.seed(42)
x <- rnorm(1e5)
callFunction(x, fivenum)
     #+end_src

**** Rmath
可以从这个函数直接调用 R 中的统计分布函数。
#+begin_src c :includes <stdio.h>
  #include <Rcpp.h>

// [[Rcpp::export]]
Rcpp::NumericVector mypnorm(Rcpp::NumericVector x) {

   int n = x.size();
   Rcpp::NumericVector y(n);

   for (int i=0; i<n; i++)
      y[i] = R::pnorm(x[i], 0.0, 1.0, 1, 0);

   return y;
}

  x <- seq(0, 1, length=1e3)
res <- mypnorm(x)
head(res)
  /* [1] 0.5000 0.5004 0.5008 0.5012 0.5016 0.5020 */
#+end_src

**** Rcount
The way of using Rcout and Rcerr is the same as std::cout and std::cerr. Connecting messages or variables with << in the order you want. When you give a vector object to <<, it will print all the elements of the vector.

C++ 连接信息（message）和变量通过 <<,当你给一个向量对象给<<,那么它将打印所有元素。

#+begin_src c :includes <stdio.h>
  void rcpp_rcount(arma::vec v) {
  Rcout << "the value of v:" << v << "\n";
  Rcerr << "error message\n";
}
#+end_src

**** Rprintf
The way of using Rprintf() and REprintf() is the same as std::printf(), it prints a message by specifying format.

![打印](https://cdn.mathpix.com/snip/images/TK6nn8YjXAHmHnuWYFs_VvjJ5o78Z3XG35J03xRMbE4.original.fullsize.png)

#+begin_src c :includes <stdio.h>
  void rcpp_rprintf(NumericVector v) {
for(int i = 0; i < v.length(); ++i){
  Rprintf("the value of v[%i] : %f \n", i, v[i]);
}
}
#+end_src

**** DataFrame
Rcpp 里也可以有 Dataframe.
     #+begin_src c :includes <stdio.h>
DataFrame rcpp_dataframe(NumericVector Dsexp){
  // Creating Datetime object by specifying date and time to
  DataFrame DF = DataFrame(Dsexp);
  // Displaying parts of the Datetime object in Coordinated Universal Time
  return DF;
}
     #+end_src

     #+begin_src c :includes <stdio.h>
       DataFrame rcpp_dataframe(DataFrame Dsexp){
  // Creating Datetime object by specifying date and time to
  DataFrame DF = DataFrame(Dsexp);
  IntegerVector a = DF["a"];
  DateVector c = DF["b"];
  return c;
}
     #+end_src

*** RcppEign

    #+begin_src c :includes <stdio.h>
      #include <Rcpp.h>
#include <RcppEigen.h>
// [[Rcpp::depends(RcppEigen)]]
// [[Rcpp::export]]
SEXP eigenMapMatMult(const Eigen::Map<Eigen::MatrixXd> A, Eigen::Map<Eigen::MatrixXd> B){
  Eigen::MatrixXd C = A * B;

  return Rcpp::wrap(C);
}
    #+end_src

** print
以下代码类似于 print(A).
#+begin_src C++
    Rcpp::Rcout << A << std::endl;
#+end_src

**** lm 估计
#+begin_src C++
arma::mat lma(arma::mat X,
              arma::mat y){
arma::mat betahat;
betahat = (X.t()*X).i()*X.t() *y;
return(betahat);
}
#+end_src
