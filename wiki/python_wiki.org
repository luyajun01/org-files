# -*- org-confirm-babel-evaluate: nil; -*-
#+PROPERTY: header-args :eval never-export
                                     
* Python_wiki                                                           :toc:
  - [[#python-版本][python 版本]]
  - [[#虚拟环境][虚拟环境]]
  - [[#工作目录][工作目录]]
  - [[#__code__][__code__]]
  - [[#推导式][推导式]]
  - [[#重复次数][重复次数]]
  - [[#聚合][聚合]]
  - [[#外积][外积]]
  - [[#合并数据集][合并数据集]]
  - [[#unionintersectiondifference][union/intersection/difference]]
  - [[#eval][eval]]
  - [[#assert][assert]]
  - [[#统计][统计]]
  - [[#数据清理][数据清理]]
  - [[#类][类]]
  - [[#面向对象技术简介][面向对象技术简介]]
  - [[#转义][转义]]
  - [[#packages][Packages]]
  - [[#python-习题][python 习题]]
  - [[#数据结构][数据结构]]
  - [[#股市量化分析][股市量化分析]]

*** 数据类型
**** 基本数据类型
整数、浮点数、布尔

可以通过 dir() 查看对象的可用的属性，help 可以看到方法。

#+begin_src python
dir(int)
#+end_src

前面的__and__是可用的方法，后面的 bit_length 是可用属性。

**** 容器数据类型
字符、元组、列表、字典、集合

** python 版本

#+begin_src python
import sys
sys.version_info
sys.version
# => '3.7.1 (default, Dec 14 2018, 13:28:58)
#    [Clang 4.0.1 (tags/RELEASE_401/final)]'
#+end_src

** 虚拟环境
*** ubuntu 
在ubuntu 中, https://zhuanlan.zhihu.com/p/81321705。

#+BEGIN_SRC python
;;使用--envs选项(-e)查看所有已创建的虚拟环境,在列出的虚拟环境中,使用星号(*)标识的是当前激活的虚拟环境.
conda info --envs
#+END_SRC

用之前打开m-x venv-workon.

** 工作目录
类似于 R 的 getwd(),setwd().

#+begin_src python
#引入模块，获得工作目录
import os
import import
os.getcwd() #获得当前工作目录
# => '/Users/luyajun/Documents/坚果云/我的坚果云/github/wiki'
os.chcwd('D:/work') #改变工作目录
os.mkdir('work') #建立新目录
os.rmdir('work') #删除目录
os.rename('fff.txt','fool.txt') #重命名
os.remove('h.txt') #删除文件
os.listdir("D:\")#获得当前工作目录下的所有文件
print(list(filter(os.path.isfile, os.listdir()))) #列出当前文件夹下所有文件
print(list(filter(os.path.isdir, os.listdir()))) #列出当前文件夹下所有文件夹
#+end_src

也能获得system 命令

#+begin_src python :results output
import os
os.system("ls")
os.system("ls -l") #more information
os.system("ls -F") #more information
os.system("dir")
os.remove #删除文件
#+end_src

文件通配符

glob 模块提供了一个在目录中使用通配符搜索创建文件列表的函数:

#+begin_src python :results output
import glob
glob.glob('*.py')
#+end_src

** __code__
这个函数可以用来查看变量参数等信息.

#+begin#+begin_example
_src python
def test(x, y = 10):
    x += 100
    print(x, y)
test
# <function __main__.test(x, y=10)>
test.__code__
# <code object test at 0x11d9b15d0, file "<ipython-input-43-3d74f8241943>", line 1>
test.__code__.co_varnames # 参数及变量量名列列表。
# => ('x', 'y')
test.__code__.co_consts # 指令常量
# => (None, 100)
test.__defaults__ # 参数默认值
# => (10,)
test(1)
# => 101 10
,#+end_src

,** python 编辑语法
,*** \
如果代码太长写成一行不便于阅读 可以使用\对代码进行折行.
,#+begin_src python
year = int(input('请输入年份: '))
# 如果代码太长写成一行不便于阅读 可以使用\对代码进行折行
is_leap = year % 4 == 0 and year % 100 != 0 or \
          year % 400 == 0
print(is_leap)
,#+end_src
 
,** 常见函数
,*** def
自定义函数可以通过关键字 def 来定义。在定义函数时给定的名称称作“形参（parameters）”， 在调用函数时你所提供函数的值称作“实参”（arguments）。
,#+begin_src python
def print_max(a, b):
    if a > b:
    print(a, 'is maximum')
elif a == b:
    print(a, 'is equal to', b)
else:
    print(b, 'is maximum')

print_max(3,4)
,#+end_src

,*args 和 **kwargs 主要用于函数定义，你可以将不定数量的参数传递给一个函数，这里的不定的意思是：预先并不知道函数使用者会传递多少个参数给你，所以在这个场景下使用这两个关键字。*

,*args 是用来发送一个非键值对的可变数量的参数列表给一个函数。

,#+begin_src python :results output
def demo(args_f, *args_v):
    print(args_f)
    for x in args_v:
        print(x)

demo('a','b','c')
# => a
#    b
#    c
demo('a', 'b')
# => a
#    b
,#+end_src

,**kwargs 允许你将不定长度的键值对，作为参数传递给一个函数。如果你想要在一个函数里处理带名字的参数，你应该使用 **kwargs.

,#+begin_src python :results output
def demo(**kwargs):
    for k,v in kwargs.items():
        print(k,v)

demo(name='njcx')
# => name njcx
,#+end_src

,**** 递归函数
在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。这个在R 中是无法实现的。
,#+begin_src python
def fact(n):
    if n == 1:
        return 1
    return n * fact(n-1)
fact(3)
# => 6
,#+end_src

,*** 空函数
如果想定义一个什么事也不做的空函数，可以用 pass 语句：

,#+begin_src python
if age >=18:
    pass
,#+end_src

pass 可以用来作为占位符，比如现在还没想好怎么写函数的代码，可以先写一个 pass，让代码能运行起来。

,*** 局部变量
当在一个函数的定义中声明变量时，它们不会以任何方式与身处函数之外但具有相同名称的变量产生关系，也就是说，这些变量名只存在于函数这一局部（local），这被称为变量作用域（scope）。

,#+begin_src python
x = 50
def func(x):
    print("x is", x)
    x = 2
    print('Changed local x to', x)

func(x)
# => x is 50
#    Changed local x to 2
print("x is still", x)
# => x is still 50
,#+end_src

,*** global 语句
在 def 中如果想要全局使用变量应该要加上 global 字段. 在一个函数内部可以修改全局变量.

,#+begin_src python
def say_hello():
    print('hello world')
say_hello()
# => hello world
x = 50
def func():
    global x

    print('x is', x)
    x = 2
    print('Changed global x to', x)

func()
# => x is 2
#    Changed global x to 2
print('Value of x is', x)
# => Value of x is 2
#如果不加上global
x = 50
def func():
    #global x
    print('x is', x)
    x = 2
    print('changed global x to', x)

func()
# => Traceback (most recent call last):
#      File "<stdin>", line 1, in <module>
#      File "/Users/luyajun/Documents/坚果云/我的坚果云/github/wiki/python_wiki.org", line 2, in func
#        #+PROPERTY: header-args :eval never-export
#    UnboundLocalError: local variable 'x' referenced before assignment
,#+end_src

下面 times = 1,就是默认的参数值。
,#+begin_src ipython
def say(message, times=1):
          print(message * times)

say('hello')
say('world',5)
,#+end_src

,*** 关键字参数

,#+begin_src python
def func(a,b=5,c=10):
    print("a is", a, "and b is", b, "and c is", c)

func(3,7)
# => a is 3 and b is 7 and c is 10
func(25,c=7)
# => a is 25 and b is 5 and c is 7
func(c=50, a=100)
# => a is 100 and b is 5 and c is 50
,#+end_src

,*** 可变参数
有时你可能想定义的函数里面能够有任意数量的变量，也就是参数数量是可变的，这可以通过使用星号来实现。

,*** return
return 语句用于从函数中返回，也就是中断函数。命名空间（namespace）

,*** 命名空间和作用域
如果想给一个在程序顶层的变量赋值（也就是说不存在于任何作用域中，无论是函数还是类），那么你必须告诉 python 这一变量并非局部，而是全局（global）。因为在不使用 global 语句的情况下，不可能为一个定义于函数之外的变量赋值。

,*** */**
为了能让一个函数接受任意数量的位置参数，可以使用一个*参数。例如

,#+begin_src python
def avg(first, *rest):
    return (first + sum(rest)) / (1 + len(rest))

# Sample use
avg(1, 2) # 1.5
avg(1, 2, 3, 4) # 2.5
,#+end_src

为了接受任意数量的关键字参数，使用一个以**开头的参数。比如：

,#+begin_src python
def maximun(x, y):
  if x > y:
      return  x
  elif x == y:
      return "The numbers are equal"
  else:
      return y

print(maximun(2, 3))
,#+end_src

从上面两个例子可以看出 * 对应的是任意数量的位置参数,而 ** 对应的是任意数量的关键字参数.还有一种情况是只接受关键字参数的函数.将强制关键字参数放到某个 * 参数或者单个 * 后面就能达到这种效果。

,#+begin_src python
def recv(maxsize, *, block):
   'Receives a message'
   pass

recv(1024, True) # TypeError
recv(1024, block=True) # Ok
,#+end_src

利用这种技术，我们还能在接受任意多个位置参数的函数中指定关键字参数。比如：

,#+begin_src python
import html

def make_element(name, value, **attrs):
    keyvals = [' %s="%s"' % item for item in attrs.items()]
    attr_str = ''.join(keyvals)
    element = '<{name}{attrs}>{value}</{name}>'.format(
                name=name,
                attrs=attr_str,
                value=html.escape(value))
    return element

# Example
# Creates '<item size="large" quantity="6">Albatross</item>'
make_element('item', 'Albatross', size='large', quantity=6)

# Creates '<p>&lt;spam&gt;</p>'
make_element('p', '<spam>')
,#+end_src

,#+begin_src python
def minimum(*values, clip=None):
   m = min(values)
   if clip is not None:
       m = clip if clip > m else m
   return m

minimum(1, 5, 2, -5, 10) # Returns -5
minimum(1, 5, 2, -5, 10, clip=0) # Returns 0
,#+end_src

- 给函数参数增加元信息

好了一个函数，然后想为这个函数的参数增加一些额外的信息，这样的话其他使用者就能清楚的知道这个函数应该怎么使用。函数注解只存储在函数的 __annotations__ 属性中。

import numpy as

,#+begin_src python
def add(x:int, y:int) -> int:
    return x + y

add(1,2)
#> 3

help(add)
#> Help on function add in module __main__:
#>
#> add(x: int, y: int) -> int
#>

add.__annotations__
#> {'x': int, 'y': int, 'return': int}
,#+end_src

- 返回多个值的函数

为了能返回多个值,函数直接 return 一个元组即可.

,#+begin_src python
def myfun():
    return 1,2,3

a, b, c = myfun()
a
#1
b
#2
c
#3
,#+end_src

从本质上看,尽管 myfun() 看上去返回了多个值,实际上是先创建了一个元组然后返回的.

- 定义有默认参数的函数

定义一个有可选参数的函数是非常简单的，直接在函数定义中给参数指定一个默认值，并放到参数列表最后就行了。

,#+begin_src python
  def spam(a, b = 42):
      print(a, b)

  spam(1)
  spam(1, 2)

  _no_value = object()
  def spam(a, b=_no_value):
      if b is _no_value:
          print('No b value supplied')

  spam(1)
  spam(1, 2)
  spam(1,  None)


  def spam(a,b=[]):
      print(b)
      return b

  x = spam(1)
  x.append(99)
  spam(1)
,#+end_src

- 减少可调用对象的参数个数

如果需要减少某个函数的参数个数，你可以使用 functools.partital().

,#+begin_src python
from functools import partial
def spam(a, b, c, d):
    print(a, b, c, d)

s1 = partial(spam, 1)
s1
s1(2, 3, 4)
s2 = partial(spam, d = 42)
s2(1, 2, 3)
s2(4, 5, 5)
s3 = partial(spam, 1, 2, d = 42)
s3(3)
s3(4)
s3(5)
,#+end_src

partial 函数允许你给一个或多个参数设置固定的值，减少接下来被调用时的参数个数。

假设要转换大量的二进制字符串，每次都传入 int(x,base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2 传进去：

,#+begin_src python :results output
import functools
int2 = functools.partial(int, base=2)
int2('1000000')
,#+end_src

需要指出的是这里的 int 是自带函数，而base 是自带参数，只不过partial 确定了参数值。如果没有 partial 函数，那么就需要重新定义int2 函数

,#+begin_src python :results output
def int2(x, base=2):
    return int(x, base)
,#+end_src

- 带额外状态信息的回调函数

你的代码中需要依赖到回调函数的使用(比如事件处理器、等待后台任务完成后的回调等)， 并且你还需要让回调函数拥有额外的状态值，以便在它的内部使用到。

,#+begin_src python
def apply_async(func, args, *, callback):
    result = func(*args)
    callback(result)

def print_result(result):
    print('Got:', result)

def add(x,y):
    return x+y

apply_async(add, (2, 3), callback=print_result)
# Got: 5
,#+end_src

- 访问闭包中定义的变量

,#+begin_src python
def sample():
    n = 0
    def func():
        print('n=', n)
    def get_n():
        return n
    def set_n(value):
        nonlocal n
        n = value
    func.get_n = get_n
    func.set_n = set_n
    return func

f =sample()
f()
# n= 0
f.set_n(10)
f()
# n= 10
f.get_n()
# 10
,#+end_src

为了说明清楚它如何工作的，有两点需要解释一下。首先，nonlocal 声明可以让我们编写函数来修改内部变量的值。其次，函数属性允许我们用一种很简单的方式将访问方法绑定到闭包函数上，这个跟实例方法很像(尽管并没有定义任何类)。

有一个例子可以说明生成器，yield,偏函数的作用！
,#+begin_src python :results output
def multiply():
    return (lambda x: i * x for i in range(4))

print([m(100) for m in multiply()])


def multiply():
    for i in range(4):
        yield lambda x: x * i

print([m(100) for m in multiply()])

from functools import partial
from operator import __mul__

def multiply():
    return [partial(__mul__, i) for i in range(4)]

print([m(100) for m in multiply()])
,#+end_src

,**** 异常处理
到目前为止，在 python 程序中遇到错误，或“异常”，意味着整个程序崩溃。我们不希望这发生在真实世界中，相反希望程序能检测到错误，处理它们，然后继续运行。

,#+begin_src python
def spam(divideBy):
    return 42/ divideBy

print(spam(2))
print(spam(0))
,#+end_src
try 语句的工作原理如下：

- 首先，执行 try 子句 （try 和 except 关键字之间的（多行）语句）。

- 如果没有异常发生，则跳过 except 子句 并完成 try 语句的执行。

- 如果在执行 try 子句时发生了异常，则跳过该子句中剩下的部分。 然后，如果异常的类型和 except 关键字后面的异常匹配，则执行 except 子句，然后继续执行 try 语句之后的代码。

- 如果发生的异常和 except 子句中指定的异常不匹配，则将其传递到外部的 try 语句中；如果没有找到处理程序，则它是一个 未处理异常，执行将停止并显示如上所示的消息。

当试图一个数除以 0 时，就会发生 ZeroDivisionError. 根据错误信息中给出的行号，我们知道 spam() 中的 return 语句导致了一个错误。

错误可以由 try 和 except 语句处理，那些可能出错的语句被放在 try 子句中。如果错误发生，程序执行就转到接下来的 except 子句开始处。

,#+begin_src python
def spam(divideBy):
    try:
        return 42/ divideBy
    except ZeroDivisionError:
        print('Error:Invalid argument.')

print(spam(0))
,#+end_src

try..except..else 没有捕获到异常,执行else 语句. 

try..except..finally 不管是否捕获到异常,都执行finally 语句.


,#+begin_src python
def divide(a,b):
    try:
        return a/b
    except ZeroDivisionError as e:
        raise ValueError("Invalid inputs") from e

divide(1, 0)
# =>
#    ZeroDivisionErrorTraceback (most recent call last)
#    ~/Documents/坚果云/我的坚果云/github/wiki/python_wiki.org in divide(a, b)
#          2 #+PROPERTY: header-args :eval never-export
#    ----> 3
#          4 * Python_wiki                                                           :toc:
#
#    ZeroDivisionError: division by zero
#
#    The above exception was the direct cause of the following exception:
#
#    ValueErrorTraceback (most recent call last)
#    <ipython-input-7-b4d7e8b388b7> in <module>
#    ----> 1 divide(1, 0)
#
#    ~/Documents/坚果云/我的坚果云/github/wiki/python_wiki.org in divide(a, b)
#          3
#          4 * Python_wiki                                                           :toc:
#    ----> 5   - [[#常见问题][常见问题]]
#          6     - [[#语法错误][语法错误]]
#          7     - [[#数据类型][数据类型]]
#
#    ValueError: Invalid inputs
divide(1,1)
# => 1.0
,#+end_src

或者

,#+begin_src python
try:
    print(spam(2))
    print(spam(0))
except ZeroDivisionError:
    print('Error:Invalid argument.')
,#+end_src

在实际工作中，try 一般紧跟抛异常函数 raise。

,#+begin_src python
try:
    a = input("输入一个数：")
    if(not a.isdigit()):
        raise ValueError("a 必须是数字")
except ValueError as e:
    print({"引发异常：", repr(e)})
,#+end_src

正如之前看到的，raise 不需要带参数。

一个 try 语句可能有多个except 子句，以指定不同异常的处理的程序，最多会执行一个处理程序。处理程序只处理相应的try 子句中发生的异常，而不处理同一 try 语句内其他处理程序中的异常。一个 except 子句可以将多个异常命名为带括号的元组。

,#+begin_src python :results output
except(RuntimeError, TypeError, NameError):
    pass
,#+end_src

自定义异常用raise 抛出异常。
,#+begin_src python
 def fn():
    try:
        for i in range(5):
            if i > 2:
                raise Exception("数字大于2")
    except Exception as ret:
        print(ret)

fn()
,#+end_src

,*** isinstance
isinstance() 布尔函数在判定一个对象是否是另一个给定类的实例时，非常有用。

,#+begin_src python :results output
class myclass(object):
    def __init__(self):
        self.foo = 100
myinst = myclass()
isinstance(myinst, myclass)
,#+end_src

,*** super
super() 函数是用于调用父类（超类）的一个方法。 super() 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没有问题，但是如果使用多继承，会涉及到查找顺序（MRO），重复调用等种种问题。

调用父类同名方法有2种方式：

1.调用未绑定的父类方法


,#+begin_src python :results output
class Base(object):
    def greet(self):
        print("hi, i am base")

class A(Base):
    def greet(self):
        Base.greet(self)
        print("hi, i am A")

a = A()
# => <__repl__.A object at 0x12018dcc0>
a.greet()
# => hi, i am base
#    hi, i am A
,#+end_src
这种方式简单还可以，如果在多重继承中就会有问题。

2.使用super 函数来调用

,#+begin_src python :results output
class Base(object):
    def __init__(self):
        print("enter Base")
        print("leave Base")


class A(Base):
    def __init__(self):
        print("enter A")
        Base.__init__(self) #调用父类的构造函数进行初始化
        print("leave A")


class B(Base):
    def __init__(self):
        print("enter B")
        Base.__init__(self) #调用父类的构造函数进行初始化
        print("leave B")

class C(A,B):
    def __init__(self):
        print("enter C")
        A.__init__(self) #调用父类A的构造函数进行初始化
        B.__init__(self) #调用父类B的构造函数进行初始化
        print("leave C")

c=C()
# => enter C
#    enter A
#    enter Base
#    leave Base
#    leave A
#    enter B
#    enter Base
#    leave Base
#    leave B
#    leave C

class Base(object):
    def __init__(self):
        print("enter Base")
        print("leave Base")


class A(Base):
    def __init__(self):
        print("enter A")
        super(A,self).__init__()
        print("leave A")

class B(Base):
    def __init__(self):
        print("enter B")
        super(B,self).__init__()
        print("leave B")

class C(A,B):
    def __init__(self):
        print("enter C")
        super(C,self).__init__()
        print("leave C")

c = C()
# => enter C
#    enter A
#    enter B
#    enter Base
#    leave Base
#    leave B
#    leave A
#    leave C
#    <__repl__.C object at 0x10898d3c8>
C.mro()
# => [__repl__.C, __repl__.A, __repl__.Base, __repl__.B, __repl__.Base, object]
,#+end_src

类C继承自A,B，而A和B又分别继承类Base，每一个类的构造函数分别被调用了一次。

https://blog.csdn.net/wo198711203217/article/details/84097274
MRO 就是类的方法解析顺序表，其实也就是继承父类方法时的顺序表。

那这个 MRO 列表的顺序是怎么定的呢，它是通过一个 C3 线性化算法来实现的，这里我们就不去深究这个算法了，感兴趣的读者可以自己去了解一下，总的来说，一个类的 MRO 列表就是合并所有父类的 MRO 列表，并遵循以下三条原则：

子类永远在父类前面

如果有多个父类，会根据它们在列表中的顺序被检查

如果对下一个类存在两个合法的选择，选择第一个父类

super() 方法的语法：

,#+begin_src python :results output
super(type[, object-or-type])
,#+end_src

,#+begin_src python :results output
class People:
    def __init__(self, name):
        self.name = name
    def say(self):
        print("我是人，名字为：", self.name)

class Animal:
    def __init__(self, food):
        self.food = food

    def display(self):
        print("我是动物，我吃", self.food)
#这里People, Animal 是父类
class Person(People, Animal):
    def __init__(self, name, food):
        super().__init__(name)
        Animal.__init__(self,food)

per = Person("zhangsan", "熟食")
per.say()
per.display()
,#+end_src

,#+begin_src python :results output
#!/usr/bin/python
# -*- coding: UTF-8 -*-
class FooParent(object):
    def __init__(self):
        self.parent = 'I\'m the parent.'
        print ('Parent')

    def bar(self,message):
        print ("%s from Parent" % message)

class FooChild(FooParent):
    def __init__(self):
        # super(FooChild,self) 首先找到 FooChild 的父类（就是类 FooParent），然后把类 FooChild 的对象转换为类 FooParent 的对象
        super(FooChild,self).__init__()
        print ('Child')

    def bar(self,message):
        super(FooChild, self).bar(message)
        print ('Child bar fuction')
        print (self.parent)

if __name__ == '__main__':
    fooChild = FooChild()
    fooChild.bar('HelloWorld')
,#+end_src

如何理解smo 呢？用一个事例来说明。

,#+begin_src python :results output
class Bird:
    def __init__(self):
        self.hungry = True
    def eat(self):
        if self.hungry:
            print('sdd')
        else:
            print("no thx")

class SongBird(Bird):
    def __init__(self):
        super(SongBird,self).__init__()
        self.sound = 'sd'
    def sing(self):
        print(self.song())

sb = SongBird()
sb.sing()
sb.eat()
,#+end_src

,*** 魔法函数

所谓的魔法函数是python 的一种高级语法，允许你在类中自定义函数（函数名格式一般为 __xx__  ），并绑定到类的特殊方法中，比如在类A 中自定义 __str__()函数，则再调用str(A()) 时，会自动调用__str__()函数，并返回相应的结果。在我们平时的使用中，可能经常使用 __init__()函数（构造函数）和 __del__()函数（）

,*** __slots__

限制实例的属性就需要 __slot__()

,#+begin_src python :results output
class Student(object):
    __slots__ = ('name', 'age')

s = Student()
s.name = 'Michael'
s.age = 25
s.score = 99
,#+end_src

,*** int
如果传入base参数，就可以做N进制的转换：
,#+begin_src python :results output
int('1234', base=8)
,#+end_src

,*** set
集合，是 python 一种数据类型，可以去重。

,#+begin_src python
basket = ['apple', 'orange', 'apple']

set(basket)
#> {'apple', 'orange'}
,#+end_src

python 去重一般通过set,然后再转成对应的数据类型。

,#+begin_src python :results output
list1 = [11,12,13,12,15]
[x for x in set(list1)]
,#+end_src

,*** help

,#+begin_src python
help() #可以获取帮助文档
#比如:
help(re.match)
,#+end_src

,*** list
python 中的 list 转变为 array.

,#+begin_src python
items = [1, 2, 3, 4, 5]
type(items)
# => <class 'list'>
l = np.array(items)
l
type(l)
,#+end_src

列表还支持合并操作：

,#+begin_src python :results output
square = [1, 4, 98]
square + [36, 90]
# => [1, 4, 98, 36, 90]
,#+end_src

字符串是immutable, 而列表是 mutable.不可变数据类型:数值型,字符串型,元组型.

,#+begin_src python :results output
s = "abc"
s[0] = "c"
# =>
#    TypeErrorTraceback (most recent call last)
#    <ipython-input-14-f112f822bcf5> in <module>
#    ----> 1 import codecs, os;__pyfile = codecs.open('''/var/folders/mz/m838mtr975g17gftlv5331xh0000gn/T/pyBLrlSP''', encoding='''utf-8''');__code = __pyfile.read().encode('''utf-8''');__pyfile.close();os.remove('''/var/folders/mz/m838mtr975g17gftlv5331xh0000gn/T/pyBLrlSP''');exec(compile(__code, '''/Users/luyajun/Documents/坚果云/我的坚果云/github/wiki/python_wiki.org''', 'exec'));
#
#    ~/Documents/坚果云/我的坚果云/github/wiki/python_wiki.org in <module>
#    ----> 1 # -*- org-confirm-babel-evaluate: nil; -*-
#          2 #+PROPERTY: header-args :eval never-export
#          3
#          4 * Python_wiki                                                           :toc:
#          5   - [[#常见问题][常见问题]]
#
#    TypeError: 'str' object does not support item assignment
,#+end_src

,**** count

,#+begin_src python
a = [66.25, 333, 333, 1, 1234]
print(a.count(333), a.count(66.25), a.count('x'))
,#+end_src

,#+begin_src python
some_data = ['a','a','b','c']
count_freq = dict()
for item in some_data:
    if item in count_freq:
        count_freq[item] += 1
    else:
        count_freq[item] = 1
count_freq
# => {'a': 2, 'b': 1, 'c': 1}
,#+end_src

,#+begin_src python
from collections import Counter
some_data = ['a', '2', 2, 4]
Counter(some_data)
# => Counter({'a': 1, '2': 1, 2: 1, 4: 1})
Counter("success")
# => Counter({'s': 3, 'u': 1, 'c': 2, 'e': 1})
,#+end_src

可以使用elements() 方法来获取Counter 中的key 值。

,#+begin_src python
list(Counter("success").elements())
# => ['s', 's', 's', 'u', 'c', 'c', 'e']
,#+end_src

利用most_common() 方法可以找出前 N 个出现频率最高的元素以及它们对应的次数。

,#+begin_src python
from collections import Counter
some_data = ['a', '2', 2, 4]
Counter(some_data).most_common(2)
,#+end_src

当访问不存在的元素时，默认返回为0 而不是抛出 KeyError 异常。

,#+begin_src python :results output
from collections import Counter
some_data = ['a', '2', 2, 4]
Counter(some_data).most_common(2)
# => [('a', 1), ('2', 1)]
(Counter(some_data))['y']
# => 0
c = Counter("success")
c.update("successfully")
# =>
c
# => Counter({'s': 6, 'c': 4, 'u': 3, 'e': 2, 'l': 2, 'f': 1, 'y': 1})
c.subtract('successfully')
c
# => Counter({'s': 0, 'c': 0, 'e': 0, 'u': -1, 'f': -1, 'y': -1, 'l': -2})
,#+end_src

,**** deque
可以把列表当做队列用，只是在队列里第一加入的元素，第一个取出来；但是拿列表用作这样的目的效率不高。在列表的最后添加或者弹出元素速度快，然而在列表里插入或者从头部弹出速度却不快（因为所有其他的元素都得一个一个地移动）。

,#+begin_src python
from collections import deque
queue = deque(['eric', 'john', 'michael'])
queue.append('terry')
queue.append('graham')
queue.popleft() ##the first to arrive now leaves
queue
queue.popleft()
queue
,#+end_src

,**** 嵌套列表解析
可以将 3*4 的矩阵列表转换为 4*3 列表。
,#+begin_src python
matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
]

[[row[i] for row in matrix] for i in range(4)]
,#+end_src

,*** print
在 python 中，print 的功能要比 R 要丰富的多。类似于是 glue。

,#+begin_src python
new_points = alien_0['color']
print("you just earned " + str(new_points) + " points!")
,#+end_src

,*** tolist
array 转变成 list.
,#+begin_src python
import array as arr
a = arr.array("i", [10, -20, 30])
print("type of a:", type(a))
print("a is:", a)
list1 = list()
a.tolist()
,#+end_src

,*** title
Python title() 方法返回"标题化"的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())。
,#+begin_src python
a = []
a.append("df")
a.append("sd")
a.insert(0,"sa")
# =>
a
# => ['sa', 'sa', 'sa', 'df', 'sd']
b = a.pop(0) #pop(0) 是删除第一个元素。
# => 'sa'
b.title()
# => 'Sa'
,#+end_src

,*** Any/All
逻辑集合。
,#+begin_src python
any([False, True])
# => True
all([False, True])
# => False
,#+end_src

,*** empty

通过empty 属性，可以验证pandas 对象是否为空。
,#+begin_src python :results output
df.empty
import pandas as pd
pd.DataFrame(columns=list('ABC')).empty
# => True
,#+end_src

,*** empty
通过empty 属性，可以验证pandas 对象是否为空。

,#+begin_src python :results output
df.empty
import pandas as pd
pd.DataFrame(columns=list('ABC')).empty
# => True
,#+end_src

,*** range
使用 range() 创建数字列表，可以使用函数 list() 将 range() 的结果直接转换为列表。这个函数类似于 seq.
,#+begin_src python
numbers = list(range(1, 6))
print(numbers)
# [1, 2, 3, 4, 5]
,#+end_src
range 函数在python2 和python3 中有区别，python2 中返回的是列表，python3 返回的是迭代器，这样做的目的是节约内存。
,*** for 循环
for 循环中的 print 需要缩进。
,#+begin_src python
magicians = ['alice', 'david', 'carolina']
for magician in magicians:
    print(magician)
,#+end_src

,*** len
可以列表的长度。
,#+begin_src python
cars = ['bmw', 'audi']
len(cars)
# => 2
,#+end_src

,*** reverse
倒着打印列表。
,#+begin_src python
cars = ['bmw', 'audi']
cars.reverse()
print(cars)
# => ['audi', 'bmw']

for i in reversed([2, 5, 3, 9, 6]):
    print(i)
#> 6
#> 9
#> 3
#> 5
#> 2
,#+end_src

,*** sort
对列表进行永久性排序。
,#+begin_src python
magicians = ['alice', 'david', 'carolina']
magicians.sort()
magicians
# => ['alice', 'carolina', 'david']
,#+end_src

,*** sorted
使用 sorted() 对列表进行 *临时排序* 。要保留列表元素原来的列表的顺序，同时以特定的顺序呈现它们。除此之外，sorted()函数还有两个参数：key 和 reverse.

key 指定带有单个参数的函数，用于从 iterable 的每个元素中提取用于比较的键 (例如 key=str.lower)。默认值为 None (直接比较元素), reverse 为一个布尔值。如果设为 True，则每个列表元素将按反向顺序比较进行排序。

,#+begin_src python
magicians = ['alice', 'david', 'carolina']
sorted(magicians)
a = sorted([2, 4, 3, 7], reverse=True)
print(a)
#> [7, 4, 3, 2]
chars = ['apple', 'watermelon', 'pear', 'banana']
sorted(chars, key = lambda x:len(x))
#> ['pear', 'apple', 'banana', 'watermelon']
,#+end_src

,#+begin_src python
basket = ['apple', 'orange', 'apple']
for f in sorted(set(basket)):
    print(f)
#> apple
#> orange
,#+end_src

,*** append
在列表中添加元素。该方法在其末尾添加新元素“ducati”。在列表末尾添加元素。
,#+begin_src python
a = []
a.append("df")
a
,#+end_src

,*** clear

,#+begin_src python :results output
letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
letters[:] = []
letters
# => []
,#+end_src

,*** insert
在任意位置添加新元素。

,#+begin_src python
a = []
a.append("df")
a
a.append("sd")
a
a.insert(0,"sa")
a
week = ['day1','day2','day3']
# => ['day1', 'day2', 'day3']
week.insert(1,'day4')
# =>
week[1] = ["day1"]
# => ['day1']
week[1:1] = ["day1"]
# => []
week[1:1] = "day1"
# => []
week1 = "day1"
# => 'day1'
,#+end_src

list 数据中插入\删除操作的时间复杂度

| 操作            | 时间复杂度 |
| list[index]     | O(1)       |
| list.append     | O(1)       |
| list.insert     | O(n)       |
| list.pop(index) | O(1)       |
| list.remove     | O(n)       |

,*** item
这个函数一般用在字典类型数据。遍历字典时，如果直接遍历字典对象，只能得到字典中的键.使用字典 items() 方法，便可以同时输出键和对应值：
,#+begin_src python
sample = {'a':1, 'b':2, 'c':3}
for i in sample:
    print(i)
#> a
#> b
#> c
for i in sample.items():
    print(i)
#> ('a', 1)
#> ('b', 2)
#> ('c', 3)
,#+end_src

,*** get
获取dict 数据中的value。
,#+begin_src python :results output
sample = {"a":1, "b":2, "c":3}
sample.get("a")
,#+end_src

,*** zip
zip 函数接收一个或多个可迭代对象，并将各个迭代对象对应的元素聚合，返回一个元组的迭代器。
,#+begin_src python
x = [1, 2, 3]
y = [4, 5, 6]
zipped = zip(x, y)
list(zipped)
#> [(1, 4), (2, 5), (3, 6)]
color = ['white', 'blue', 'black']
animal = ['cat', 'dog', 'pig']
for i in zip(color, animal):
    print(i)
#> ('white', 'cat')
#> ('blue', 'dog')
#> ('black', 'pig')
,#+end_src

,*** del
从列表中删除元素。可以删除任意位置的元素。
,#+begin_src python
a = ['honda', "bmw"]
del a[0]
a
#del 可以删除字典中的键，也可以合并字典数据。
dic = {'name':'zs','age':18}
dic
del dic['name']
dic
dic2 = {'name':'ls'}
dic.update(dic2)
dic
,#+end_src

,*** pop
可以使用 pop() 可以删除末尾元素。

,#+begin_src python
a = ['honda', "bmw"]
del a[0]
a.append("dff")
a
c = a.pop(0) #自动从最后一个元素开始剔除
a
,#+end_src

如果要从列表中删除一个元素，且不再以任何方式使用它，那就用 del 语句；如果要在删除元素后还能继续使用它，就使用方法 pop().

,*** remove
根据值删除元素。a.remove("df")

,#+begin_src python
a = ['honda', "bmw"]
a = []
a.append("df")
a
a.append("sd")
a
a.insert(0,"sa")
a
b = a.pop(0)
a.remove("df")
a
c = "df"
a.remove(c)
a
,#+end_src

,*** time.sleep
sleep 就是推迟程序中线程中进行的时间，参数形式是：
time.sleep(1) 在执行到这句语句时候，python 就会将程序推迟一秒钟后继续下一个语句。

,*** timeit
性能测量函数。

,#+begin_src python :results output
from timeit import Timer
Timer('t=a;a=b;b=t','a=1;b=2').timeit()
# => 0.03639837200171314
Timer('a,b=b,a','a=1;b=2').timeit()
# => 0.03396420300123282
,#+end_src

,*** 列表解析
列表解析将 for 循环和创建新元素的代码合并一行，并自动附加新元素。
,#+begin_src python
squres = [value**2 for value in range(1, 11)]
# => [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
,#+end_src

,*** if
,#+begin_src python
cars = ['audi', 'bmw']
for car in cars:
    if car == 'bmw':
        print(car.upper())
    else:
        print(car.title())

user_0 = {
    'username':'eferni',
    'first':'enrico',
    'last':'fermi'
}
user_0.keys
for name in user_0.keys():
    print(name.title())
,#+end_src

,*** 按顺序遍历字典中的所有键

,#+begin_src python
favorite_lang = {
    'jen':'python',
    'sarah':'c',
    'edward':'R'
}

for name in sorted(favorite_lang.keys()):
    print(name.title() + ", thank you for talking the poll.")

    # Edward, thank you for talking the poll.
    # Jen, thank you for talking the poll.
    # Sarah, thank you for talking the poll.
,#+end_src

上述 for 语句类似于其他 for 语句，但对方法 dictinary.keys() 的结果调用了函数 sorted().这让 python 列出字典中的所有键，并在遍历前对这个列表进行排序。

,*** 遍历字典中的所有值

,#+begin_src python
favorite_lang = {
    'jen':'python',
    'sarah':'c',
    'edward':'R',
    'lu':'python'
}
for name in favorite_lang.values():
    print(name.title() + ', is favorite language.')

    # Python, is favorite language.
    # C, is favorite language.
    # R, is favorite language.
    # Python, is favorite language.
,#+end_src

可以看出上述输出有重复值，利用 set(),可以去重。

,#+begin_src python
favorite_lang = {
    'jen':'python',
    'sarah':'c',
    'edward':'R',
    'lu':'python'
}
for name in set(favorite_lang.values()):
    print(name.title() + ', is favorite language.')
 # Python, is favorite language.
    # C, is favorite language.
    # R, is favorite language.
,#+end_src

,*** 嵌套
有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这成为“嵌套”。
,#+begin_src python
alien = []
#创建30个绿色的外星人
for alien_number in range(30):
    new_alien = {'color': 'green', 'points':5,'speed':'slow'}
    alien.append(new_alien)
alien
len(alien)
# => 30
,#+end_src

,*** 在字典中存储列表
字典中还有列表型数据。
,#+begin_src python
favorite_lang = {
    'jen':['python', 'ruby'],
    'sarah':['c'],
    'edward':['ruby','go'],
    'phil':['python', 'haskell']
}

for name, languages in favorite_lang.items():
    print("\n" + name.title() + "'s favorite languages are:")
    for languages in languages:
        print('\t' + languages.title())
,#+end_src

,*** 字典中还有字典
    ,#+begin_src python
      users = {
          'aeinstein':{
              'first':'albert',
              'last':'einstein',
              'location':'princeton',
          },
          'mcurie':{
              'first':'marie',
              'last':'curie',
              'location':'paris',
          }
      }

for username, user_info in users.items():
    print("\nUsername:" + username)
    full_name = user_info['first'] + " " + user_info['last']
    location = user_info['location']
    print("\tFull name: " + full_name.title())
    print("\tLocation: " + location.title())
    ,#+end_src

,*** 字典推导

,#+begin_src python
Dial_codes = [
    (86, 'china'),
(91, 'india'),
]

Dial_codes
country_code = {country:code for code, country in Dial_codes}
country_code
,#+end_src

,** 正则表达式
在 python 中 re 模块可以完成对文本的正则化处理。匹配对象的两种方法：group() 和 groups().
,*** re.match
在正则表达式中，通常会选用 | 符号匹配多个字符串。

,#+begin_src python
import re
bt = 'bat|bet|bit'
m = re.match(bt, "bat")
m.group()
,#+end_src

这里会涉及到贪婪匹配和非贪婪匹配。

,#+begin_src python
s = "<a>哈哈</a><a>呵呵</a>"
import re
res1 = re.findall("<a>(.*)</a>", s)
# => ['哈哈</a><a>呵呵']
res2 = re.findall("<a>(.*?)</a>", s)
# => ['哈哈', '呵呵']
,#+end_src

,*** 匹配任何单个字符
,**** .可以匹配任何字符
python 和 r 不同，在正则表达式中，模式在前，字符串在后面。
,#+begin_src python
import re
anyend = '.end'
m = re.match(anyend, 'bend')
m.group()
,#+end_src
,** 用户输入和 while 循环
,*** 函数 input

,#+begin_src python
message = input("tell me something, and I will repeat it back to you:")
print(message)
,#+end_src

 ,#+begin_src python
 import numpy as np
 import pandas as pd
 name = input("Please enter your name: ")
 print("Hello, " + name + "!")
 ,#+end_src

,#+begin_src python
x = eval(input('Enter a number'))
print(x, type(x))
,#+end_src

,*** int() 获取数值输入

,#+begin_src python
age = input("how old are you?")
age
21
,#+end_src

,*** %
求模运算%, 这点和 R 一样。
,#+begin_src python
4 % 3
# 1
,#+end_src

,*** while
for 循环用于针对集合中的每个元素的一个代码块，而 while 循环不断地运行，直到指定的条件不满足为此。

,#+begin_src python
current_num = 1
while current_num <= 5:
    print(current_num)
    current_num +=1

current_num
# => 6
,#+end_src

,*** def
定义函数：

,#+begin_src python
def function_name(para_1,...,para_n=defau_n,..., para_m=defau_m):
    expressions
,#+end_src
函数声明只需要在需要默认参数的地方用 = 号给定即可, 但是要注意所有的默认参数都不能出现在非默认参数的前面。

,**** 向函数传递信息

,#+begin_src python
def greet_user(usename):
    print("Hello, " + usename.title() + "!")

greet_user('jesse')
# => Hello, Jesse!
,#+end_src

,#+begin_src python
def greet_user():
    """显示简单的问候语"""
    print("Hello!")

greet_user()
#Hello!
,#+end_src

在上面的函数参数中，usename 是形参，jesse 是实参。和 R 不同，python 可以返回字典。

,#+begin_src python
def build_person(first_name, last_name):
    person = {'first': first_name, 'last': last_name}
    return person

musician = build_person('jimi', 'hendrix')
print(musician)
# {'first': 'jimi', 'last': 'hendrix'}
,#+end_src

,**** 传递列表

,#+begin_src python
def greet_user(names):
    for name in names:
        msg = "Hello, " + name.title() + "!"
        print(msg)

usernames = ['hannah', 'ty', 'margot']
greet_user(usernames)
# => Hello, Hannah!
#    Hello, Ty!
#    Hello, Margot!
,#+end_src

,**** 传递任意数量的实参

,#+begin_src python
def make_pizza(*toppings):
    print(toppings)

make_pizza('pepperoni')
make_pizza('pepperoni','green peppers')
,#+end_src

形参名*toppings 中的星号让 python 创建一个名为 toppings 的空元组，并将收到的所有值都封装到这个元组中。这点跟 R 不一样。

,**** 可更改（mutable）与不可更改（immutable）对象

在 python 中，strings,tuples 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。

不可变类型：变量赋值 a = 5 后再赋值 a = 10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a.

可变类型：变量赋值 la =［1，2，3，4］后再赋值 la[2] = 5 则是将 list la 的第三个元素值更改，本身 la 没有动，只是其内部的一部分值被修改了。

python 函数的参数传递：

不可变类型：类似 C++ 的值传递，如 整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a)内部修改 a 的值，则是新生成来一个 a。

可变类型：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响

python 传不可变对象实例

,#+begin_src python
def change(a):
    print(id(a))
    a=10
    print(id(a))

a=1
print(id(a))
# => 4430828656
change(a)
# => 4430828656
#    4430828944
,#+end_src

传可变对象实例

,#+begin_src python
def changeme(mylist):
    ""
    mylist.append([1, 2, 3, 4])
    print("函数内取值：", mylist)
    return

#调用changeme 函数
mylist = [10, 20, 30]
changeme(mylist)
# => 函数内取值： [10, 20, 30, [1, 2, 3, 4], [1, 2, 3, 4]]
print("函数外取值：", mylist)
# => 函数外取值： [10, 20, 30, [1, 2, 3, 4], [1, 2, 3, 4]]
,#+end_src

,*** 导入整个模块
这块类似于 R 中的.R 执行文件，文件中可以包含 function 函数。

要让函数是可导入的，得先创建模块。模块是扩展名为.py 的文件。

,*** 导入特定的函数

,#+begin_src python
from module_name import function_name
,#+end_src

通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数。

,#+begin_src python
from module_name import function_0, function_1, function_2
,#+end_src

使用 as 给函数指定别名，如：

,#+begin_src python
import numpy as np
,#+end_src

指定别名的通用语法如下：

,#+begin_src python
from module_name import function_name as fn
,#+end_src

,*** 使用 as 给模块指定别名
不光可以给函数命名，还可以给模块命名。

,#+begin_src python
import pizza as p
p.make_pizza(16, 'pepperoni')
,#+end_src

,*** 导入模块中的所有函数

,#+begin_src python
from pizza import *
make_pizza(16, 'pepperoni')
,#+end_src

,** lambda

lambda 函数也叫匿名函数或内联函数，即没有具体名称的函数，它允许快速定义单行函数，可以用在任何需要函数的地方。这区别于 def 定义的函数。
lambda 与 def 的区别：

1）def 创建的方法是有名称的，而 lambda 没有。

2）lambda 会返回一个函数对象，但这个对象不会赋给一个标识符，而 def 则会把函数对象赋值给一个变量（函数名）。

3）lambda 只是一个表达式，而 def 则是一个语句。

4）lambda 表达式” : “后面，只能有一个表达式，def 则可以有多个。

,#+begin_src python
names = ['tony',  'bob']
sorted(names, key = lambda name:name.split()[-1].lower())
# => ['bob', 'tony']
,#+end_src

匿名函数需要注意的地方是:你用 lambda 定义了一个匿名函数，并想在定义时捕获到某些变量的值。

,#+begin_src python
x = 10
a = lambda y:x + y
x = 20
b = lambda y: x + y
a(10)
#> 30
b(10)
#> 30
,#+end_src

从上面例子可以知道 lambda 表达式中的 x 是一个自由变量，在运行时绑定值，而不是定义时就绑定，这跟函数的默认值参数定义是不同的。

,** class
类与对象是面向对象编程的两个主要方面。一个类（class）能够创建一种新的类型（type），其中对象（object）就是类的实例（instance）。python 中的 self 相当于 c++ 中的 this 指针及 java 与 C# 中的 this 引用。面向对象编程，在编写类时，定义一大类对象都有通用的行为。

类方法与普通函数只有一种特定的区别——前者必须多加一个参数在参数列表开头，这个名字必须添加到参数列表的开头，但是你不用在你调用这个功能时为这个参数赋值，Python 会为它提供。这种特定的变量引用的是对象本身，按照惯例，它被赋予 self 这一名称，以表示该类自身。

类对象支持两种操作：属性引用和实例化。属性引用使用 python 中所有属性所使用的标准语法：obj.name, 有效的属性名称是类对象被创建时存在于类命名空间中的所有名称。

如果类的定义是这样：

,#+begin_src python
class MyClass:
     """A simple example class"""
     i = 12345

def f(self):
    return 'hello world'
,#+end_src

那么 MyClass.i 和 MyClass.f 就是有效的属性引用，将分别返回一个整数和一个函数对象。类属性也可以被赋值，因此可以通过赋值来更改 MyClass.i 的值。__doc__ 也是一个有效属性，将返回所属类的文档字符串："""A simple example class"""。

类的实例化使用函数表示法。可以把类对象视为是返回该类的一个新实例的不带参数的函数。

,#+begin_src python
class Complex:
   def __init__(self, realpart, imagpart):
       self.r = realpart
       self.i = imagpart

x = Complex(3.0, -4.5)
x.r,x.i
# => (3.0, -4.5)
,#+end_src

,#+begin_src python
class Dog:
    kind = 'canine'

def __init__(self, name):
    self.name = name

d = Dog('Fido')
e = Dog('Buddy')
d.kind
# 'canine'
e.kind
# 'canine'
,#+end_src

,*** 字符串
isdecima(),isdigit(),isalpha(),isalnum().可以测试字符串 S 是否是数字\字母\字母或数字，对于非 Unicode 字符串。

,#+begin_src python
print('34'.isdigit())
# => True
print('34'.isalnum())
# => True
print('34'.isdecimal())
# => True
,#+end_src

,** 向量
,*** 将序列分解为单独变量

,#+begin_src python
p = (4, 5)
x, y =p
x
y

data = ['a', 50, 10, {2012,12,30}]
name, share, price, date =data
print(name, share, price, date)
# => a 50 10 {2012, 12, 30}
,#+end_src

实际上不仅仅是元组或列表，只要对象恰好是可迭代的，那么就可以执行分解操作。这包括字符串\文件\迭代器及生成器。

,*** 从任意长度的可迭代对象中分解元素
如果需要从某个可迭代对象中分解出 N 个元素，但是这个可迭代对象的长度可能超过 N.

,#+begin_src python
import pandas as pd
import numpy as np
def drop_first_last(grades):
    first, *middle, last = grades
    return np.mean(middle)

drop_first_last((1,2,3,4))
# => 2.5
,#+end_src

可以利用*表达式解决这个问题，这个表达式有点类似于 R 中的 everything。

,#+begin_src python
record = ("a", 'b', '1',"2")
a, b, *other = record
a
b
other
# => ['1', '2']
,#+end_src

,*** 找到最大或最小的 N 个元素
heapq 模块中有两个函数－nlargest() 和 nsmallest().
,#+begin_src python
import heapq
nums = [1, 8, 2, 23, 7, -4]
print(heapq.nlargest(3, nums))#最大的3个数字
# => [23, 8, 7]
print(heapq.nsmallest(3, nums))
# => [-4, 1, 2]
,#+end_src

,*** set
当需要对一个列表进行去重操作的时候，set()函数就派上用场了。
,#+begin_src python
a = [1, 5, 2, 1, 9]
set(a)
# {1, 2, 5, 9}
,#+end_src

要向set 中增加元素，可以通过 add 方法。

,#+begin_src python :results output
s = set([1,2,3,4])
s.add(5)
s
# => {1, 2, 3, 4, 5}
set([1, 2, 3, 4]).add(5) #这种就有问题
,#+end_src

移除一个元素，可以通过remove 的方法：

,#+begin_src python :results output
s = set([1,2,3,4])
s.remove(4)
s
# => {1, 2, 3}
,#+end_src

,*** lambda
一个 lambda 函数是一个小的匿名函数。匿名函数不需要显示地定义函数名，使用【lambda + 参数 +表达式】的方式，语法是：

,#+begin_src python
lambda arguments:expression
x = lambda a : a + 10
x(5)
# => 15
,#+end_src

lambda functions can take any number of arguments.

,#+begin_src python
x = lambda a, b : a*b
x(5,6)
# => 30
x = lambda a,b,c: a+b+c
print(x(5,6,2))
# => 13
,#+end_src

与 def 区别：
https://pic1.zhimg.com/80/v2-061aa0744539a1f7bfc301015e9594a2_720w.jpg

,#+begin_src python
def f(x,y):
    return x*y
f(1,2)

func = lambda x,y: x*y
func(1,2)
,#+end_src

匿名函数的优点：

- 不用取名称，因为给函数取名是比较头疼的一件事，特别是函数比较多的时候

- 可以直接在使用的地方定义，如果需要修改，直接找到修改即可，方便以后代码的维护工作

- 语法结构简单，不用使用 def 函数名(参数名):这种方式定义，直接使用 lambda 参数:返回值 定义即可

,*** 全为 0/1 的数组

,#+begin_src python
import numpy as np
np.ones((2, 2, 3))
np.zeros((2, 2, 3))
np.empty((2, 2, 3) )
,#+end_src

,** 元组
元组是一个固定长度，不可改变的 python 序列对象。创建元组的最简单方式，用用逗号分隔一列值：
tuple 和 list 非常类似（一个用圆括号，一个用方括号），主要区别在于 tuple 不能增减或更改其元素，而 dict 则是有索引的多元组（用花括号表示），有其方便的地方。tuple 和 list 之间可以相互切换，list(tup)

,#+begin_src python
tup = 4, 5, 6
tup
# (4, 5, 6)
list(tup)
# => [4, 5, 6]
,#+end_src

,#+begin_src python
nested_tup = (4,5,6),(7,8)
nested_tup
# ((4, 5, 6), (7, 8))
,#+end_src

用 tuple 可以将任意序列或迭代器转换成元组：
,#+begin_src python
tuple([4,0,2])
# (4, 0, 2)
tuple('string')
# ('s', 't', 'r', 'i', 'n', 'g')
,#+end_src

如果元组中的某个对象是可变的，比如列表，可以在原位进行修改。

,#+begin_src python
tup = tuple(['foo', [1,2], True])
tup[1].append(3)
tup
# ('foo', [1, 2, 3], True)
,#+end_src

可以用加号运算符将远组串联起来。
,#+begin_src python
(4,None,'foo') + (6,0) + ('bar',)
# (4, None, 'foo', 6, 0, 'bar')
,#+end_src

元组乘以一个整数，像列表一样，会将几个元组的复制串联起来：

,#+begin_src python
('foo', 'bar')*4
# ('foo', 'bar', 'foo', 'bar', 'foo', 'bar', 'foo', 'bar')
,#+end_src

创建元组可以用小括号（），也可以什么也不用，为了可读性，建议还是用（）。此外对于含单个元素的元组，务必记住要多加一个逗号。

,#+begin_src python
print(type(('ok')))
# => <class 'str'>
print(type(('ok', )))
# => <class 'tuple'>
,#+end_src

元组也可以创建二维元组

,#+begin_src python
nested = ((1,10,'python'),('data'))
nested
# => ((1, 10, 'python'), 'data')
type(nested)
# => <class 'tuple'>
,#+end_src

索引和切片

元组中可以用整数来对它进行索引和切片。

,#+begin_src python
nested = ((1,10,'python'),('data'))
type(nested)
# => <class 'tuple'>
nested[0]
# => (1, 10, 'python')
print(nested[0][0], nested[0][1], nested[0][2])
# => 1 10 python
,#+end_src

不可更改

元组具有不可更改性。虽然不可更改，但是可以通过以下方式来更改。

,#+begin_src python
t = ('ok',[1,2],True)
t[2] = False
# => Traceback (most recent call last):
#      File "<stdin>", line 1, in <module>
#      File "/Users/luyajun/Documents/坚果云/我的坚果云/github/wiki/python_wiki.org", line 1, in <module>
#        # -*- org-confirm-babel-evaluate: nil; -*-
#    TypeError: 'tuple' object does not support item assignment
,#+end_src

当tuple 只有一个元素时，必须加逗号, 来消除歧义

,#+begin_src python
tuple = ('a','b','c','d','e')
tuple[1:3]
# => ('b', 'c')
tuple[0] = 'A'
tuple = ('A',) + tuple[1:]
# => ('A', 'b', 'c', 'd', 'e')
tuple

t = ('a','b',['A','B'])
# => ('a', 'b', ['A', 'B'])
t[2][0] = 'X' #tuple 里的list 型可以更改对象
# => 'X'
t[0] =  'C'
t
# => ('a', 'b', ['X', 'B'])
,#+end_src

但是只要元组中的元素可更改（mutable），那么我们可直接更改其元素。

,#+begin_src python
t[1].append(3)
t
,#+end_src

元组大小和内容都不可更改，因此只有 count 和 index 两种方法。

,#+begin_src python
t = (1,10.31,'python')
t.count('python')
# => 1
t.index(10.31)
# => 1
,#+end_src

这两个方法返回值都是 1，但意思完全不同。index(10.31) 是找到该元素在元组的索引。

元组拼接
元组拼接有 2 种方式，用 + 和 *，前者首尾拼接，后者复制拼接。

,#+begin_src python
(1,10,'python') + ('data',11) + ('ok',)
# => (1, 10, 'python', 'data', 11, 'ok')
(1,10,'python') * 2
# => (1, 10, 'python', 1, 10, 'python')
,#+end_src

解压元组

解压（unpack）一堆元组（有几个元素左边括号定义几个变量）

,#+begin_src python
t = (1,10,'python')
(a, b, c) = t
print(a,b,c)
# => 1 10 python
,#+end_src

解压二维元组（按照元组里的元组结构来定义变量）

,#+begin_src python
t = (1,10,('ok', 'python'))
(a,b,(c,d)) = t
print(a,b,c,d)
# => 1 10 ok python
,#+end_src

如果元素数目对不上，会报错。

,#+begin_src python
p = (4, 5)
x, y, z =  p
,#+end_src

如果你只想要元组其中几个元素，用通配符*，在计算机语言中代表一个或多个元素，下例就是把多个元素给了 reset 变量。

,#+begin_src python
t = 1,2,3,4,5
a,b,*rest,c = t
print(a,b,c)
# => 1 2 5
print(rest)
# => [3, 4]
,#+end_src

解压缩对象不仅仅局限于tuple，list, 还包括有string.files, iterators, generators.

可以通过_ 来扔掉某些你不想要的变量。
,#+begin_src python
data = ['a','b',23,1]
_,shares,price,_ = data
print(shares, price)
,#+end_src

star unpacking can also be useful when combined with certain kinds of string processing operations, such as splitting.

,#+begin_src python
line = "nobody:*-2:-2:unpsdfdf:/sdsdsd"
uname,*filesd,hoer,sh = line.split(":")
uname
,#+end_src

,#+begin_src python
record = ('as',50,12,(1,2,3))
name, *_,(*_,year) = record
year
,#+end_src

,*** keeping the last N items
确保向量保留固定位数数字。
,#+begin_src python :results output
from collections import deque
q = deque(maxlen=3)
q.append(1)
q.append(2)
q.append(3)
q.append(4)
q
# => deque([2, 3, 4], maxlen=3)
q.appendleft(4)
# =>
q.pop()
# => 3
q.popleft()
# => 4
,#+end_src

,*** finding the largest or smallest n items

,#+begin_src python :results output
import heapq
nums = [1,8,2,12,23,1]
print(heapq.nlargest(3, nums))
# => [23, 12, 8]
print(heapq.nsmallest(3, nums))
# => [1, 1, 2]
,#+end_src

对于多个变量数组，可以指定 key 这种方式来选定特定的列。
,#+begin_src python :results output
portfolio = [
  {'name':'IBM', 'share':100, 'price':91.1},
  {'name':'aapl', 'share':50, 'price':2343.1}
]

heapq.nsmallest(1, portfolio, key = lambda s:s['price'])
,#+end_src

,*** mapping keys to multiple values in a dictinary
if you want to map keys to multiple values.

,#+begin_src python :results output
d = {
  'a': [1, 2,3],
  'b': [4, 5]
}

d['a'].append(1)
d
# => {'a': [1, 2, 3, 1], 'b': [4, 5]}
,#+end_src

,*** keeping dictinaries in order
这里的顺序，其实是添加数据的顺序。

,#+begin_src python :results output
from collections import OrderedDict

d = OrderedDict()
d['foo'] = 1
d['bar'] = 2
d['spam'] = 3
d['grok'] = 4

for key in d:
   print(key, d[key])
   # => foo 1
   #    bar 2
   #    spam 3
   #    grok 4
,#+end_src

,*** calculating with dictinaries
如何统计字典型数据的最大，最小及排序值。

,#+begin_src python :results output
prices = {'ACme': 45.23,'A':231.120,"sdfg":234}

min_price = min(zip(prices.values(), prices.keys()))
min_price
# => (45.23, 'ACme')
max_price = max(zip(prices.values(), prices.keys()))
max_price
# => (234, 'sdfg')
sort_price = sorted(zip(prices.values(), prices.keys()))
sort_price
# => [(45.23, 'ACme'), (231.12, 'A'), (234, 'sdfg')]
,#+end_src

注意对比，min,max,sorted 结果。

,#+begin_src ipython :results output
min(price)
min(price.values())
max(price)
max(price.values())
sorted(price)
,#+end_src

,*** finding commonalities in two dictinaries
找到2个字典数据共有的keys, same values.

,#+begin_src python :results output
a = {'x':1, 'y':1, 'z':3}
b = {'w':2, "x":11, "y":2}
# find keys in common
a.keys() & b.keys()
# => {'x', 'y'}
# find keys in a that are not in b
a.keys() - b.keys()
# => {'z'}
# find (key, value) pairs in common
a.items() & b.items()
# => set()
,#+end_src

these kinds of operations can also be used to alter or filter dictinary contents.

,#+begin_src python :results output
c = {key:a[key] for key in a.keys() - {'z', 'w'}}
,#+end_src

,*** removing duplicates from a sequence while maintaining order
如果不要保持序的话，set 即可满足这个条件。

,#+begin_src python :results output
def dedupe(items):
  seen = set()
  for item in items:
    if item not in seen:
      yield item
      seen.add(item)

a = [1, 5, 2, 1, 9]
list(dedupe(a))
# => [1, 5, 2, 9]
,#+end_src

如果数据类型是 unhashable.
,#+begin_src python :results output
def dedupe(items, key=None):
	seen =  set()
	for item in items:
		val = item if key is None else key(item)
		if val not in seen:
			yield item
			seen.add(val)
,#+end_src

,*** naming a slice
对切片重新命名？

,#+begin_src python :results output
items = [0, 1, 2, 3, 4, 5, 6]
a =  slice(2, 4)
a
# => slice(2, 4, None)
items[a]
items[a] =  [10,11]
items
del items[a]
items
,#+end_src

if you have a slice instance s, you can get more information about it by looking at its s.start, s.stop and s.step attributes.

,#+begin_src python :results output
a =  slice(10, 50, 2)
a.start
a.stop
a.step
,#+end_src

,*** determining the most frequently occuring items in a sequence

,#+begin_src python :results output
words = [
	'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
	'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
	'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into',
	'my', 'eyes', "you're", 'under'
]

from collections import Counter
word_counts =  Counter(words)
word_counts
top_three =  word_counts.most_common(3)
# => [('eyes', 8), ('the', 5), ('look', 4)]
,#+end_src

if you want to increment the count manually, simply use addition:

,#+begin_src python :results output
morewords =  ['my', 'look', 'b', 'c', 'b']
for word in morewords:
	word_counts[word] += 1

word_counts
,#+end_src

更简单的操作是：
,#+begin_src python :results output
word_counts.update(morewords)
a =  Counter(words)
b =  Counter(morewords)
#combine counts
c = a + b
c
#subtract counts
d = a - b
d
,#+end_src

,*** sorting a list of dictionaries by a common key

,#+begin_src python :results output
rows = [
	{'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
	{'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
	{'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
	{'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
]

from operator import itemgetter
row_by_fname = sorted(rows,  key =itemgetter('fname'))
# =>
# [{'fname': 'Big', 'lname': 'Jones', 'uid': 1004},
#  {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
#  {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
#  {'fname': 'John', 'lname': 'Cleese', 'uid': 1001}]
row_by_uid = sorted(rows,  key =itemgetter('uid'))
rows_by_lfname = sorted(rows, key = itemgetter('lname', 'fname'))
rows_by_lfname
,#+end_src

the functionality of itemgetter() is sometimes replaced by lambda expression.

,#+begin_src python :results output
rows_by_fname = sorted(rows, key=lambda x:x['fname'])
rows_by_lfname = sorted(rows, key=lambda x:(x['lname'], x['fname']))
,#+end_src

,#+begin_src python :results output
min(rows,key=itemgetter('uid'))
max(rows,key=itemgetter('uid'))
,#+end_src

,*** sorting objects without native comparison support

,#+begin_src python :results output
for date, items in groupby(rows, key =itemgetter('date')):
	print(date)
	for i in items:
		print("    ", i)
,#+end_src

,*** grouping records together based on a field

,#+begin_src python :results output
rows = [
	{'address': '5412 N CLARK', 'date': '07/01/2012'},
	{'address': '5148 N CLARK', 'date': '07/04/2012'},
	{'address': '5800 E 58TH', 'date': '07/02/2012'},
	{'address': '2122 N CLARK', 'date': '07/03/2012'},
	{'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},
	{'address': '1060 W ADDISON', 'date': '07/02/2012'},
	{'address': '4801 N BROADWAY', 'date': '07/01/2012'},
	{'address': '1039 W GRANVILLE', 'date': '07/04/2012'},
]

from operator import itemgetter
from itertools import groupby
rows.sort(key =  itemgetter('date'))

for date, items in groupby(rows, key =itemgetter('date')):
	print(date)
	for i in items:
		print("    ", i)
		# =>
		# 07/01/2012
		#      {'address': '5412 N CLARK', 'date': '07/01/2012'}
		#      {'address': '4801 N BROADWAY', 'date': '07/01/2012'}
		# 07/02/2012
		#      {'address': '5800 E 58TH', 'date': '07/02/2012'}
		#      {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'}
		#      {'address': '1060 W ADDISON', 'date': '07/02/2012'}
		# 07/03/2012
		#      {'address': '2122 N CLARK', 'date': '07/03/2012'}
		# 07/04/2012
		#      {'address': '5148 N CLARK', 'date': '07/04/2012'}
		#      {'address': '1039 W GRANVILLE', 'date': '07/04/2012'}
,#+end_src

,*** filtering sequence elements
The easiest way to filter sequence data is often to use a list comprehension.

,#+begin_src python :results output
mylist = [1,24,-5,10,-7]
[n for n in mylist if n > 0]
[n for n in mylist if n < 0]
,#+end_src

,#+begin_src ipython :session :exports both :results raw drawer
import numpy as np
,#+end_src

也可以是一个生成器（generator），you can use generator expression to produce the filtered values iteratively.

for example:

,#+begin_src python :results output
pos =  (n for n in mylist if n > 0)
pos
for i in pos:
	print(i)
,#+end_src

还有一种类型数据不好用list comprehension 或者 generator expression 来进行过滤，需要通过特定的filter() function 来进行过滤。

,#+begin_src python :results output
values = ["1", "2", "-3", "-", "4", "N?A"]

def is_int(val):
	try:
		x = int(val)
		return True
	except ValueError:
		return False

ivals = list(filter(is_int,values))
ivals
,#+end_src

filter() create an iterator, so if you want to create a list of results, make sure you also use list() as shown.

在过滤的同时，还能进行变形。

,#+begin_src python :results output
mylist = [1,24,-5,10,-7]
[n if n > 0 else 0 for n in mylist]
,#+end_src

another notable filtering tool is itertools.compress(), which takes an iterable and an accompanying boolean selector sequence as input.

   


      
,#+begin_src python :results output
addresses = [
'5412 N CLARK',
'5148 N CLARK',
'5800 E 58TH',
'2122 N CLARK'
'5645 N RAVENSWOOD',
'1060 W ADDISON',
'4801 N BROADWAY',
'1039 W GRANVILLE',
]
count = [0, 3, 10, 1,7, 6, 1]
from itertools import compress
more5 = [n > 5 for n in count]
more5
# => [False, False, True, False, True, True, False]
list(compress(addresses, more5))
# => ['5800 E 58TH', '1060 W ADDISON', '4801 N BROADWAY']
,#+end_src

the compress() function then picks out the items corresponding to True values.

,*** extracting a subset of a dictionary
you want to make a dictionary that is a subset of another dictionary.

,#+begin_src python
prices = {
'ACME': 45.23,
'AAPL': 612.78,
'IBM': 205.55,
'HPQ': 37.20,
'FB': 10.75
}
#make a dictionary of all price over 200
p1 = {key:value for key, value in prices.items() if value > 200}
# => {'AAPL': 612.78, 'IBM': 205.55}

#make a dictionary of tech stocks
tech_names =  {'AAPL', 'IBM', 'HPQ', 'MSFT'}
p2 = {key:value for key,value in prices.items() if key in tech_names}
# => {'AAPL': 612.78, 'IBM': 205.55, 'HPQ': 37.2}
p2 = {key:prices[key] for key in prices.keys() & tech_names}
# => {'IBM': 205.55, 'HPQ': 37.2, 'AAPL': 612.78}
,#+end_src

,*** mapping names to sequence elements
if you are building large data structures involving dictionaries, use of a namedtuple will be more efficient.

be aware that unlike a dictionary, a namedtuple is immutable.

如果实在有需求需要更改数据，就用 _replace 进行修改。

namedtuple 第一个参数就是类名,后面肯定会跟着一个数据格式例子.

从这第一个

,#+begin_src python
from collections import namedtuple
subscribe =namedtuple('subscribe',['addr', 'joined'])
sub = subscribe('ab@sina.com', '2012-10-01')
sub
# => subscribe(addr='ab@sina.com', joined='2012-10-01')
sub.addr
# => 'ab@sina.com'
sub.joined
# => '2012-10-01'
len(sub)
# => 2
addr, joined=sub
addr
# => 'ab@sina.com'
a, b=sub
a
# => 'ab@sina.com'
from collections import namedtuple
stocks = namedtuple('stocks',['name', 'share', 'price'])
s = stocks('asb', 100,1003.55)
# => stocks(name='asb', share=100, price=1003.55)
s.share = 75
# => Traceback (most recent call last):
#      File "<stdin>", line 1, in <module>
#      File "e:/我的坚果云/github/wiki/python_wiki.org", line 1, in <module>
#        # -*- org-confirm-babel-evaluate: nil; -*-
#    AttributeError: can't set attribute
s = s._replace(share=75)
# => stocks(name='asb', share=75, price=1003.55)

from collections import namedtuple

stock =namedtuple('stock',['name', 'share', 'price', 'date', 'time'])
stock_prototype = stock('', 1, 1, None, None)
def dict_to_stock(s):
  return stock_prototype._replace(**s)

a = {'name': 'asb','share':1, 'price':1003.55}
dict_to_stock(a)
# => stock(name='asb', share=1, price=1003.55, date=None, time=None)
b = {'name': 'b', 'share':1003.55, 'price':1003.55, 'date':'12/17/2016'}
dict_to_stock(b)
# => stock(name='b', share=1003.55, price=1003.55, date='12/17/2016', time=None)
,#+end_src

,*** transform and reducing data at the same time
you need to execute a reduction fuction (e.g., sum(), min(), max()), but first need to transform or filter the data.

,#+begin_src python
nums =[1, 2, 3, 4, 5]
s = sum(x*x for x in nums)
# => 55

s =('acs', 50, 100.45)
print(','.join(str(x) for x in s))

portfolio = [{'name': 'goog', 'share':50},
			 {'name':'yhoo', 'share':100}]
portfolio
min_share = min(s['share'] for s in portfolio)
# => 50
# => acs,50,100.45
,#+end_src

,*** combining multiple mapping into a single
a chainmap is particularly useful when working with scoped values such as variables in a programming language.
,#+begin_src python :results output
a ={'x':1, 'z':2}
b ={'y':1, 'z':2}
from collections import ChainMap
c =ChainMap(a, b)
c
# => ChainMap({'x': 1, 'z': 2}, {'y': 1, 'z': 2})
print(c['x'])
# => 1
print(c['z'])
# => 2
len(c)
# => 3
list(c.keys())
# => ['y', 'z', 'x']
list(c.values())
# => [1, 2, 1]
c['z'] =100
c['w'] =400
del c['x']
c
# => ChainMap({'z': 100, 'w': 400}, {'y': 1, 'z': 2})
a
# => {'z': 100, 'w': 400}
del c['y']
# => Traceback (most recent call last):
#      File "e:\virenv\pyenv\lib\collections\__init__.py", line 970, in __delitem__
#        del self.maps[0][key]
#    KeyError: 'y'
#
#    During handling of the above exception, another exception occurred:
#
#    Traceback (most recent call last):
#      File "<stdin>", line 1, in <module>
#      File "e:\virenv\pyenv\lib\collections\__init__.py", line 972, in __delitem__
#        raise KeyError('Key not found in the first mapping: {!r}'.format(key))
#    KeyError: "Key not found in the first mapping: 'y'"
values =ChainMap()
values['x'] = 1
#add a new mapping
values =values.new_child()
values['x'] = 2
values =values.new_child()
values['x'] = 3
values
# => ChainMap({'x': 3}, {'x': 2}, {'x': 1})
#discardlast mapping
values =values.parents
values['x']
values
# => ChainMap({'x': 2}, {'x': 1})
,#+end_src

as an alternative to chainmap, you might consider merging dictionary together using the update() method.

,#+begin_src python :results output
from collections import ChainMap
a ={'x':1, 'z':3}
b ={'y':2, 'z':4}
merged =dict(b)
merged.update(a)
merged
# => {'y': 2, 'z': 3, 'x': 1}
a ={'x':1, 'z':3}
b ={'y':2, 'z':4}
merged = ChainMap(a, b)
merged['x']
# => 1
a['x'] = 42
merged['x']
# => 42
,#+end_src

从上面的例子可以看出，dict 会对取值作去重处理。

,*** splitting string on any of multiple delimiter
you need to split a string into fields, but the delimiters aren't consistent throughout the strings.

r,表示需要原始字符串，不转义特殊字符。

,#+begin_src python :results output
import re
line ='asdf fjdk;afed, fjek, asdf'
re.split(r'[;,\s]\s*', line)
# => ['asdf', 'fjdk', 'afed', 'fjek', 'asdf']
,#+end_src

,*** matching text at the start or end of a string

,#+begin_src python :results output
filename ='spam.txt'
filename.endswith('.txt')
# => True
filename.startswith('file:')
# => False
url ='http://www.python.org'
url.startswith('http:')
# => True
import os
filenames =os.listdir('.')
filenames
[name for name in filenames if name.endswith('.org')]
any(name.endswith('.py') for name in filenames)
# => False
,#+end_src

,#+begin_src python :results output
filename ='spam.txt'
filename[-4:] =='.txt'
# => True
url ='http://www.python.org'
url[:5] =='http:' or url[:6] =='https:' or url[:4] == 'ftp:'
# => True
,#+end_src

,#+begin_src python :results output
import re
url ='http://www.python.org'
re.match('http:|https:|ftp:', url)
,#+end_src

,*** matching strings using shell wildcard patterns

,#+begin_src python :results output
from fnmatch import fnmatch,fnmatchcase
fnmatch('foo.txt', '*.txt')
# => True
fnmatch('foo.txt', '?oo.txt')
# => True
fnmatch('Dat45.csv', 'Dat[0-9]*')
# => True
names =['Dat1.csv', 'Dat2.csv', 'config.ini']
[name for name in names if fnmatch(name, 'Dat*.csv')]
# => ['Dat1.csv', 'Dat2.csv']
,#+end_src

use fnmatchcase() instead, it matches exactly based on the lower- and uppercase conventions that you supply.

,#+begin_src python :results output
fnmatchcase('foo.txt', '*.TXT')
# => False
,#+end_src

,*** matching and searching for text patterns

,#+begin_src python :results output
text = 'yeah, but no, but yeah, but no, but yeah'
text == 'yeah'
# => False
#match at start or end
text.startswith('yeah')
# => True
text.endswith('not')
# => False
text.find('no')
# => 10

text1 = '11/27/2012'
text2 = 'Nov 27, 2012'
import re
if re.match(r'\d+/\d+/\d+', text1):
	print('yes')
else:
	print('no')
	# => yes
,#+end_src

if you are going to perform a lot of matches using the same pattern, it usually to precompile the regular expression pattern into a pattern object first.

,#+begin_src python :results output
datepart =re.compile(r'\d+/\d+/\d+')
if datepart.match(text1):
    print('yes')
text ='Today is 11/27/2012, pycon srad 3/13/2013'
datepart.findall(text)
# => ['11/27/2012', '3/13/2013']
m =datepart.match('11/27/2012')
m
m.group()
m.group(0)
m.group(1)
m.group(2)
m.groups()
datepart.findall(text)
for month, day, year in datepart.findall(text):
	print('{}-{}-{}'.format(year, month, day))

for m in datepat.finditer(text):
	print(m.groups())
,#+end_src

,*** searching and replacing text

,#+begin_src python :results output
text = 'Yeah, but no, but Yeah'
text.replace('yeah', 'yep')
# => 'Yeah, but no, but Yeah'

text ='Today is 11/27/2012. Pycon starts 3/13/2013.'
import re
re.sub(r'(\d+)/(\d+)/(\d+)', r'\3-\1-\2', text)
,#+end_src

the first argument to sub() is the pattern to match and the second argument is the replacement pattern.

re.compile 是将正则表达式编译成一个对象,加快速度义,并重复使用.   

,#+begin_src python :results output
import re
datepat =re.compile(r'(\d+)/(\d+)/(\d+)')
newtext, n= datepat.sub(r'\3-\1-\2', text)
newtext
,#+end_src

,*** searching and replacing case - insensitive text

,#+begin_src python :results output
text='Upper Python, lower python, mixed python'
re.findall('python', text, flags=re.IGNORECASE)
# => ['Python', 'python', 'python']
re.sub('python', 'snake', text, flags=re.IGNORECASE)
# => 'Upper snake, lower snake, mixed snake'
,#+end_src

,*** specifying a regular expression for the shortest match
This problem often aries in patterns that try to match text enclosed inside a pair of starting and ending delimiters.

,#+begin_src python :results output
import re
str_pat =re.compile(r'\"(.*)"')
text1 ='Computer says "no."'
str_pat.findall(text1)
# => ['no.']
text2 ='Computer says "no." phone says "yes"'
str_pat.findall(text2)
# => ['no." phone says "yes']
,#+end_src

,*** aligning text strings

,#+begin_src python :results output
text ='hello world'
text.ljust(20)
import re
text = 'hello world'
text.ljust(20)
# => 'hello world         '
text.rjust(20)
# => '         hello world'
text.center(20)
# => '    hello world     '
format(text, '>20')
# => '         hello world'
format(text, '<20')
# => 'hello world         '
format(text, '^20')
# => '    hello world     '
format(text, '=>20s')
# => '=========hello world'
format(text, '*^20s')

'{:>10s}{:>10s}'.format('hello', 'world')
# => '     hello     world'
x = 1.345
format(x, '>10')
# => '     1.345'
format(x, '^10.2f')
# => '   1.34   '
'%-20s' % text
# => 'hello world         '
,#+end_src

,*** combining and concatenating strings

,#+begin_src python :results output
parts = ['Is', 'chiao', 'not', 'chiago']
", ".join(parts)
''.join(parts)

a ='Is Chicago'
b ='Not Chicago'
a + ' ' +b
join = ['Is', '']
print(a + ':' + b)
print(a + ':' + b)
,#+end_src

,*** interpolating variables in strings
you want to create a string in which embedded variables names are substituted with a string representation of a variable's value.

,#+begin_src python
s = '{name} has {n} messages.'
s.format(name='Guidao', n=37)
# => 'Guidao has 37 messages.'
,#+end_src

,*** performing accurate decimal calculations

,#+begin_src python :results output
a = 4.2
b = 2.1
a + b
# => 6.300000000000001
(a + b) == 6.3
# => False
,#+end_src

需要引用 decimal.

,#+begin_src python
from decimal import Decimal
a = Decimal('1.3')
b = Decimal('2.2')
a + b
# => Decimal('3.5')
print(a + b)
# => 3.5
(a + b) == Decimal('3.5')
# => True
,#+end_src

,#+begin_src python
from decimal import localcontext
a = Decimal('4.2')
b = Decimal('1.2')
print(a/b)

with localcontext() as ctx:
     ctx.prec = 3
     print(a/b)

,#+end_src

,#+begin_src python
nums = [1.23e+18, 1, -1.23e+18]
sum(nums)
# => 0.0
import math
math.fsum(nums)
# => 1.0
,#+end_src

,*** formatting numbers for output
to format a single number for output, use the built-in format() function.

,#+begin_src python
x = 1234.34045
format(x, '0.2f')
# => '1234.34'
format(x, '> 10.1f')
# => '    1234.3'
format(x, '<10.1f')
# => '1234.3    '
format(x,',')
# => '1,234.34045'
,#+end_src

,** list
与元组对比，列表的长度可变，内容可以被修改。属于 mutable.

,#+begin_src python
tup = ('foo', 'bar')
b_list = list(tup)
b_list
b_list[1] = 'peekaboo'
b_list
,#+end_src
附加（append，extend），插入（insert），删除（remove,pop）这些操作都可以用在它身上。

,#+begin_src python
l = [1,10,'python']
l.append([4,3])
l
# =>
[1, 10, 'python', [4, 3]]
l.extend([4, 33]
   l
   # => [1, 10, 'python', 4, 3]
   l.extend([1,2,'ok'])
   l
   # => [1, 10, 'python', 1, 2, 'ok']
,#+end_src

严格来说 append 是追加，把一个东西整体添加在列表后，而 extend 是扩展，把一个东西里的所有元素添加在列表后。对着上面结果感受一下区别。

,** 列表长度

,#+begin_src python
len([1,2,3])
# => 3
,#+end_src

,*** 笛卡尔积
python 真的很喜欢用 for 循环。

,#+begin_src python
colors = ['black', 'white']
sizes = ['S', 'M', 'L']
tshirts = [(color, size) for color in colors for size in sizes]
# [('black', 'S'), ('black', 'M'), ('black', 'L'), ('white', 'S'), ('white', 'M'), ('white', 'L')]
,#+end_src

,** 切片操作
在 python 里，像列表（list）\元组（tuple）\字符串（str）这类序列类型都支持切片操作。

#+begin_src python
l = [10, 20, 30, 40]
l[::2]
# [10, 20]
l[0:3]
# [10, 20, 30]
#+end_src

还可以对对象进行切片。可以用 s[a:b:c] 的形式对 s 在 a 和 b 之间以 c 为间隔取值。c 的值还可以为负，负值意味着可以反向取值。

#+begin_src python
s = 'bicycle'
s[::3] #间隔为3
s[1::3]
# => 'ic'
# bye
s[::-1]
# 'elcycib'
s[::-2]
# 'eccb'
#+end_src

给切片赋值

#+begin_src python
l = list(range(10))
l
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
l[2:5] = [20, 30]
l
# [0, 1, 20, 30, 5, 6, 7, 8, 9]
del l[5:7]
l
l[3::2] = [11, 22]
l
# [0, 1, 20, 11, 5, 22, 9]
l[2:5] = 100
l[2:5] = [100]
l
#+end_src

第一种索引器是 loc 属性，表示取值和切片都是显式。 python 代码的设计原则是“显式优于隐式”。所以，索引器 loc 只是在 pandas 中应用。

#+begin_src python
import pandas as pd
data = pd.Series(['a', 'b', 'c'], index=[1, 3, 5])
data
# => 1    a
#    3    b
#    5    c
#    dtype: object
data[1]
# => 'a'
data[1:3]
# => 3    b
#    5    c
#    dtype: object
data.loc[1]
# => 'a'
data.loc[1:3]
# => 1    a
#    3    b
#    dtype: object
#+end_src

** 推导式

#+begin_src python
[x for x in range(5)]
#> [0, 1, 2, 3, 4]

[x + 10 for x in range(10) if x % 2 == 0]
#> [10, 12, 14, 16, 18]
#+end_src

输出表达式：x+10; 数据源迭代：for x in range(10); 过滤表达式：if x % 2 == 0. 推导式还可以直接用作函数调用实参。

#+begin_src python
def test(data):
    print(type(data), data)

test({x for x in range(3)})
#> <class 'set'> {0, 1, 2}
#+end_src

推导式允许有多个 for 子句，每个子句都可选一个 if 条件表达式。

#+begin_src python
[f"{x}{y}" for x in "abc" if x != "c"
           for y in range(3) if y != 0]
#> ['a1', 'a2', 'b1', 'b2']
#+end_src

*** 字典

#+begin_src python
{k:v for k,v in zip("abc", range(10, 13))}
#> {'a': 10, 'b': 11, 'c': 12}
#+end_src

*** 集合

#+begin_src python
{x for x in "abc"}
#> {'a', 'b', 'c'}
#+end_src

** 重复次数

#+begin_src python
l = [1, 2, 3]
l * 2
# => [1, 2, 3, 1, 2, 3]
2 * 'abc'
# 'abcabc'
#+end_src

*** 建立由列表组成的列表
** 聚合
reduce,类似于 R 中的函数。如果需要存储每次计算的中间结果，那么可以使用 accumulate, .sum, np.prod, np.cumsum, np.cumprod 这些函数都可以实现 reduce 的功能。

#+begin_src python
import numpy as np
x = np.arange(1, 6)
x
# => array([1, 2, 3, 4, 5])
np.add.reduce(x)
# => 15
np.multiply.reduce(x)
# => 120
np.multiply.accumulate(x)
# => array([  1,   2,   6,  24, 120])
#+end_src

** 外积

#+begin_src python
import numpy as np
x = np.array([0, 1, 2])
np.multiply.outer(x, x)
# =>
# array([[0, 0, 0],
#        [0, 1, 2],
#        [0, 2, 4]])
,#+end_src

,** 广播
对于同样大小的数组，二进制操作是对相应元素逐个计算：

,#+begin_src python
a = np.array([0, 1, 2])
b = np.array([5, 5, 5])
a + b
# => array([5, 6, 7])
a = np.array([0, 1, 2])
a + 5
,#+end_src

,** 枚举
在多数语言里,枚举是面向编译器,类似数字常量的存在.但到了python 这里,事情变得有些复杂.首先,需要定义枚举类型,随后由内部代码生成对应的枚举值.
                                                       
,#+begin_src python
import enum
color = enum.Enum("color", "black yellow blue red")
,#+end_src

,** 统计记录个数
如果需要统计布尔数组中 True 记录的个数，可以使用 np.count_nonzero 函数。

,#+begin_src python
X = np.random.random((2, 3))
X.mean(0) #对列进行统计
# => array([0.50275777, 0.77663369, 0.52202549])
X.mean(1) #对行进行统计
# => array([0.57452292, 0.62642171])
X < 0.2 #对所有元素进行判断
# =>
# array([[False, False, False],
#        [False, False, False]])
np.count_nonzero(X<0.2) #统计True 的个数
# => 0
,#+end_src

,** value_counts
value_counts() 相当于 dplyr 包中的 count(). 相当于 R 中的 table.具体用法是 df.colName.value_counts().

,#+begin_src python
X= np.random.random((10, 3))
X.value_counts()
housing['income_cat'].value_counts()
count.nlargest(2).index
,#+end_src

,** mode
可以统计series 或dataframe 的众数，即出现频率最高的值。

,#+begin_src python :results output
s5 = pd.Series([1, 1, 3, 3, 3, 5, 5, 7, 7, 7])
s5.mode()
# =>
#    0    3
#    1    7
#    dtype: int64
,#+end_src

,** cut
cut() 函数（以值为依据实现分箱）及 qcut() 函数（以样本分位数为依据实现分箱）用于连续值的离散化。

,#+begin_src python :results output
import numpy as np
import pandas as pd
arr = np.random.randn(20)
pd.cut(arr,4)
# =>
#
# [(-0.444, 0.324], (0.324, 1.092], (1.092, 1.86], (-0.444, 0.324], (-1.215, -0.444], ..., (-0.444, 0.324], (1.092, 1.86], (-1.215, -0.444], (-1.215, -0.444], (1.092, 1.86]]
# Length: 20
# Categories (4, interval[float64]): [(-1.215, -0.444] <
#                                     (-0.444, 0.324] <
#                                     (0.324, 1.092] <
#                                     (1.092, 1.86]]
pd.qcut(arr,[0,0.25,0.5,0.75,1])
# =>
#
# [(-0.297, 0.234], (0.234, 1.354], (1.354, 1.86], (-0.297, 0.234], (-1.2129999999999999, -0.297], ..., (-0.297, 0.234], (1.354, 1.86], (-1.2129999999999999, -0.297], (-1.2129999999999999, -0.297], (1.354, 1.86]]
# Length: 20
# Categories (4, interval[float64]): [(-1.2129999999999999, -0.297] <
#                                     (-0.297, 0.234] <
#                                     (0.234, 1.354] <
#                                     (1.354, 1.86]]
,#+end_src

定义分箱时，可以传递无穷值。

,#+begin_src python :results output
pd.cut(arr,[-np.inf,0,np.inf])
# =>
#
# [(0.0, inf], (0.0, inf], (0.0, inf], (0.0, inf], (-inf, 0.0], ..., (0.0, inf], (0.0, inf], (-inf, 0.0], (-inf, 0.0], (0.0, inf]]
# Length: 20
# Categories (2, interval[float64]): [(-inf, 0.0] < (0.0, inf]]
,#+end_src

,** nlargest
本方法返回N 个最大或最小的值。

,#+begin_src python :results output
count = iris.species.value_counts()
count.nlargest(2)
,#+end_src

dataframe 也支持 nlargest 与 nsmallest 方法。
,#+begin_src python :results output
df = pd.DataFrame({'a': [-2, -1, 1, 10, 8, 11, -1],
                       'b': list('abdceff'),
                       'c': [1.0, 2.0, 4.0, 3.2, np.nan, 3.0, 4.0]})
df.nsmallest(3, 'a') #'a' 列第3小的元素
,#+end_src

,** 处理缺失值
,*** isnull
python 中np.nan 与 None 是等价关系？

,#+begin_src python
import pandas as pd
import numpy as np
df1 = pd.Series([1, np.nan, 2, None])
# => 0    1.0
#    1    NaN
#    2    2.0
#    3    NaN
#    dtype: float64
df1.isnull()
# => 0    False
#    1     True
#    2    False
#    3     True
#    dtype: bool
df1[df1.notnull()]
# => 0    1.0
#    2    2.0
#    dtype: float64
,#+end_src

在 series 里使用的 isnull() 和 notnull() 同样适用于 dataframe
,*** fillna
df.fillna(),将缺失值填充为给定值.

,#+begin_src python
df1
# => 0    1.0
#    1    NaN
#    2    2.0
#    3    NaN
#    dtype: float64
df1.fillna(0)
# => 0    1.0
#    1    0.0
#    2    2.0
#    3    0.0
#    dtype: float64
,#+end_src

,*** dropna
分别是 dropna() (剔除缺失值) 和 fillna() (填充缺失值).可以按着行或者列筛选 NA 值。

,#+begin_src python
import #+end_example
pandas as pd
df1 = pd.Series([1, np.nan, 2, None])
# => 0    1.0
#    1    NaN
#    2    2.0
#    3    NaN
#    dtype: float64
df1.dropna()
# => 0    1.0
#    2    2.0
#    dtype: float64
#+end_src

默认情况下，dropna() 会剔除任何包含缺失值的整行数据。

#+begin_src python
import numpy as np 
df = pd.DataFrame([[1, np.nan, 2],
                  [2, 3, 5],
                  [np.nan, 4, 6]])
df
# =>      0    1  2
#    0  1.0  NaN  2
#    1  2.0  3.0  5
#    2  NaN  4.0  6
df.dropna(thresh = len(df)*0.9, axis = "columns")
# =>    2
#    0  2
#    1  5
#    2  6
#+end_src

可以设置按不同的坐标轴剔除缺失值，比如 axis = 1 (或 axis = 'columns') 会剔除任何包含缺失值的整列数据。

只想删除列中缺失值高于10% 的缺失值，可以设置 dropna() 里的阈值。

#+begin_src python
df.dropna(axis='columns')
df.dropna(axis='columns', how='all')
#+end_src

默认设置是 how = 'any',也就是只要有缺失值就是剔除整行或整列（通过 axis 设置座标轴），还可以设置 how = 'all',这样就只会剔除全部是缺失值的行或列了。

#+begin_src python
df.dropna(axis='rows', thresh=3)
#+end_src

*** datetime

#+begin_src python
import datetime
datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S') + '   星期:' + str(datetime.datetime.now().isoweekday())
#+end_src

** 合并数据集
*** concat 与 append 操作
numpy 中可以用 np.concatenate 函数将 numpy 数组进行合并。np.vstack np.hstack

#+begin_src python
x = [1, 2, 3]
y = [4, 5, 6]
np.concatenate([x,y])
# array([1, 2, 3, 4, 5, 6])

x = np.array([[1,2],[3,4]])
y = np.array([[5,6],[7,8]])
np.concatenate((x, y), axis = 0) #x,y 纵向叠加合并成4乘2矩阵
# =>
# array([[1, 2],
#        [3, 4],
#        [5, 6],
#        [7, 8]])
np.concatenate((x, y), axis = 1) #x,y 纵向叠加合并成2乘4矩阵
# =>
# array([[1, 2, 5, 6],
#        [3, 4, 7, 8]])
np.vstack((x, y)) #np.concatenate((x, y), axis = 0)
# =>
# array([[1, 2],
#        [3, 4],
#        [5, 6],
#        [7, 8]])
np.hstack((x, y)) #np.concatenate((x, y), axis = 1)
#+end_src

#+begin_src python
import numpy as np
b = np.array(a).flatten().tolist()
# => [1, 2, 3, 4, 5, 6]
#+end_src

*** pd.concat
这个函数不能将 list 型数据进行合并。 pd.concat(objs, axis=0, join='outer')

#+begin_src python
pd.concat([pd.Series(x),pd.Series(y)],axis=1)
#+end_src

#+begin_src python :results output
l = pd.DataFrame(data=None)
for date in df['cal_date'].values:
     l = pd.concat([l,get_daily(trade_date = date)])
#+end_src

用concat() 函数可以把原dataframe 与新dataframe 组合在一起。

#+begin_src python :results output
pd.concat([df, df_new], axis = 'columns')
#+end_src

*** 伪随机数
生成一个[1,100]以内的随机整数 random.randint(1,100)。随机生成5个随机小数np.random.randn(5). 0-1 随机小数，random.random(),括号内不传参。

#+begin_src python
import random
random.seed(1010)
random.randint(1, 100)
# => 78
random.choice([1,2,4,'word']) #随机选择一个数字
# => 2
random.sample(range(100), 5)
# => [68, 10, 52, 55, 21]
random.random()
# => 0.14252352294885373
#+end_src

** union/intersection/difference
基本模块的集合运算不能直接用于 list，但可以用于通过函数 set()转换的 list,这些计算包括集合的差（difference），并（union），交（intersection）。

#+begin_src python
set(['I', 'you', 'he', 'I'])
# => {'you', 'he', 'I'}
#+end_src

#+begin_src python
set.difference(set(['a',2,'5']),set(['a',7]))
# => {2, '5'}
set.union(set(['a',2,'5']),set(['a',7]))
# => {2, '5', 7, 'a'}
set.intersection(set(['a',2,'5']),set(['a',7]))
# => {'a'}
#+end_src

** eval
和 R 一样，eval 的用法也类似。eval(str_expression)作用是将字符串转换成表达式，并且执行。
#+begin_src python
eval('[1,2,3]')
#> [1, 2, 3]
x = 7
eval('x**2')
# => 49
#+end_src

** assert
可以 check 等式是否成立.

#+begin_src python
a = 3
assert(a>1)
print("断言成功，程序继续向下执行")

b = 4
assert(b>7)
# => Traceback (most recent call last):
#      File "<stdin>", line 1, in <module>
#    AssertionError
print("断言失败，程序报错")
#+end_src

** 统计
*** 最小值和最大值
#+begin_src python
min(L),max(L)
#+end_src

#+begin_src python
import numpy as np
M = np.random.random((2, 2))
M.sum()
# => 3.096348468019526
M.min(axis = 0)
# => array([0.72297729, 0.49036662])

from sklearn.preprocessing import MinMaxScaler
#区间缩放，返回值为缩放到[0, 1]区间的数据
minMaxScaler = MinMaxScaler().fit(X_train)
# => Traceback (most recent call last):
#      File "<stdin>", line 1, in <module>
#      File "/Users/luyajun/Documents/坚果云/我的坚果云/github/wiki/python_wiki.org", line 1, in <module>
#        # -*- org-confirm-babel-evaluate: nil; -*-
#    NameError: name 'X_train' is not defined
minMaxScaler.transform(X_train)
# => Traceback (most recent call last):
#      File "<stdin>", line 1, in <module>
#    NameError: name 'minMaxScaler' is not defined
#+end_src

*** 数组值求和\累积\乘积\差分

#+begin_src python
import numpy as np
L = np.random.random(100)
sum(L)
# => 46.01864793657274
np.prod(x)
# => 7
np.cumsum(x)
# => array([7])
#+end_src

当数组数据中有缺失值 None 时，就需要借助filter 函数，这点没有R 来的方便。

#+begin_src python :results output
sum(filter(None, [1,2,3,None]))
# => 6
#+end_src

array 变成矩阵，可以通过限定 shape 来确定矩阵维数。

#+begin_src python
x = np.array([32, -12, 3, 5])
x.shape = 2, 2
x
# =>
# array([[ 32, -12],
#        [  3,   5]])
np.diff(x, axis=0) #按行差分
# => array([[-29,  17]])
np.diff(x, axis=1) #按列差分
# =>
# array([[-44],
#        [  2]])
#+end_src

*** kronecker 积

#+begin_src python
import numpy as np
A = np.eye(3)
# =>
# array([[1., 0., 0.],
#        [0., 1., 0.],
#        [0., 0., 1.]])
B = np.array([[1,2], [3, 4]])
np.kron(A, B)
# =>
# array([[1., 2., 0., 0., 0., 0.],
#        [3., 4., 0., 0., 0., 0.],
#        [0., 0., 1., 2., 0., 0.],
#        [0., 0., 3., 4., 0., 0.],
#        [0., 0., 0., 0., 1., 2.],
#        [0., 0., 0., 0., 3., 4.]])
#+end_src

*** 舍入运算
在 R 里面是 round(x,6).在python 中，也可以直接使用 round.

#+begin_src python
import numpy as np
x = np.array([1.234, 2.387, 3.673])
# => array([1.234, 2.387, 3.673])
np.round(x, 2) #四舍五入
# => array([1.23, 2.39, 3.67])
round(1344545, -1)
# => 1344540
np.around(x, 2)
# => array([1.23, 2.39, 3.67])
np.floor(x) #保留整数位
# => array([1., 2., 3.])
np.ceil(x)
# => array([2., 3., 4.])
#+end_src

指数，对数，符号函数，绝对值，极值

#+begin_src python
import numpy as np
x = np.array([-2, 7, 9, 6]).reshape(2, 2)
x
# =>
# array([[-2,  7],
#        [ 9,  6]])
np.sign(x)
# =>
# array([[-1,  1],
#        [ 1,  1]])
np.exp(x)
# =>
# array([[1.35335283e-01, 1.09663316e+03],
#        [8.10308393e+03, 4.03428793e+02]])
np.log(x)
# =>
# array([[       nan, 1.94591015],
#        [2.19722458, 1.79175947]])
np.abs(x)
# =>
# array([[2, 7],
#        [9, 6]])
x.max()
# => 9
np.argmin(x, 0)
# => array([0, 1])
#+end_src

arange,range

#+begin_src python
np.arange(3,5,.5) #从3到5(不包含5)等间隔为0.5 的数列
# => array([3. , 3.5, 4. , 4.5])
np.arange(4)
# array([0, 1, 2, 3])
#+end_src

点乘法

#+begin_src python
x = np.arange(4,7,.4)
y = np.arange(1,5)
np.dot(x.reshape(len(x), 1),
       y.reshape(1, len(y)))
#+end_src

数组维度大小

#+begin_src python
np.shape(x)
np.shape(y)
#+end_src

转置
#+begin_src python
x = [[2,3],[7,5]]
z = np.asmatrix(x)
z
# =>
# matrix([[2, 3],
#         [7, 5]])
print(z, type(z))
print(z.transpose()*z)
print(z.T*z)
#+end_src

维数和大小
#+begin_src python
np.ndim(z)
z.shape
#+end_src

*** 画图

#+begin_src python
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import sklearn
def prepare_country_stats(oecd_bli, gdp_per_capita):
    oecd_bli = oecd_bli[oecd_bli["INEQUALITY"]=="TOT"]
    oecd_bli = oecd_bli.pivot(index="Country", columns="Indicator", values="Value")
    gdp_per_capita.rename(columns={"2015": "GDP per capita"}, inplace=True)
    gdp_per_capita.set_index("Country", inplace=True)
    full_country_stats = pd.merge(left=oecd_bli, right=gdp_per_capita,
                                  left_index=True, right_index=True)
    full_country_stats.sort_values(by="GDP per capita", inplace=True)
    remove_indices = [0, 1, 6, 8, 33, 34, 35]
    keep_indices = list(set(range(36)) - set(remove_indices))
    return full_country_stats[["GDP per capita", 'Life satisfaction']].iloc[keep_indices]

##load data
url1 = "https://raw.githubusercontent.com/WillKoehrsen/Hands-On-Machine-Learning/master/handson-ml-master/datasets/lifesat/oecd_bli_2015.csv"
oecd_bli = pd.read_csv(url1, thousands=',')

url2 = 'https://raw.githubusercontent.com/ageron/handson-ml/master/datasets/lifesat/gdp_per_capita.csv'
gdp_per_capita = pd.read_csv(url2, thousands=',', delimiter='\t', encoding='latin1',na_values="n/a")

#prepare the data
country_stats = prepare_country_stats(oecd_bli, gdp_per_capita)
x = np.c_[country_stats['GDP per capita']]
y = np.c_[country_stats['Life satisfaction']]

##visualize the data
country_stats.plot(kind='scatter', x="GDP per capita", y='Life satisfaction')
plt.show()
#+end_src

*** 线性模型

#+begin_src python
##load data
url1 = "https://raw.githubusercontent.com/WillKoehrsen/Hands-On-Machine-Learning/master/handson-ml-master/datasets/lifesat/oecd_bli_2015.csv"
oecd_bli = pd.read_csv(url1, thousands=',')

url2 = 'https://raw.githubusercontent.com/ageron/handson-ml/master/datasets/lifesat/gdp_per_capita.csv'
gdp_per_capita = pd.read_csv(url2, thousands=',', delimiter='\t', encoding='latin1',na_values="n/a")

#prepare the data
country_stats = prepare_country_stats(oecd_bli, gdp_per_capita)
x = np.c_[country_stats['GDP per capita']]
y = np.c_[country_stats['Life satisfaction']]

##visualize the data
country_stats.plot(kind='scatter', x="GDP per capita", y='Life satisfaction')
plt.show()

#select a linear model
lin_reg_model = sklearn.linear_model.LinearRegression()

#train the model
lin_reg_model.fit(x,y)
#Make a prediction for cyprus
x_new = [[22587]]
print(lin_reg_model.predict(x_new))
#+end_src

#+begin_src python
np.random.seed(1010)
X = np.random.randn(100, 3)
X1 = np.hstack((np.ones((100, 1)),X))
y = np.random.randn(100)
beta,SSR,rank,sv = np.linalg.lstsq(X, y)
beta
#+end_src

*** lasso

#+begin_src python
from sklearn import linear_model
clf = linear_model.Lasso(alpha=0.1)
clf.fit([[0, 0],
         [1, 1],
         [2, 2]],
        [0, 1, 2])
clf.coef_
clf.intercept_
#+end_src

** 数据清理
*** 数字型变量
删除缺失值，删除一个特征，将缺失值填充为一个固定值。
#+begin_src python
housing.dropna(subset=['total_bedrooms']) #option 1 可以理解为删除缺失值
housing.drop('total_bedrooms', axis=1)  #删除一个特征
median = housing['total_bedrooms'].median()
housing['total_bedrooms'].fillna(median)
#+end_src

*** 字符串和文本
**** 使用多个界定符分割字符串

#+begin_src python
line ='asdf fjjdk; afed, fjek'
import re
fields = re.split(r'[;,\s]\s*', line)
fields
# => ['asdf', 'fjjdk', 'afed', 'fjek']
values = fields[::2]
delimiters = fields[1::2] + ['']
#+end_src
**** 去除空格

#+begin_src python
a = (i for i in range(3))
a = " heheheh "
a.strip()
#+end_src


**** 字符串开头或结尾匹配
检查字符串开头或结尾的一个简单方法是使用 str.startswith() 或者是 str.endswith() 方法。比如：

#+begin_src python
filename = 'spam.txt'
filename.endswith('.txt')
# => True
filename.startswith('file:')
# => False
url = 'http://www.python.org'
url.startswith('http')
# => True
#+end_src

如果想检查多种匹配可能，只需要将所有的匹配项放入到一个元组中去，然后传给 startswith() 或者 endswith() 方法：

#+begin_src python
import os
filenames = os.listdir(".")
filenames[0:2]
[name for name in filenames if name.endswith(('.org'))] #展示以 org 结尾的文件名称
any(name.endswith('.py') for name in filenames) #判断目录下是否有py 文件
#+end_src

**** 用 shell 通配符匹配字符串

#+begin_src python
from fnmatch import fnmatch,  fnmatchcase
fnmatch('foo.txt', '*.txt')
fnmatch('foo.txt', '?oo.txt')
fnmatch('Dat45.csv', 'Dat[0-9]*')
#+end_src

**** 字符串搜索和替换

#+begin_src python
text = 'yeah, but no'
text.replace('yeah', 'yep')
# => 'yep, but no'
#+end_src

对于复杂的模式，需要使用 re 模块中的 sub() 函数。

#+begin_src python
##LabelBinarizer 类可以一次性完成两个转换
from sklearn.preprocessing import LabelBinarizer
encoder = LabelBinarizer()
housing_cat_1hot = encoder.fit_transform(housing_cat)
housing_cat_1hot
#+end_src

**** 转换
内置多个函数将整数转换为指定进制的字符串，反向操作用 int.十进制转二进制

#+begin_src python :results output
print(bin(100))
# => 0b1100100
#+end_src

** 类
Python 从设计之初就已经是一门面向对象的语言，正因为如此，在 Python 中创建一个类和对象是很容易的。

根据类来创建对象被称为实例化。一个简单的样例如下：使用类几乎可以模拟任何东西。下面一个简单的例子是模拟小狗，对于多数小狗，都会有名字和年龄，那么创造一个类就会包含这两个信息。

#+begin_src python
class Dog():
    """一次模拟小狗的简单尝试"""

    def __init__(self, name, age):
        """初始化属性name和age"""
        self.name = name
        self.age = age

    def sit(self):
        """模拟小狗被命令时蹲下"""
        print(self.name.title() + " is now sitting.")

    def roll_over(self):
        """模拟小狗被命令时打滚"""
        print(self.name.title() + " rolled over!")
#+end_src

在 python 中，首字母大写的名称就是类。这个类定义中的括号是空的。

#+begin_src python
print("RMSE: %f" % (rmse))
#+end_src

** 面向对象技术简介

*类(Class):* 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。

*方法：* 类中定义的函数。

类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。

数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。

方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。

局部变量：定义在方法中的变量，只作用于当前实例的类。

实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。

继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个 Dog 类型的对象派生自 Animal 类，这是模拟"是一个（is-a）"关系（例图，Dog 是一个 Animal）。

实例化：创建一个类的实例，类的具体对象。

对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。

类的定义：
#+begin_src python
class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
#+end_src

实例化类其他编程语言中一般用关键字 new，但是在 python 中并没有这个关键字，类的实例化类似函数调用方式。

类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。

类对象：

类对象支持两种操作：属性引用和实例化。属性引用使用和 python 中所有的属性引用一样的标准语法：obj.name.类对象创建后，类命名空间中所有的命名都是有效属性名。所有如果类定义是这样类的方法与普通函数只有一个特别的区别，它们必须有一个额外的第一个参数名称，按照惯例它的名称为 self。

在 python 中，可以使用点 . 来访问对象的属性，也可以使用以下函数的方式来访问属性：

- getattr(obj, name) 访问对象的属性

- hasattr(obj, name) 检查是否存在一个属性

#+begin_src python :results output
class myclass(object):
    def __init__(self):
        self.foo = 100

myinst = myclass()
hasattr(myinst, 'foo')
getattr(myinst, 'foo')
hasattr(myinst, 'bar')
getattr(myinst, 'bar')
setattr(myinst, 'bar','my attr')
getattr(myinst,'bar')
delattr(myinst, 'bar')
getattr(myinst, 'bar')
#+end_src

- setattr(obj, name, value) 设置一个属性，如果属性不存在，会创建一个新属性,存在的话，会覆盖掉原来的属性值。

- delattr(obj, name) 删除属性

python 内置类属性：

__dict__：类的属性（包含一个字典，由类的数据属性组成）

__doc__：类的文档字符串

__name__：类名

__module__：类定义所在的模块

__bases__：类的所有父类构成的元素（包含了一个由所有父类组成的元组）。

#+begin_src python
class MyClass:
    i = 12345
    def f(self):
        return 'hello world'

#实例化
x = MyClass()

##访问类的属性和方法
print('MyClass 类的属性 i 为：', x.i)
print('MyClass 类的方法 f 输出为：', x.f())
#+end_src

python 对象销毁（垃圾回收）：python 使用了引用计数这一简单技术来跟踪和回收垃圾。在 python 内部记录着所有使用中的对象各自有多少引用。一个完整的 python 类例子是：

#+begin_src python
class Employee:
    '所有员工的基类'
    empCount = 0

    def __init__(self, name, salary):
        self.name = name
        self.salary = salary
        Employee.empCount += 1

    def displaycount(self):
        print("Total Employee %d" % Employee.empCount)

    def displayEmployee(self):
        print("Name:", self.name, ", Salary:", self.salary)

print("Employee.__doc__:", Employee.__doc__)
# => Employee.__doc__: 所有员工的基类
print("Employee.__name__:", Employee.__name__)
# => Employee.__name__: Employee
print("Employee.__module__:", Employee.__module__)
# => Employee.__module__: __repl__
print("Employee.__bases__:", Employee.__bases__)
# => Employee.__bases__: (<class 'object'>,)
print("Employee.__dict__:", Employee.__dict__)
# =>
# Employee.__dict__: {'__module__':
#                     '__repl__', '__doc__':
#                     '所有员工的基类', 'empCount':
#                     0, '__init__': <
#                     function Employee.
#                     __init__ at
#                     0x1268529d8>, 'displaycount': <
#                     function Employee.
#                     displaycount at
#                     0x126852a60>, 'displayEmployee': <
#                     function Employee.
#                     displayEmployee at
#                     0x126852ae8>, '__dict__': <
#                     attribute '__dict__'
#                     of 'Employee'
#                     objects>, '__weakref__':
#                     <attribute '__weakref__' of 'Employee' objects>}
#+end_src

类定义了__init__() 方法可以有参数，参数通过__init__()传递到类的实例化操作上的。

#+begin_src python
class Complex:
    def __init__(self, realpart, imagpart):
        self.r = realpart
        self.i = imagpart

x = Complex(3, -4.5)
print(x.r, x.i)
#+end_src

self 代表类的实例，而非类

#+begin_src python
class Test:
    def prt(self):
        print(self)
        print(self.__class__)

t = Test()
t.prt()
#+end_src

类的方法：
#+begin_src python
#类定义
class people:
    #定义基本属性
    name = ''
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print("%s 说: 我 %d 岁。" %(self.name,self.age))
# 实例化类
p = people('runoob',10,30)
# => <__repl__.people object at 0x12685d3c8>
p.speak()
# => runoob 说: 我 10 岁。
#+end_src

*** 继承
python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下：

#+begin_src python
class DerivedClassName(BaseClassName1):
    <statement-1>
    .
    .
    .
    <statement-N>
#+end_src

BaseClassName(示例中的基类名)必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时非常有用。

#+begin_src python
#类定义
class people:
    #定义基本属性
    name = ''
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print("%s 说: 我 %d 岁。" %(self.name,self.age))

#单继承示例
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print("%s 说: 我 %d 岁了，我在读 %d 年级"%(self.name,self.age,self.grade))

s = student('ken',10,60,3)
s.speak()
#+end_src

** 转义
** Packages
*** seaborn
**** get_dataset_names
获取dataset 名称。
#+begin_src python
import seaborn as sns
sns.get_dataset_names()
#+end_src

**** load_dataset
这个包下面有很多的数据集。
#+begin_src python
import seaborn as sns
flight_data = sns.load_dataset('flights')
#+end_src

*** sklearn
**** MinMaxScaler
#+begin_src python
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(-1,1))
train_data_normalized = scaler.fit_transform(train_data.reshape(-1,1))
#+end_src

*** dplython
这个包类似于 dplyr.
**** select

#+begin_src python
import pandas
from dplython import (DplyFrame, X, diamonds, select, sift, sample_n,
    sample_frac, head, arrange, mutate, group_by, summarize, DelayFunction)

diamonds >> select(X.carat) >> head
     #+end_src

     #+begin_src python
    #+begin_src python
class Car():
    """一次模拟汽车的简单尝试"""
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_descriptive_name(self):
        long_name = str(self.year) + " " + self.make + " " + self.model
        return long_name.title()

    def read_odometer(self):
        print("this car has " + str(self.odometer_reading) + " miles on it.")

    def update_odometer(self, mileage):
        if mileage >= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print("You can't roll back an odometer!")

    def increment_odometer(self, miles):
        self.odometer_reading += miles

class ElectricCar(Car):
    """电动车的独特之处"""
    def __init__(self, make, model, year):
        """初始化父类的属性"""
        super().__init__(make, model, year)


my_tesla = ElectricCar('tesla', 'model s', 2016)
print()
#+end_src

**** filter
在 python 中，filter 是 sift.

#+begin_src python
diamonds >> sift(X.carat > 4) >> select(X.carat, X.cut,
                                        X.depth, X.price)
#+end_src

在python 中，要像dplyr 那样优雅的处理数据，得load dply。

#+begin_src python :results output
from dplython import (DplyFrame, X, diamonds, select, sift,
  sample_n, sample_frac, head, arrange, mutate, group_by,
  summarize, DelayFunction)

price_data >> mask(price_data.name == "金徽酒")
price_data[price_data.name.str.contains("金徽酒")].sort_values(by = ["decrease_ratio","max_high"])
#+end_src

**** sample
随机抽样。

#+begin_src python
diamonds["column w/spaces"] = range(len(diamonds))
diamonds >> \
select(X["column w/spaces"])
diamonds.sample(100)
diamonds.sample(frac=0.2)
#+end_src

把dataframe 分为两个随机子集，一个占75%的数据量，另一个25%.

使用drop() 方法可以快速删掉price_data 中一部分数据。

#+begin_src python :results output
diamonds.sample(frac=0.2, random_state=1234)
temp1 = price_data.sample(frac=0.5,random_state=1234)
price_data.drop(temp1.index).shape
#+end_src

**** arrange

 #+begin_src python
 diamonds >> arrange(X.carat)
     #+end_src
这个函数不能实现降序。可以用下面这个函数实现。
     #+begin_src python
 diamonds >> sample_n(10)
 #+end_src

**** mutate
mutate 新建一列数据。
     #+begin_src python
 diamonds >> \
mutate(carat_bin = X.carat.round())
     #+end_src

以下语句可以实现相同的功能。

#+begin_src python
diamonds.sort_values("carat", ascending=False)
#+end_src

mutate by group

#+begin_src python
diamonds.groupby('cut').apply(lambda x: np.mean(x.price)).reset_index(level=0, drop=True)
#+end_src

**** distinct

#+begin_src python
import pandas
from dplython import (DplyFrame, X, diamonds, select, sift, sample_n,
    sample_frac, head, arrange, mutate, group_by, summarize, DelayFunction)
diamonds.assign(carat_bin = diamonds.carat.round()).head()
#>    Unnamed: 0  carat      cut color clarity  depth  table  price     x     y  \
# 0           1   0.23    Ideal     E     SI2   61.5   55.0    326  3.95  3.98
# 1           2   0.21  Premium     E     SI1   59.8   61.0    326  3.89  3.84
# 2           3   0.23     Good     E     VS1   56.9   65.0    327  4.05  4.07
# 3           4   0.29  Premium     I     VS2   62.4   58.0    334  4.20  4.23
# 4           5   0.31     Good     J     SI2   63.3   58.0    335  4.34  4.35

#       z  carat_bin
# 0  2.43        0.0
# 1  2.31        0.0
# 2  2.31        0.0
# 3  2.63        0.0
# 4  2.75        0.0
#+end_src

#+begin_src python
diamonds.drop_duplicates()
df.drop_duplicates(subset='col1') # returns dataframe with unique values of col1
diamonds.drop_duplicates("cut")
#+end_src

**** group_by

#+begin_src python
import pandas
from dplython import (DplyFrame, X, diamonds, select, sift, sample_n,
    sample_frac, head, arrange, mutate, group_by, summarize, DelayFunction)
diamonds >> \
mutate(carat_bin=X.carat.round()) >> \
group_by(X.cut, X.carat_bin) >> \
summarize(avg_price=X.price.mean()) >> \
head
# #>     cut  carat_bin     avg_price
# 0  Fair        0.0   1027.979275
# 1  Fair        1.0   3305.754579
# 2  Fair        2.0   9588.269737
# 3  Fair        3.0  13466.823529
# 4  Fair        4.0  15842.666667
#+end_src

**** T
转置。

#+begin_src python
diamonds >> select(X.carat, X.cut) >> head >> X._.T
#+end_src
*** reprex
类似于 R 中的 reprex.

#+begin_src python
from reprexpy import reprex
reprex()
#+end_src

*** pipe
管道符 |

#+begin_src python :results output
from pipe import *
[1,2,3,4] | where (lambda x:x%2) | tail(2) | select(lambda x: x*x) | add
#+end_src

*** pytorch
为啥选择pytorch?

- Pytorch中最重要的就是Variable模块，该模块集成了围绕一个张量所有的操作，包括前向传播、反向传播的各种求偏导数的数值。

- Pytorch所有的网络在nn包里，我们待会会实现经典的Lenet5模型。

- Pytorch计算GPU和CPU切换很快，直接使用x.cuda()即可

#+begin_src python
import torch
import numpy as np
torch.tensor([[1, -1], [1, -1]])
# =>
#
# tensor([[ 1, -1],
#         [ 1, -1]])
torch.tensor(np.array([[1, 2, 3], [4, 5, 6]]))
# =>
#
# tensor([[1, 2, 3],
#         [4, 5, 6]])
#+end_src

#+begin_src python
from __future__ import print_function
import torch
x = torch.Tensor(5, 3)
# =>
# tensor([[ 0.0000e+00, -2.0000e+00,  0.0000e+00],
#         [-2.0000e+00,  7.0065e-45,  0.0000e+00],
#         [ 0.0000e+00,  0.0000e+00,  0.0000e+00],
#         [ 0.0000e+00,  0.0000e+00,  0.0000e+00],
#         [ 0.0000e+00,  0.0000e+00,  0.0000e+00]])
x = torch.rand(5, 3)
# =>
# tensor([[0.6338, 0.7640, 0.2705],
#         [0.7526, 0.4298, 0.5034],
#         [0.2133, 0.3547, 0.2881],
#         [0.0147, 0.5184, 0.4553],
#         [0.9626, 0.4408, 0.7808]])
x.size()
# => torch.Size([5, 3])
y = torch.rand(5, 3)
x + y
torch.add(x, y)
# =>
#
# tensor([[1.3094, 1.1680, 0.9302],
#         [1.0575, 1.0410, 0.9032],
#         [0.6446, 1.2074, 0.5801],
#         [0.4301, 0.7996, 1.2447],
#         [1.0978, 0.8058, 1.7350]])
x[:, 1]
# => tensor([0.7640, 0.4298, 0.3547, 0.5184, 0.4408])
#Numpy 桥
a = torch.ones(5)
b = a.numpy()
# => array([1., 1., 1., 1., 1.], dtype=float32)
a.add_(1)
b

#将numpy 的array 转换为torch的tensor
import numpy as np
a = np.ones(5)
# => array([1., 1., 1., 1., 1.])
b = torch.from_numpy(a)
# => tensor([1., 1., 1., 1., 1.], dtype=torch.float64)
np.add(a, 1, out=a)
b

if torch.cuda.is_available():
x = x.cuda()
y = y.cuda()
x + y

from torch.autograd import Variable
x = Variable(torch.ones(2, 2), requires_grad = True)
# =>
# tensor([[1., 1.],
#         [1., 1.]], requires_grad=True)
#+end_src

一些简单的例子

#+begin_src python
import torch
N,D_in,H,D_out = 64, 1000, 100, 10

#随机创建一些训练数据
x = torch.randn(N, D_in)
x.shape
y = torch.randn(N, D_out)
y.shape

w1 = torch.randn(D_in, H)
w2 = torch.randn(H, D_out)

learning_rate = 1e-6
for it in range(500):
    #forward pass
    h = x.mm(w1) #N*H
    h_relu = h.clamp(min=0) #N*H
    y_pred = h_relu.mm(w2)

    #compute loss
    loss = (y_pred - y).pow(2).sum().item()
    print(it, loss)

    #backward pass
    #compute the gradient
    grad_y_pred = 2 * (y_pred - y)
    grad_w2 = h_relu.t().mm(grad_y_pred)
    grad_h_relu = grad_y_pred.mm(w2.t())
    grad_h = grad_h_relu.clone()
    grad_h[h<0] = 0
    grad_w1 = x.t().mm(grad_h)

    #update weights of w1 and w2
    w1 -= learning_rate * grad_w1
    w2 -= learning_rate * grad_w2

import torch
N,D_in,H,D_out = 64, 1000, 100, 10

#随机创建一些训练数据
x = torch.randn(N, D_in)
x.shape
y = torch.randn(N, D_out)
y.shape

w1 = torch.randn(D_in, H,requires_grad=True)
w2 = torch.randn(H, D_out, requires_grad=True)

learning_rate = 1e-6
for it in range(500):
    #forward pass
    y_pred = x.mm(w1).clamp(min=0).mm(w2)
    #compute loss
    loss = (y_pred - y).pow(2).sum()
    print(it, loss.item())
    #backward pass
    loss.backward()
    #update weights of w1 and w2
    with torch.no_grad():
        w1 -= learning_rate * w1.grad
        w2 -= learning_rate * w2.grad
        w1.grad.zero_()
        w2.grad.zero_()
#+end_src

*** Tensors
tensors 张量是一种特殊的数据结构，它和数组还有矩阵十分相似。在pytorch 中，我们使用tensors 来给模型的输入输出以及参数进行编码。tensors 除了张量可以在gpu 或其他专用硬件上运行来加速计算之外，其他用法类似于numpy 中的ndarrays.

**** 初始化tensors
创建tensor 有多种方法，可以直接从数据创建。

#+begin_src python
import torch
import numpy as np
data = [[1,2],[3,4]]
x_data = torch.tensor(data)
# =>
# tensor([[1, 2],
#         [3, 4]])
#+end_src

可以从numpy 创建

#+begin_src python
np_array = np.array(data)
# =>
# array([[1, 2],
#        [3, 4]])
x_np = torch.from_numpy(np_array)
# =>
# tensor([[1, 2],
#         [3, 4]])
#+end_src

也可以从其他tensor 创建
新的tensor 保留了参数tensor 的一些属性，除非显式覆盖

#+begin_src python
x_ones = torch.ones_like(x_data)
# =>
# tensor([[1, 1],
#         [1, 1]])
x_rand = torch.rand_like(x_data, dtype = torch.float)
# =>
# tensor([[0.0472, 0.1287],
#         [0.5208, 0.5567]])
#+end_src

也可以从常数或者随机数创建

shape 是关于tensor 维度的一元数组，在下面的函数中，它决定了输出tensor 的维数。

#+begin_src python
shape = (2, 3, )
# => (2, 3)
rand_tensor = torch.rand(shape)
# =>
# tensor([[0.2239, 0.6943, 0.0765],
#         [0.0583, 0.8416, 0.1918]])
ones_tensor = torch.ones(shape)
# =>
# tensor([[1., 1., 1.],
#         [1., 1., 1.]])
zeros_tensor = torch.zeros(shape)
# =>
# tensor([[0., 0., 0.],
#         [0., 0., 0.]])
#+end_src

**** tensor 的属性
Tensor 的属性包括形状，数据类型以及存储的设备。

#+begin_src python
tensor = torch.rand(3,4)
# =>
# tensor([[0.7840, 0.9059, 0.1290, 0.0850],
#         [0.4428, 0.5879, 0.8544, 0.5955],
#         [0.5341, 0.3769, 0.6598, 0.2467]])
print(f"shape of tensor: {tensor.shape}")
# => shape of tensor: torch.Size([3, 4])
print(f"dataType of tensor: {tensor.dtype}")
# => dataType of tensor: torch.float32
print(f"device tensor is stored on: {tensor.device}")
# => device tensor is stored on: cpu
#+end_src

**** tensor 的操作
tensor 有超过100个操作，包括transposing, indexing, slicing, mathematical operations, linear algebra, random sampling.

它们都可以在GPU 上运行。

- 标准的numpy 类索引和切片

#+begin_src python :results output
tensor = torch.ones(4,4)
# =>
# tensor([[1., 1., 1., 1.],
#         [1., 1., 1., 1.],
#         [1., 1., 1., 1.],
#         [1., 1., 1., 1.]])
tensor[:,1] = 0
# => tensor([0., 0., 0., 0.])
print(tensor)
# =>
# tensor([[1., 0., 1., 1.],
#         [1., 0., 1., 1.],
#         [1., 0., 1., 1.],
#         [1., 0., 1., 1.]])
#+end_src

- 合并tensors

可以使用torch.cat 来沿着特定维数连接一系列张量。torch.stack 另一个加入op 的张量与torch.cat 有细微不同。

#+begin_src python :results output
t1 = torch.cat([tensor, tensor, tensor], dim =1)
# =>
# tensor([[1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.],
#         [1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.],
#         [1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.],
#         [1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.]])
t1 = torch.stack([tensor, tensor], dim=1)
# =>
# tensor([[[1., 1., 1., 1.],
#          [1., 1., 1., 1.]],
#
#         [[1., 1., 1., 1.],
#          [1., 1., 1., 1.]],
#
#         [[1., 1., 1., 1.],
#          [1., 1., 1., 1.]],
#
#         [[1., 1., 1., 1.],
#          [1., 1., 1., 1.]]])
#+end_src

- 增加tensors

#+begin_src python :results output
tensor.mul(tensor)
# =>
#
# tensor([[1., 1., 1., 1.],
#         [1., 1., 1., 1.],
#         [1., 1., 1., 1.],
#         [1., 1., 1., 1.]])
tensor * tensor
# =>
#
# tensor([[1., 1., 1., 1.],
#         [1., 1., 1., 1.],
#         [1., 1., 1., 1.],
#         [1., 1., 1., 1.]])
print(f"tensor.mul(tensor) \n {tensor.mul(tensor)} \n")
# =>
# tensor.mul(tensor)
#  tensor([[1., 1., 1., 1.],
#         [1., 1., 1., 1.],
#         [1., 1., 1., 1.],
#         [1., 1., 1., 1.]])
#+end_src

#+begin_src python :results output
tensor.matmul(tensor.T)
tensor @ tensor
# =>
#
# tensor([[4., 4., 4., 4.],
#         [4., 4., 4., 4.],
#         [4., 4., 4., 4.],
#         [4., 4., 4., 4.]])
#+end_src

- 原地操作

带有后缀_的操作表示的是原地操作，例如：x.copy_(y),x.t_() 将改变x.

#+begin_src python :results output
tensor.add_(5)
# =>
#
# tensor([[11., 11., 11., 11.],
#         [11., 11., 11., 11.],
#         [11., 11., 11., 11.],
#         [11., 11., 11., 11.]])
#+end_src

- tensor 转换为numpt

#+begin_src python :results output
t = torch.ones(5)
print(f"t:{t}")
n = t.numpy()
print(f"n:{n}")
#+end_src

- numpy 数组转换为tensor

#+begin_src python :results output
n = np.ones(5)
t = torch.from_numpy(n)
np.add(n, 1, out=n)
#+end_src

**** autograd
pytorch 使用了一种自动微分的技术。也就是说，它会有一个记录我们所有执行操作的记录器，之后再回放记录来计算我们的梯度，这一技术在构建神经网络时尤其有效，因为我们可以通过计算前路参数的微分来节省时间。

#+begin_src python :results output
from torch.autograd import Variable
x = Variable(train_x)
y = Variable(train_y, requires_grad = False)
#+end_src

**** data preparation
scalar (0 - D tensors)

#+begin_src python :results output
x = torch.randn(10)
x.size()
# => torch.Size([10])
#+end_src

Vector (1 - D tensors)

#+begin_src python :results output
temp = torch.FloatTensor([23,24,23,1,23,23])
temp.size()
# => torch.Size([6])
#+end_src

Matrix (2 - D tensors)

#+begin_src python :results output
boston_tenor = torch.from_numpy(boson.data)
boson_tenor.size()
#+end_src

3 - D tensors

#+begin_src python :results output
from PIL import Image
panda = np.array(Image.open("panda.jpg").resize(224,224))
panda_tenor = torch.from_numpy(panda)
panda_tenor.size()
#+end_src

slicing Tensors

sales[:slice_index]

#+begin_src python :results output
sales = torch.FloatTensor([1000, 322, 33,233,4])
sales[:3]
# => tensor([1000.,  322.,   33.])
sales[:-3]
# => tensor([1000.,  322.])
#+end_src

**** autograd
深度学习框架通过自动计算导数，即自动求导，来加快这块工作。

#+begin_src python :results output
import torch
x = torch.arange(4.0) #input 必须是float
# => tensor([0., 1., 2., 3.])
x.requires_grad_(True)
# => tensor([0., 1., 2., 3.], requires_grad=True)
x.grad
# =>
y = 2*torch.dot(x,x)
# => tensor(28., grad_fn=<MulBackward0>)
y.backward()
x.grad
# => tensor([ 0.,  4.,  8., 12.])
x.grad == 4*x
# => tensor([True, True, True, True])
x.grad.zero_()#清空数据
# => tensor([0., 0., 0., 0.])
y = x.sum()
# => tensor(6., grad_fn=<SumBackward0>)
y.backward()
x.grad
# => tensor([1., 1., 1., 1.])
#+end_src

**** models
torchvision 里有所有torch 可用的models.

#+begin_src python :results output
from torchvision import models
dir(models)
#+end_src

**** 查找特定函数和类的用法

#+begin_src python
import torch
help(torch.ones)
#+end_src

** python 习题
https://leetcode-cn.com/circle/discuss/wOEKvB/

这个习题答案是。
#+begin_src python :results output
import numpy as np
m = 50
n = 10
for i in range(int(np.floor(m/10)+1)):
    for j in range(int(np.floor(((m-10*i)+1)/5))):
        for k in range(int(np.floor(((m-10*i-5*j)+1)/2))):
            l = m-10*i-5*j-2*k
            if i+j+k+l == n and l>
=0:
                print(i,j,k,l)
#+end_src

** 数据结构
*** 线性表

线性表是最常用且最简单的一种数据结构，它是 $n$ 个数据元素的有限序列。

实现线性表的方式一般有两种，一种是使用数组存储线性表的元素，即用一组连续的存储单元依次存储线性表的数据元素。另一种是使用链表存储线性表的元素，即用一组任意的存储单元存储线性表的数据元素（存储单元可以是连续的，也可以是不连续的）。

*** 链表

链表的结构：链表像锁链一样，由一节节节点连在一起，组成一条数据链。
链表的节点的结构如下： data next data为自定义的数据，next为下一个节点的地址。 链表的结构为，head保存首位节点的地址：

*** hash表

数组能够通过下标O(1) 访问，但是删除一个中间元素却要移动其他元素，时间O(n).

能不能给每个元素一种逻辑下标，然后直接找到它呢，hash 表就是这种实现？它通过一个hash 函数来计算一个元素应该放在数组哪个位置，当然对于一个特定的元素，哈希函数每次计算的下标必须要一样才可以，而且范围不能超过给定的数组长度。

假设有一个数组T, 包含 $M=13$ 个元素，可以定义个简单的hash 函数。

#+begin_src python :results output
h(key) = key % M
#+end_src

假设需要插入765, 431, 96, 142, 579, 226, 903, 388 元素，可以先计算下它们应用哈希函数的结果。

#+begin_src python :results output
M = 13
h(765) = 765 % M = 11
h(431) = 431 % M = 2
h(96) = 96 % M = 5
h(142) = 142 % M = 12
h(579) = 579 % M = 7
h(226) = 226 % M = 5
h(903) = 903 % M = 6
h(388) = 388 % M = 11
#+end_src


**** hash 冲突

如果有2个值均是一样，那么就有了哈希冲突（collision），如果有了冲突，这么解决呢？可以用一种链接法。

链接法的思想就是如果有了冲突，可以让数组中对应的槽变成一个链式结构。

https://python-data-structures-and-algorithms.readthedocs.io/zh/latest/07_%E5%93%88%E5%B8%8C%E8%A1%A8/hashtable/

具体可看上面那个链接。

还有一种开放寻址法，基本思想就是当一个槽被占用的时候，采用一种方式来寻找下一个可用的槽。

** 股市量化分析

如何知道近期成交量波动较大的股票？

#+begin_src python :results output
import tushare as ts
import pandas as pd
pro = ts.pro_api("f93f38014c933f1a70e35512fa876e7a7c4e6cdba01665b52f9b3531")
data = pro.query('stock_basic', exchange='', list_status='L', fields='ts_code,symbol,name,area,industry,list_date')

df = pro.trade_cal(exchange='SSE', is_open='1',
                            start_date='20210101',
                            end_date='20210407',
                            fields='cal_date')

def get_daily(ts_code='', trade_date='', start_date='', end_date=''):
    for _ in range(3):
      try:
          if trade_date:
              df = pro.daily(ts_code=ts_code, trade_date=trade_date)
          else:
              df = pro.daily(ts_code=ts_code, start_date=start_date, end_date=end_date)
      except:
            time.sleep(1)
      else:
          return df

l = pd.DataFrame(data=None)
for date in df['cal_date'].values:
     l = pd.concat([l,get_daily(trade_date = date)])

##最近一天的成交量超过5天成交量的均值
#vol_lastday = l[l.trade_date == "20210406"][["ts_code","vol"]]
mean_vol_last5days = l[l.trade_date >= "20210331"].groupby("ts_code").agg(
  mean_last5vol = pd.NamedAgg(column="vol", aggfunc = 'mean'))

mean_vol_last15days = l[l.trade_date >= "20210315"].groupby("ts_code").agg(
  mean_last15vol = pd.NamedAgg(column="vol", aggfunc = 'mean'))

from dplython import (DplyFrame, X, diamonds, select, sift, sample_n,
                        sample_frac, head, arrange, mutate, group_by, summarize, DelayFunction)

vol_data = pd.merge(mean_vol_last5days, mean_vol_last15days, on = "ts_code",how = "inner")

vol_data = pd.merge(vol_data, data[["ts_code","name"]], on = "ts_code",how = "inner")

vol_data.head()

result = vol_data.assign(diff = vol_data.mean_last5vol - vol_data.mean_last15vol).sort_values(by = "diff", ascending =False)

result.to_csv("history_A_stock_k_data.csv",encoding="utf_8_sig")

##历史最高值
stock_price_high = l.groupby("ts_code").agg(
  max_high = pd.NamedAgg(column='high', aggfunc = 'max')
  #min_low = pd.NamedAgg(column='low', aggfunc = 'min'),
  )
##最近5天股价均值
stock_price_last5 = l[l.trade_date >= '20210324'].groupby("ts_code").agg(
  mean_colse = pd.NamedAgg(column='close', aggfunc = 'mean'),
)

price_data = pd.merge(stock_price_high, stock_price_last5, on="ts_code",how = "inner")

price_data = price_data.assign(decrease_ratio = (price_data.mean_colse-price_data.max_high)/price_data.max_high)

price_data = pd.merge(price_data, data[["ts_code","name"]], on = "ts_code",how = "inner")

price_data = pd.merge(price_data,l,on = "ts_code", how = "inner")

amount_max = price_data[price_data.trade_date > "20210324"].groupby("ts_code").agg(max_amount = pd.NamedAgg(column='vol', aggfunc = 'max'))
result = pd.merge(price_data[["ts_code","decrease_ratio","name","trade_date","vol"]].rename({"vol":"amount"},axis = 'columns'),amount_max.rename({'max_amount':"amount"},axis = 'columns'),on = ["ts_code","amount"],how = "inner").sort_values(by = ["decrease_ratio", "amount"])

result.head()

result[result.amount > 4000000].sort_values(by = "amount", ascending=False)

result.to_csv("D:\\history_A_stock_k_data.csv",encoding="utf_8_sig")


from dplython import (DplyFrame, X, diamonds, select, sift,
  sample_n, sample_frac, head, arrange, mutate, group_by,
  summarize, DelayFunction)


price_data >> mask(price_data.name == "金徽酒")
filter(lambda x:"酒" in price_data.name[x],range(len(price_data.name)))

mao_20 = ["长江电力", "贵州茅台", "五粮液", "中国中免", "比亚迪", "恒瑞医药", "牧原股份", "爱尔眼科", "立讯精密", "药明康德", "万华化学", "三一重工",
"迈瑞医疗","长春高新","宁德时代","美的集团","中国平安","海天味业", "伊利股份"]

longtou = ["恒立液压", "顺丰控股", "立昂微", "隆基股份"]

price_data[price_data.name.str.contains("普路通")].sort_values(by = ["decrease_ratio", "max_high"])
#+end_src
 
