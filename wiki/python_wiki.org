# -*- org-confirm-babel-evaluate: nil; -*-
#+PROPERTY: header-args :eval never-export

* Python_wiki                                                           :toc:
  - [[#常见问题][常见问题]]
    - [[#语法错误][语法错误]]
    - [[#数据类型][数据类型]]
      - [[#基本数据类型][基本数据类型]]
      - [[#容器数据类型][容器数据类型]]
  - [[#python-版本][python 版本]]
  - [[#工作目录][工作目录]]
  - [[#pip-install][pip install]]
  - [[#python-编辑语法][python 编辑语法]]
    - [[#][\]]
  - [[#常见函数][常见函数]]
    - [[#def][def]]
      - [[#递归函数][递归函数]]
    - [[#空函数][空函数]]
    - [[#局部变量][局部变量]]
    - [[#global-语句][global 语句]]
    - [[#关键字参数][关键字参数]]
    - [[#可变参数][可变参数]]
    - [[#return][return]]
    - [[#命名空间和作用域][命名空间和作用域]]
    - [[#-1][*/**]]
      - [[#异常处理][异常处理]]
    - [[#isinstance][isinstance]]
    - [[#super][super]]
    - [[#魔法函数][魔法函数]]
    - [[#__slots__][__slots__]]
    - [[#int][int]]
    - [[#set][set]]
    - [[#help][help]]
    - [[#list][list]]
      - [[#count][count]]
      - [[#deque][deque]]
      - [[#嵌套列表解析][嵌套列表解析]]
    - [[#print][print]]
    - [[#tolist][tolist]]
    - [[#title][title]]
    - [[#anyall][Any/All]]
    - [[#range][range]]
    - [[#for-循环][for 循环]]
    - [[#len][len]]
    - [[#reverse][reverse]]
    - [[#sort][sort]]
    - [[#sorted][sorted]]
    - [[#append][append]]
    - [[#clear][clear]]
    - [[#insert][insert]]
    - [[#item][item]]
    - [[#get][get]]
    - [[#zip][zip]]
    - [[#del][del]]
    - [[#pop][pop]]
    - [[#remove][remove]]
    - [[#timesleep][time.sleep]]
    - [[#列表解析][列表解析]]
    - [[#if][if]]
    - [[#boolen][boolen]]
    - [[#检查多个条件][检查多个条件]]
    - [[#in][in]]
    - [[#not-in][not in]]
    - [[#else][else]]
    - [[#elif][elif]]
    - [[#forif][for,if]]
    - [[#continue][continue]]
    - [[#break][break]]
    - [[#引号][引号]]
      - [[#单引号双引号][单引号、双引号]]
      - [[#三引号][三引号]]
    - [[#enumerate][enumerate]]
    - [[#map][map]]
    - [[#filter][filter]]
    - [[#reduce][reduce]]
    - [[#format][format]]
    - [[#f][f'']]
    - [[#while][while]]
    - [[#for][for]]
    - [[#_][_]]
    - [[#dir][dir]]
    - [[#docall][do.call]]
    - [[#rownames_to_columncolumn_to_rownames][rownames_to_column/column_to_rownames]]
    - [[#break-语句][break 语句]]
    - [[#基本数学运算][基本数学运算]]
      - [[#sqrt][sqrt]]
    - [[#列表推导][列表推导]]
      - [[#笛卡尔积][笛卡尔积]]
  - [[#pycharm-使用技巧][pycharm 使用技巧]]
  - [[#numpy][numpy]]
    - [[#查看版本][查看版本]]
    - [[#info][info]]
    - [[#npnonzero][np.nonzero]]
    - [[#head][head]]
    - [[#keys][keys]]
    - [[#matrix][matrix]]
      - [[#nptranspose][np.transpose]]
      - [[#npmatmul][np.matmul]]
      - [[#type][type]]
    - [[#unique][unique]]
    - [[#where][where]]
    - [[#argmax][argmax]]
    - [[#stackunstack][stack/unstack]]
    - [[#给定-dataframe将负值代替为同组的平均值][给定 dataframe,将负值代替为同组的平均值]]
    - [[#创建-series将-2015-所有工作日作为随机值的索引][创建 series,将 2015 所有工作日作为随机值的索引]]
    - [[#melt][melt]]
    - [[#create-ndarray][create ndarray]]
      - [[#astype][astype]]
      - [[#列表属性][列表属性]]
      - [[#npzerosnpempty][np.zeros/np.empty]]
      - [[#nparange][np.arange]]
      - [[#nprandom][np.random]]
      - [[#nplinspace][np.linspace]]
    - [[#数据维度][数据维度]]
    - [[#data-type][data type]]
      - [[#str][str]]
          - [[#find][find]]
          - [[#index][index]]
          - [[#count-1][count]]
          - [[#replace][replace]]
          - [[#split][split]]
          - [[#strip][strip]]
          - [[#lsstrip][lsstrip]]
          - [[#rsstrip][rsstrip]]
          - [[#join][join]]
      - [[#int-1][int]]
      - [[#float][float]]
    - [[#生成数据][生成数据]]
    - [[#npdot][np.dot]]
    - [[#linalgeig][linalg.eig]]
    - [[#npc_][np.c_]]
    - [[#npr_][np.r_]]
    - [[#单位矩阵对角矩阵三角矩阵][单位矩阵、对角矩阵、三角矩阵]]
    - [[#特征值问题解][特征值问题解]]
    - [[#svd-分解][svd 分解]]
    - [[#cholesky-分解][cholesky 分解]]
    - [[#lu-分解][LU 分解]]
  - [[#pandas][pandas]]
    - [[#查看一列的基本信息][查看一列的基本信息]]
    - [[#选择一列][选择一列]]
    - [[#选择一列的前几行数据][选择一列的前几行数据]]
    - [[#选择多列][选择多列]]
    - [[#filter-1][filter]]
    - [[#slice--select][slice & select]]
    - [[#select-a][select(-A)]]
    - [[#rename][rename]]
    - [[#case_when][case_when]]
    - [[#read_csv][read_csv]]
    - [[#to_csv][to_csv]]
    - [[#read_clipboard][read_clipboard]]
    - [[#info-1][info]]
    - [[#describe][describe]]
    - [[#t][T]]
    - [[#columns][columns]]
      - [[#列名][列名]]
    - [[#series][Series]]
    - [[#dict][dict]]
      - [[#items][items]]
    - [[#isnullnotnull][isnull/notnull]]
      - [[#isnullany][isnull().any()]]
      - [[#isnullall][isnull().all()]]
    - [[#isna][isna]]
    - [[#insert-na][insert na]]
    - [[#scalar][scalar]]
    - [[#ndarray][ndarray]]
    - [[#dataframe][DataFrame]]
      - [[#create-dataframe][create dataframe]]
      - [[#create-a-dataframe-from-lists][create a dataframe from lists]]
      - [[#create-a-dataframe-from-dict-of-ndarrayslists][create a dataframe from dict of ndarrays/lists]]
      -  [[#create-a-dataframe-from-list-of-dicts][create a dataframe from list of dicts]]
      - [[#create-a-dataframe-from-dict-of-series][create a dataframe from dict of series]]
      - [[#column-addition][column addition]]
      - [[#删除某一列][删除某一列]]
      - [[#loc][loc]]
      - [[#iloc][iloc]]
      - [[#at][at]]
      - [[#slice-rows][slice rows]]
      - [[#addition-of-rows][addition of rows]]
      - [[#deletion-of-rows][deletion of rows]]
      - [[#drop][drop]]
      - [[#drop_duplicates][drop_duplicates]]
      - [[#sub][sub]]
      - [[#idxmin][idxmin]]
    - [[#function-application][function application]]
      - [[#table-wise-function-application][table-wise function application]]
      - [[#rowcolumn-wise-function-application][row/column wise function application]]
      - [[#element-wise-function-application][element wise function application]]
    - [[#docstrings][DocStrings]]
    - [[#indexvalue][index/value]]
    - [[#value][value]]
    - [[#ilocloc][iloc,loc]]
      - [[#regex][regex]]
    - [[#arrange][arrange]]
    - [[#assign][assign]]
    - [[#group_by][group_by]]
    - [[#select][select]]
    - [[#dtypes][dtypes]]
    - [[#agg][agg]]
    - [[#transform][transform]]
    - [[#join-1][join]]
    - [[#date][date]]
    - [[#date_range][date_range]]
    - [[#string][string]]
      - [[#strreplace][str.replace]]
      - [[#strlowerstrupper][str.lower/str.upper]]
      - [[#strlen][str.len]]
      - [[#strcat][str.cat]]
      - [[#strcontains][str.contains]]
      - [[#strrepeat][str.repeat]]
      - [[#strcount][str.count]]
      - [[#startswith][startswith]]
      - [[#endswith][endswith]]
      - [[#strfind][str.find]]
      - [[#strfindall][str.findall]]
      - [[#strswapcase][str.swapcase]]
      - [[#strislower][str.islower]]
      - [[#strisupper][str.isupper]]
      - [[#strisnumeric][str.isnumeric]]
      - [[#capitalize][capitalize]]
      - [[#split-1][split]]
      - [[#find-1][find]]
      - [[#replace-1][replace]]
    - [[#apply][apply]]
    - [[#统计函数][统计函数]]
      - [[#方差][方差]]
  - [[#generator][generator]]
  - [[#装饰器][装饰器]]
  - [[#pivot_table][pivot_table]]
  - [[#修改列表元素][修改列表元素]]
  - [[#转换][转换]]
  - [[#列表中添加元素][列表中添加元素]]
  - [[#列表删除元素][列表删除元素]]
  - [[#根据值删除元素][根据值删除元素]]
  - [[#组织列表][组织列表]]
    - [[#sort-1][sort]]
    - [[#reverse-1][reverse]]
    - [[#len-1][len]]
    - [[#索引][索引]]
  - [[#循环][循环]]
    - [[#遍历整个列表][遍历整个列表]]
  - [[#创建数字列表][创建数字列表]]
    - [[#使用函数-range][使用函数 range()]]
    - [[#使用-range-创建数字列表][使用 range() 创建数字列表]]
  - [[#字典][字典]]
    - [[#添加键值对][添加键－值对]]
    - [[#创建空字典][创建空字典]]
    - [[#修改字典中的值][修改字典中的值]]
    - [[#删除键-值对][删除键-值对]]
    - [[#遍历字典][遍历字典]]
    - [[#遍历字典中的所有键][遍历字典中的所有键]]
    - [[#按顺序遍历字典中的所有键][按顺序遍历字典中的所有键]]
    - [[#遍历字典中的所有值][遍历字典中的所有值]]
    - [[#嵌套][嵌套]]
    - [[#在字典中存储列表][在字典中存储列表]]
    - [[#字典中还有字典][字典中还有字典]]
    - [[#字典推导][字典推导]]
  - [[#正则表达式][正则表达式]]
    - [[#rematch][re.match]]
    - [[#匹配任何单个字符][匹配任何单个字符]]
      - [[#可以匹配任何字符][.可以匹配任何字符]]
  - [[#用户输入和-while-循环][用户输入和 while 循环]]
    - [[#函数-input][函数 input]]
    - [[#int-获取数值输入][int() 获取数值输入]]
    - [[#-2][%]]
    - [[#while-1][while]]
    - [[#def-1][def]]
      - [[#向函数传递信息][向函数传递信息]]
      - [[#传递列表][传递列表]]
      - [[#传递任意数量的实参][传递任意数量的实参]]
      - [[#可更改mutable与不可更改immutable对象][可更改（mutable）与不可更改（immutable）对象]]
    - [[#导入整个模块][导入整个模块]]
    - [[#导入特定的函数][导入特定的函数]]
    - [[#使用-as-给模块指定别名][使用 as 给模块指定别名]]
    - [[#导入模块中的所有函数][导入模块中的所有函数]]
  - [[#lambda][lambda]]
  - [[#class][class]]
    - [[#字符串][字符串]]
  - [[#向量][向量]]
    - [[#将序列分解为单独变量][将序列分解为单独变量]]
    - [[#从任意长度的可迭代对象中分解元素][从任意长度的可迭代对象中分解元素]]
    - [[#找到最大或最小的-n-个元素][找到最大或最小的 N 个元素]]
    - [[#set-1][set]]
    - [[#lambda-1][lambda]]
    - [[#全为-01-的数组][全为 0/1 的数组]]
  - [[#元组][元组]]
  - [[#列表list][列表（list）]]
  - [[#列表长度][列表长度]]
    - [[#笛卡尔积-1][笛卡尔积]]
  - [[#切片操作][切片操作]]
  - [[#推导式][推导式]]
    - [[#字典-1][字典]]
    - [[#集合][集合]]
  - [[#-3][*]]
    - [[#建立由列表组成的列表][建立由列表组成的列表]]
  - [[#聚合][聚合]]
  - [[#外积][外积]]
  - [[#广播][广播]]
  - [[#统计记录个数][统计记录个数]]
  - [[#value_counts][value_counts]]
  - [[#nlargest][nlargest]]
  - [[#处理缺失值][处理缺失值]]
    - [[#isnull][isnull]]
    - [[#fillna][fillna]]
    - [[#dropna][dropna]]
  - [[#合并数据集][合并数据集]]
    - [[#concat-与-append-操作][concat 与 append 操作]]
    - [[#pdconcat][pd.concat]]
    - [[#伪随机数][伪随机数]]
  - [[#unionintersectiondifference][union/intersection/difference]]
  - [[#eval][eval]]
  - [[#assert][assert]]
  - [[#统计][统计]]
    - [[#最小值和最大值][最小值和最大值]]
    - [[#数组值求和累积乘积差分][数组值求和\累积\乘积\差分]]
    - [[#kronecker-积][kronecker 积]]
    - [[#舍入运算][舍入运算]]
    - [[#画图][画图]]
    - [[#线性模型][线性模型]]
    - [[#lasso][lasso]]
  - [[#数据清理][数据清理]]
    - [[#数字型变量][数字型变量]]
    - [[#字符串和文本][字符串和文本]]
      - [[#使用多个界定符分割字符串][使用多个界定符分割字符串]]
      - [[#字符串开头或结尾匹配][字符串开头或结尾匹配]]
      - [[#用-shell-通配符匹配字符串][用 shell 通配符匹配字符串]]
      - [[#字符串搜索和替换][字符串搜索和替换]]
  - [[#类][类]]
  - [[#面向对象技术简介][面向对象技术简介]]
    - [[#继承][继承]]
  - [[#转义][转义]]
  - [[#packages][Packages]]
    - [[#seaborn][seaborn]]
      - [[#get_dataset_names][get_dataset_names()]]
      - [[#load_dataset][load_dataset]]
    - [[#sklearn][sklearn]]
      - [[#minmaxscaler][MinMaxScaler]]
    - [[#dplython][dplython]]
      - [[#select-1][select]]
      - [[#filter-2][filter]]
      - [[#sample][sample]]
      - [[#arrange-1][arrange]]
      - [[#mutate][mutate]]
      - [[#distinct][distinct]]
      - [[#group_by-1][group_by]]
      - [[#t-1][T]]
    - [[#reprex][reprex]]
    - [[#pipe][pipe]]
    - [[#pytorch][pytorch]]
  - [[#python-习题][python 习题]]
  - [[#数据结构][数据结构]]
    - [[#线性表][线性表]]
    - [[#链表][链表]]
    - [[#hash表][hash表]]
      - [[#hash-冲突][hash 冲突]]

** 常见问题
*** 语法错误

#+begin_quote
SyntaxError: invalid syntax
#+end_quote

语法错误又称解析错误，简单来说是基本语法结构写错了，如：多任务写成一行、for 循环没加‘:’等。上面示例可以看到，针对语法错误，python 解析器会输出错误的那一行，并且在最先找到的错误的位置标记了一个箭头。

*** 数据类型
**** 基本数据类型
整数、浮点数、布尔

可以通过 dir() 查看对象的可用的属性，help 可以看到方法。
#+begin_src python
dir(int)
#+end_src

前面的__and__是可用的方法，后面的 bit_length 是可用属性。

**** 容器数据类型
字符、元组、列表、字典、集合

** python 版本

#+begin_src python
import sys
sys.version_info
sys.version
#+end_src

** 工作目录
类似于 R 的 getwd(),setwd().
#+begin_src python
##引入模块，获得工作目录
import os
os.getcwd() #获得当前工作目录
os.chcwd('D:/work') #改变工作目录
os.mkdir('work') #建立新目录
os.rmdir('work') #删除目录
os.rename('fff.txt','fool.txt') #重命名
os.remove('h.txt') #删除文件
#+end_src

** pip install
谁用谁知道。
#+begin_src python
def test(x, y = 10):
    x += 100
    print(x, y)
test
# <function __main__.test(x, y=10)>
test.__code__
# <code object test at 0x11d9b15d0, file "<ipython-input-43-3d74f8241943>", line 1>
test.__code__.co_varnames # 参数及变量量名列列表。
test.__code__.co_consts # 指令常量
test.__defaults__ # 参数默认值
# (10,)
test(1)
# 101 10
#+end_src

** python 编辑语法
*** \
如果代码太长写成一行不便于阅读 可以使用\对代码进行折行.
#+begin_src python
year = int(input('请输入年份: '))
# 如果代码太长写成一行不便于阅读 可以使用\对代码进行折行
is_leap = year % 4 == 0 and year % 100 != 0 or \
          year % 400 == 0
print(is_leap)
#+end_src

** 常见函数
*** def
自定义函数可以通过关键字 def 来定义。在定义函数时给定的名称称作“形参（parameters）”， 在调用函数时你所提供函数的值称作“实参”（arguments）。
#+begin_src python
def print_max(a, b):
    if a > b:
    print(a, 'is maximum')
elif a == b:
    print(a, 'is equal to', b)
else:
    print(b, 'is maximum')

print_max(3,4)
#+end_src

*args 和 **kwargs 主要用于函数定义，你可以将不定数量的参数传递给一个函数，这里的不定的意思是：预先并不知道函数使用者会传递多少个参数给你，所以在这个场景下使用这两个关键字。*

*args 是用来发送一个非键值对的可变数量的参数列表给一个函数。

#+begin_src python :results output
def demo(args_f, *args_v):
    print(args_f)
    for x in args_v:
        print(x)

demo('a','b','c')
#+end_src

**kwargs 允许你将不定长度的键值对，作为参数传递给一个函数。如果你想要在一个函数里处理带名字的参数，你应该使用 **kwargs.

#+begin_src python :results output
def demo(**kwargs):
    for k,v in kwargs.items():
        print(k,v)

demo(name='njcx')
#+end_src

**** 递归函数
在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。
这个在R 中是无法实现的。
 #+begin_src python
 def fact(n):
     if n == 1:
     return 1
 return n * fact(n-1)
 #+end_src

*** 空函数
如果想定义一个什么事也不做的空函数，可以用 pass 语句：

#+begin_src python
if age >=18:
    pass
#+end_src

pass 可以用来作为占位符，比如现在还没想好怎么写函数的代码，可以先写一个 pass，让代码能运行起来。

*** 局部变量
当在一个函数的定义中声明变量时，它们不会以任何方式与身处函数之外但具有相同名称的 变量产生关系，也就是说，这些变量名只存在于函数这一局部（local），这被称为变量作用域（scope）。

#+begin_src python
x = 50
def func(x):
    print("x is", x)
    x = 2
    print('Changed local x to', x)

func(x)
print("x is still", x)
#+end_src

*** global 语句

#+begin_src python
def say_hello():
    print('hello world')
say_hello()
x = 50
def func():
    global x

    print('x is', x)
    x = 2
    print('Changed global x to', x)

func()
      print('Value of x is', x)
#+end_src

下面 times = 1,就是默认的参数值。
#+begin_src ipython
def say(message, times=1):
          print(message * times)

say('hello')

say('world',5)
    #+end_src

*** 关键字参数

#+begin_src python
def func(a,b=5,c=10):
    print("a is", a, "and b is", b, "and c is", c)

func(3,7)
func(25,c=7)
func(c=50, a=100)
#+end_src

*** 可变参数

有时你可能想定义的函数里面能够有任意数量的变量，也就是参数数量是可变的，这可以通过使用星号来实现。

*** return
return 语句用于从函数中返回，也就是中断函数。命名空间（namespace）

*** 命名空间和作用域

如果想给一个在程序顶层的变量赋值（也就是说不存在于任何作用域中，无论是函数还是类），那么你必须告诉 python 这一变量并非局部，而是全局（global）。因为在不使用 global 语句的情况下，不可能为一个定义于函数之外的变量赋值。

*** */**
为了能让一个函数接受任意数量的位置参数，可以使用一个*参数。例如

#+begin_src python
def avg(first, *rest):
    return (first + sum(rest)) / (1 + len(rest))

# Sample use
avg(1, 2) # 1.5
avg(1, 2, 3, 4) # 2.5
    #+end_src

为了接受任意数量的关键字参数，使用一个以**开头的参数。比如：
#+begin_src python
  def maximun(x, y):
    if x > y:
        return  x
    elif x == y:
        return "The numbers are equal"
    else:
        return y

print(maximun(2, 3))
#+end_src

从上面两个例子可以看出 * 对应的是任意数量的位置参数,而 ** 对应的是任意数量的关键字参数.还有一种情况是只接受关键字参数的函数.将强制关键字参数放到某个 * 参数或者单个 * 后面就能达到这种效果。

#+begin_src python
 def recv(maxsize, *, block):
    'Receives a message'
    pass

recv(1024, True) # TypeError
recv(1024, block=True) # Ok
#+end_src

利用这种技术，我们还能在接受任意多个位置参数的函数中指定关键字参数。比如：

#+begin_src python
import html

def make_element(name, value, **attrs):
    keyvals = [' %s="%s"' % item for item in attrs.items()]
    attr_str = ''.join(keyvals)
    element = '<{name}{attrs}>{value}</{name}>'.format(
                name=name,
                attrs=attr_str,
                value=html.escape(value))
    return element

# Example
# Creates '<item size="large" quantity="6">Albatross</item>'
make_element('item', 'Albatross', size='large', quantity=6)

# Creates '<p>&lt;spam&gt;</p>'
make_element('p', '<spam>')
#+end_src

#+begin_src python
def minimum(*values, clip=None):
   m = min(values)
   if clip is not None:
       m = clip if clip > m else m
   return m

minimum(1, 5, 2, -5, 10) # Returns -5
minimum(1, 5, 2, -5, 10, clip=0) # Returns 0

- 给函数参数增加元信息

写好了一个函数，然后想为这个函数的参数增加一些额外的信息，这样的话其他使用者就能清楚的知道这个函数应该怎么使用。函数注解只存储在函数的 __annotations__ 属性中。

#+begin_src python
def add(x:int, y:int) -> int:
    return x + y

add(1,2)
#> 3

help(add)
#> Help on function add in module __main__:
#>
#> add(x: int, y: int) -> int
#>

add.__annotations__
#> {'x': int, 'y': int, 'return': int}
#+end_src

- 返回多个值的函数

为了能返回多个值,函数直接 return 一个元组即可.
#+begin_src python
def myfun():
    return 1,2,3

a, b, c = myfun()
a
#1
b
#2
c
#3
#+end_src

从本质上看,尽管 myfun() 看上去返回了多个值,实际上是先创建了一个元组然后返回的.

- 定义有默认参数的函数

定义一个有可选参数的函数是非常简单的，直接在函数定义中给参数指定一个默认值，并放到参数列表最后就行了。
#+begin_src python
def spam(a, b = 42):
    print(a, b)

spam(1)
spam(1, 2)

_no_value = object()
def spam(a, b=_no_value):
    if b is _no_value:
        print('No b value supplied')

spam(1)
spam(1, 2)
spam(1,  None)


def spam(a,b=[]):
    print(b)
    return b
x = spam(1)
x.append(99)
spam(1)

- 减少可调用对象的参数个数

如果需要减少某个函数的参数个数，你可以使用 functools.partital().

#+begin_src python
from functools import partial
def spam(a, b, c, d):
    print(a, b, c, d)

s1 = partial(spam, 1)
s1
s1(2, 3, 4)
s2 = partial(spam, d = 42)
s2(1, 2, 3)
s2(4, 5, 5)
s3 = partial(spam, 1, 2, d = 42)
s3(3)
s3(4)
s3(5)
#+end_src

partial 函数允许你给一个或多个参数设置固定的值，减少接下来被调用时的参数个数。

假设要转换大量的二进制字符串，每次都传入 int(x,base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2 传进去：

#+begin_src python :results output
import functools
int2 = functools.partial(int, base=2)
int2('1000000')
#+end_src

需要指出的是这里的 int 是自带函数，而base 是自带参数，只不过partial 确定了参数值。如果没有 partial 函数，那么就需要重新定义int2 函数

#+begin_src python :results output
def int2(x, base=2):
    return int(x, base)
#+end_src

- 带额外状态信息的回调函数

你的代码中需要依赖到回调函数的使用(比如事件处理器、等待后台任务完成后的回调等)， 并且你还需要让回调函数拥有额外的状态值，以便在它的内部使用到。

#+begin_src python
def apply_async(func, args, *, callback):
    result = func(*args)
    callback(result)

def print_result(result):
    print('Got:', result)

def add(x,y):
    return x+y

apply_async(add, (2, 3), callback=print_result)
# Got: 5
#+end_src

- 访问闭包中定义的变量

#+begin_src python
def sample():
    n = 0
    def func():
        print('n=', n)
    def get_n():
        return n
    def set_n(value):
        nonlocal n
        n = value
    func.get_n = get_n
    func.set_n = set_n
    return func

f =sample()
f()
# n= 0
f.set_n(10)
f()
# n= 10
f.get_n()
# 10
#+end_src

为了说明清楚它如何工作的，有两点需要解释一下。首先，nonlocal 声明可以让我们编写函数来修改内部变量的值。其次，函数属性允许我们用一种很简单的方式将访问方法绑定到闭包函数上，这个跟实例方法很像(尽管并没有定义任何类)。


有一个例子可以说明生成器，yield,偏函数的作用！

#+begin_src python :results output
def multiply():
    return (lambda x: i * x for i in range(4))

print([m(100) for m in multiply()])


def multiply():
    for i in range(4):
        yield lambda x: x * i

print([m(100) for m in multiply()])

from functools import partial
from operator import __mul__

def multiply():
    return [partial(__mul__, i) for i in range(4)]

print([m(100) for m in multiply()])
#+end_src

**** 异常处理
到目前为止，在 python 程序中遇到错误，或“异常”，意味着整个程序崩溃。我们不希望这发生在真实世界中，相反希望程序能检测到错误，处理它们，然后继续运行。

#+begin_src python
def spam(divideBy):
    return 42/ divideBy

print(spam(2))
print(spam(0))
#+end_src

当试图一个数除以 0 时，就会发生 ZeroDivisionError. 根据错误信息中给出的行号，我们知道 spam() 中的 return 语句导致了一个错误。

错误可以由 try 和 except 语句处理，那些可能出错的语句被放在 try 子句中。如果错误发生，程序执行就转到接下来的 except 子句开始处。

#+begin_src python
def spam(divideBy):
    try:
        return 42/ divideBy
    except ZeroDivisionError:
        print('Error:Invalid argument.')

print(spam(0))
#+end_src

#+begin_src python
def divide(a,b):
    try:
        return a/b
    except ZeroDivisionError as e:
        raise ValueError("Invalid inputs") from e

divide(1, 0)
# =>
#    ZeroDivisionErrorTraceback (most recent call last)
#    ~/Documents/坚果云/我的坚果云/github/wiki/python_wiki.org in divide(a, b)
#          2 #+PROPERTY: header-args :eval never-export
#    ----> 3
#          4 * Python_wiki                                                           :toc:
#
#    ZeroDivisionError: division by zero
#
#    The above exception was the direct cause of the following exception:
#
#    ValueErrorTraceback (most recent call last)
#    <ipython-input-7-b4d7e8b388b7> in <module>
#    ----> 1 divide(1, 0)
#
#    ~/Documents/坚果云/我的坚果云/github/wiki/python_wiki.org in divide(a, b)
#          3
#          4 * Python_wiki                                                           :toc:
#    ----> 5   - [[#常见问题][常见问题]]
#          6     - [[#语法错误][语法错误]]
#          7     - [[#数据类型][数据类型]]
#
#    ValueError: Invalid inputs
divide(1,1)
# => 1.0
#+end_src

或者

#+begin_src python
try:
    print(spam(2))
    print(spam(0))
except ZeroDivisionError:
    print('Error:Invalid argument.')
#+end_src

在实际工作中，try 一般紧跟抛异常函数 raise。

#+begin_src python
try:
    a = input("输入一个数：")
    if(not a.isdigit()):
        raise ValueError("a 必须是数字")
except ValueError as e:
    print({"引发异常：", repr(e)})
#+end_src

正如之前看到的，raise 不需要带参数。


*** isinstance
isinstance() 布尔函数在判定一个对象是否是另一个给定类的实例时，非常有用。

#+begin_src python :results output
class myclass(object):
    def __init__(self):
        self.foo = 100
myinst = myclass()
isinstance(myinst, myclass)
#+end_src

*** super
super() 函数是用于调用父类（超类）的一个方法。 super() 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没有问题，但是如果使用多继承，会涉及到查找顺序（MRO），重复调用等种种问题。

调用父类同名方法有2种方式：

1.调用未绑定的父类方法

#+begin_src python :results output
class Base(object):
    def greet(self):
        print("hi, i am base")

class A(Base):
    def greet(self):
        Base.greet(self)
        print("hi, i am A")

a = A()
a.greet()
这种方式简单还可以，如果在多重继承中就会有问题。

2.使用super 函数来调用

#+begin_src python :results output
class Base(object):
    def __init__(self):
        print("enter Base")
        print("leave Base")


class A(Base):
    def __init__(self):
        print("enter A")
        Base.__init__(self) #调用父类的构造函数进行初始化
        print("leave A")


class B(Base):
    def __init__(self):
        print("enter B")
        Base.__init__(self) #调用父类的构造函数进行初始化
        print("leave B")

class C(A,B):
    def __init__(self):
        print("enter C")
        A.__init__(self) #调用父类A的构造函数进行初始化
        B.__init__(self) #调用父类B的构造函数进行初始化
        print("leave C")

c=C()


class Base(object):
    def __init__(self):
        print("enter Base")
        print("leave Base")


class A(Base):
    def __init__(self):
        print("enter A")
        super(A,self).__init__()
        print("leave A")


class B(Base):
    def __init__(self):
        print("enter B")
        super(B,self).__init__()
        print("leave B")

class C(A,B):
    def __init__(self):
        print("enter C")
        super(C,self).__init__()
        print("leave C")

c = C()
C.mro()
# => [__repl__.C, __repl__.A, __repl__.Base, __repl__.B, __repl__.Base, object]
#+end_src

类C继承自A,B，而A和B又分别继承类Base，每一个类的构造函数分别被调用了一次。

https://blog.csdn.net/wo198711203217/article/details/84097274
MRO 就是类的方法解析顺序表，其实也就是继承父类方法时的顺序表。

那这个 MRO 列表的顺序是怎么定的呢，它是通过一个 C3 线性化算法来实现的，这里我们就不去深究这个算法了，感兴趣的读者可以自己去了解一下，总的来说，一个类的 MRO 列表就是合并所有父类的 MRO 列表，并遵循以下三条原则：

子类永远在父类前面

如果有多个父类，会根据它们在列表中的顺序被检查

如果对下一个类存在两个合法的选择，选择第一个父类

super() 方法的语法：

#+begin_src python :results output
super(type[, object-or-type])
#+end_src

#+begin_src python :results output
class People:
    def __init__(self, name):
        self.name = name
    def say(self):
        print("我是人，名字为：", self.name)

class Animal:
    def __init__(self, food):
        self.food = food

    def display(self):
        print("我是动物，我吃", self.food)
#这里People, Animal 是父类
class Person(People, Animal):
    def __init__(self, name, food):
        super().__init__(name)
        Animal.__init__(self,food)

per = Person("zhangsan", "熟食")
per.say()
per.display()
#+end_src

#+begin_src python :results output
#!/usr/bin/python
# -*- coding: UTF-8 -*-

class FooParent(object):
    def __init__(self):
        self.parent = 'I\'m the parent.'
        print ('Parent')

    def bar(self,message):
        print ("%s from Parent" % message)

class FooChild(FooParent):
    def __init__(self):
        # super(FooChild,self) 首先找到 FooChild 的父类（就是类 FooParent），然后把类 FooChild 的对象转换为类 FooParent 的对象
        super(FooChild,self).__init__()
        print ('Child')

    def bar(self,message):
        super(FooChild, self).bar(message)
        print ('Child bar fuction')
        print (self.parent)

if __name__ == '__main__':
    fooChild = FooChild()
    fooChild.bar('HelloWorld')
#+end_src

如何理解smo 呢？用一个事例来说明。

#+begin_src python :results output
class Bird:
    def __init__(self):
        self.hungry = True
    def eat(self):
        if self.hungry:
            print('sdd')
        else:
            print("no thx")

class SongBird(Bird):
    def __init__(self):
        super(SongBird,self).__init__()
        self.sound = 'sd'
    def sing(self):
        print(self.song())

sb = SongBird()
sb.sing()
sb.eat()
#+end_src

*** 魔法函数

所谓的魔法函数是python 的一种高级语法，允许你在类中自定义函数（函数名格式一般为 __xx__  ），并绑定到类的特殊方法中，比如在类A 中自定义 __str__()函数，则再调用str(A()) 时，会自动调用__str__()函数，并返回相应的结果。在我们平时的使用中，可能经常使用 __init__()函数（构造函数）和 __del__()函数（）

*** __slots__

限制实例的属性就需要 __slot__()

#+begin_src python :results output
class Student(object):
    __slots__ = ('name', 'age')

s = Student()
s.name = 'Michael'
s.age = 25
s.score = 99

*** int
如果传入base参数，就可以做N进制的转换：
#+begin_src python :results output
int('1234', base=8)
#+end_src


*** set
集合，是 python 一种数据类型，可以去重。
#+begin_src python
basket = ['apple', 'orange', 'apple']

set(basket)
#> {'apple', 'orange'}
#+end_src

python 去重一般通过set,然后再转成对应的数据类型。

#+begin_src python :results output
list1 = [11,12,13,12,15]
[x for x in set(list1)]
#+end_src

*** help

#+begin_src python
help() #可以获取帮助文档
#比如:
help(re.match)
#+end_src

*** list
python 中的 list 转变为 array.
#+begin_src python
items = [1, 2, 3, 4, 5]
type(items)
l = np.array(items)
l
type(l)
#+end_src

列表还支持合并操作：

#+begin_src python :results output
square = [1, 4, 98]
square + [36, 90]
# => [1, 4, 98, 36, 90]

#+end_src

字符串是immutable, 而列表是 mutable.

#+begin_src python :results output
s = "abc"
s[0] = "c"
# =>
#    TypeErrorTraceback (most recent call last)
#    <ipython-input-14-f112f822bcf5> in <module>
#    ----> 1 import codecs, os;__pyfile = codecs.open('''/var/folders/mz/m838mtr975g17gftlv5331xh0000gn/T/pyBLrlSP''', encoding='''utf-8''');__code = __pyfile.read().encode('''utf-8''');__pyfile.close();os.remove('''/var/folders/mz/m838mtr975g17gftlv5331xh0000gn/T/pyBLrlSP''');exec(compile(__code, '''/Users/luyajun/Documents/坚果云/我的坚果云/github/wiki/python_wiki.org''', 'exec'));
#
#    ~/Documents/坚果云/我的坚果云/github/wiki/python_wiki.org in <module>
#    ----> 1 # -*- org-confirm-babel-evaluate: nil; -*-
#          2 #+PROPERTY: header-args :eval never-export
#          3
#          4 * Python_wiki                                                           :toc:
#          5   - [[#常见问题][常见问题]]
#
#    TypeError: 'str' object does not support item assignment
#+end_src

**** count

#+begin_src python
a = [66.25, 333, 333, 1, 1234]
print(a.count(333), a.count(66.25), a.count('x'))
#+end_src

#+begin_src python
some_data = ['a','a','b','c']
count_freq = dict()
for item in some_data:
    if item in count_freq:
        count_freq[item] += 1
    else:
        count_freq[item] = 1
count_freq
# => {'a': 2, 'b': 1, 'c': 1}
#+end_src

#+begin_src python
from collections import Counter
some_data = ['a', '2', 2, 4]
Counter(some_data)
# => Counter({'a': 1, '2': 1, 2: 1, 4: 1})
Counter("success")
# => Counter({'s': 3, 'u': 1, 'c': 2, 'e': 1})
#+end_src

可以使用elements() 方法来获取Counter 中的key 值。

#+begin_src python
list(Counter("success").elements())
# => ['s', 's', 's', 'u', 'c', 'c', 'e']
#+end_src

利用most_common() 方法可以找出前 N 个出现频率最高的元素以及它们对应的次数。

#+begin_src python
from collections import Counter
some_data = ['a', '2', 2, 4]
Counter(some_data).most_common(2)
#+end_src

当访问不存在的元素时，默认返回为0 而不是抛出 KeyError 异常。

#+begin_src python :results output
from collections import Counter
some_data = ['a', '2', 2, 4]
Counter(some_data).most_common(2)
# => [('a', 1), ('2', 1)]
(Counter(some_data))['y']
# => 0
c = Counter("success")
c.update("successfully")
# =>
c
# => Counter({'s': 6, 'c': 4, 'u': 3, 'e': 2, 'l': 2, 'f': 1, 'y': 1})
c.subtract('successfully')
c
# => Counter({'s': 0, 'c': 0, 'e': 0, 'u': -1, 'f': -1, 'y': -1, 'l': -2})
#+end_src

**** deque
可以把列表当做队列用，只是在队列里第一加入的元素，第一个取出来；但是拿列表用作这样的目的效率不高。在列表的最后添加或者弹出元素速度快，然而在列表里插入或者从头部弹出速度却不快（因为所有其他的元素都得一个一个地移动）。

#+begin_src python
from collections import deque
queue = deque(['eric', 'john', 'michael'])
queue.append('terry')
queue.append('graham')
queue.popleft() ##the first to arrive now leaves
queue
queue.popleft()
queue
#+end_src

**** 嵌套列表解析
可以将 3*4 的矩阵列表转换为 4*3 列表。
#+begin_src python
matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
]

[[row[i] for row in matrix] for i in range(4)]
#+end_src

*** print
在 python 中，print 的功能要比 R 要丰富的多。类似于是 glue。

#+begin_src python
new_points = alien_0['color']
print("you just earned " + str(new_points) + " points!")
#+end_src

*** tolist
array 转变成 list.
#+begin_src python
import array as arr
a = arr.array("i", [10, -20, 30])
print("type of a:", type(a))
print("a is:", a)
list1 = list()
a.tolist()
#+end_src

*** title
Python title() 方法返回"标题化"的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())。
#+begin_src python
a = []
a.append("df")
a.append("sd")
a.insert(0,"sa")
# =>
a
# => ['sa', 'sa', 'sa', 'df', 'sd']
b = a.pop(0)
# => 'sa'
b.title()
# => 'Sa'
#+end_src

pop(0) 是删除第一个元素。

*** Any/All
逻辑集合。

#+begin_src python
any([False, True])
# => True
all([False, True])
# => False
#+end_src

*** range
使用 range() 创建数字列表，可以使用函数 list() 将 range() 的结果直接转换为列表。这个函数类似于 seq.

#+begin_src python
numbers = list(range(1, 6))
print(numbers)
# [1, 2, 3, 4, 5]
#+end_src

range 函数在python2 和python3 中有区别，python2 中返回的是列表，python3 返回的是迭代器，这样做的目的是节约内存。

*** for 循环
for 循环中的 print 需要缩进。
#+begin_src python
magicians = ['alice', 'david', 'carolina']
for magician in magicians:
    print(magician)
#+end_src

*** len
可以列表的长度。

#+begin_src python
cars = ['bmw', 'audi']
len(cars)
# => 2
#+end_src

*** reverse
倒着打印列表。
#+begin_src python
cars = ['bmw', 'audi']
cars.reverse()
print(cars)

for i in reversed([2, 5, 3, 9, 6]):
    print(i)
#> 6
#> 9
#> 3
#> 5
#> 2
#+end_src

*** sort
对列表进行永久性排序。
#+begin_src python
magicians = ['alice', 'david', 'carolina']
magicians.sort()
magicians
#+end_src

*** sorted
使用 sorted() 对列表进行 *临时排序* 。要保留列表元素原来的列表的顺序，同时以特定的顺序呈现它们。除此之外，sorted()函数还有两个参数：key 和 reverse.

key 指定带有单个参数的函数，用于从 iterable 的每个元素中提取用于比较的键 (例如 key=str.lower)。默认值为 None (直接比较元素), reverse 为一个布尔值。如果设为 True，则每个列表元素将按反向顺序比较进行排序。

#+begin_src python
magicians = ['alice', 'david', 'carolina']
sorted(magicians)
a = sorted([2, 4, 3, 7], reverse=True)
print(a)
#> [7, 4, 3, 2]
chars = ['apple', 'watermelon', 'pear', 'banana']
sorted(chars, key = lambda x:len(x))
#> ['pear', 'apple', 'banana', 'watermelon']
#+end_src

#+begin_src python
basket = ['apple', 'orange', 'apple']
for f in sorted(set(basket)):
    print(f)
#> apple
#> orange
#+end_src

*** append
在列表中添加元素。该方法在其末尾添加新元素“ducati”。在列表末尾添加元素。
#+begin_src python
a = []
a.append("df")
a
#+end_src

*** clear

#+begin_src python :results output
letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
letters[:] = []
letters
# => []
#+end_src

*** insert
在任意位置添加新元素。

#+begin_src python
a = []
a.append("df")
a
a.append("sd")
a
a.insert(0,"sa")
a
#+end_src

#+begin_src python
week = ['day1','day2','day3']
# => ['day1', 'day2', 'day3']
week.insert(1,'day4')
# =>
week[1] = ["day1"]
# => ['day1']
week[1:1] = ["day1"]
# => []
week[1:1] = "day1"
# => []
week1 = "day1"
# => 'day1'
#+end_src

list 数据中插入\删除操作的时间复杂度

| 操作            | 时间复杂度 |
| list[index]     | O(1)       |
| list.append     | O(1)       |
| list.insert     | O(n)       |
| list.pop(index) | O(1)       |
| list.remove     | O(n)       |


*** item
这个函数一般用在字典类型数据。遍历字典时，如果直接遍历字典对象，只能得到字典中的键.使用字典 items() 方法，便可以同时输出键和对应值：

#+begin_src python
sample = {'a':1, 'b':2, 'c':3}
for i in sample:
    print(i)
#> a
#> b
#> c
for i in sample.items():
    print(i)
#> ('a', 1)
#> ('b', 2)
#> ('c', 3)
#+end_src

*** get
获取dict 数据中的value。

#+begin_src python :results output
sample = {"a":1, "b":2, "c":3}
sample.get("a")
#+end_src

*** zip
zip 函数接收一个或多个可迭代对象，并将各个迭代对象对应的元素聚合，返回一个元组的迭代器。
#+begin_src python
x = [1, 2, 3]
y = [4, 5, 6]
zipped = zip(x, y)
list(zipped)
#> [(1, 4), (2, 5), (3, 6)]
color = ['white', 'blue', 'black']
animal = ['cat', 'dog', 'pig']
for i in zip(color, animal):
    print(i)
#> ('white', 'cat')
#> ('blue', 'dog')
#> ('black', 'pig')
#+end_src

*** del
从列表中删除元素。可以删除任意位置的元素。
#+begin_src python
a = ['honda', "bmw"]
del a[0]
a
#del 可以删除字典中的键，也可以合并字典数据。
#+begin_src python
dic = {'name':'zs','age':18}
dic
del dic['name']
dic
dic2 = {'name':'ls'}
dic.update(dic2)
dic
#+end_src

*** pop
可以使用 pop() 可以删除末尾元素。

#+begin_src python
a = ['honda', "bmw"]
del a[0]
a.append("dff")
a
c = a.pop(0) #自动从最后一个元素开始剔除
a
#+end_src

如果要从列表中删除一个元素，且不再以任何方式使用它，那就用 del 语句；如果要在删除元素后还能继续使用它，就使用方法 pop().
*** remove

根据值删除元素。a.remove("df")

#+begin_src python
a = ['honda', "bmw"]
a = []
a.append("df")
a
a.append("sd")
a
a.insert(0,"sa")
a
b = a.pop(0)
a.remove("df")
a
c = "df"
a.remove(c)
a
#+end_src

*** time.sleep
sleep 就是推迟程序中线程中进行的时间，参数形式是：

time.sleep(1) 在执行到这句语句时候，python 就会将程序推迟一秒钟后继续下一个语句。

*** 列表解析
列表解析将 for 循环和创建新元素的代码合并一行，并自动附加新元素。
#+begin_src python
squres = [value**2 for value in range(1, 11)]

*** if
#+begin_src python
cars = ['audi', 'bmw']
for car in cars:
    if car == 'bmw':
        print(car.upper())
    else:
        print(car.title())
#+end_src

*** boolen

#+begin_src python
cars = ['audi', 'bmw']
cars == "bmw"
#True
car = "Audi"
car.lower() == "audi"

*** 检查多个条件
and/or. and 等价于 R 中的&.

#+begin_src python
age_0 = 22
age_1 = 18
age_0 >= 21 and age_1 >=21
age_0 >= 21 or age_1 >=21

*** in
    #+begin_src python
df = ['a', 'b', 'c']
"a" in df
    #+end_src
*** not in
in 反义词。
    #+begin_src python
df = ['a', 'b', 'c']
"a" not in df
    #+end_src

    #+begin_src python
df = ['a', 'b', 'c']
a = "d"
"a" not in df
if a not in df:
    print(a.title() + ", you can post a response if you wish.")
    #+end_src

*** else
    #+begin_src python
age = 17
if age >= 18:
    print("you are old enough to vote!")
    print("Have you registered to vote yet?")
else:
    print("Sorry, you are too young to vote")

*** elif

#+begin_src python
age = 12
if age < 4:
    print("Your admission cost is $0.")
elif age < 18:
    print("Your admission cost is $5.")
else:
    print("your admission cost is $10.")
#+end_src

使用多个 elif 代码块。

#+begin_src python
age = 12

if age < 4:
    price = 0
elif age < 18:
    price = 6
elif age < 65:
    price = 10
else:
    price = 5

    price
print("Your admission cost is $" + str(price) + ".")

也可以省略 else 代码块。

#+begin_src python
age = 12
if age < 4:
    price = 0
elif age < 18:
    price = 5
elif age < 65:
    price = 10
elif age >= 65:
    price = 4

print("Your admission cost is $" + str(price) + ".")

*** for,if

#+begin_src python
s = ['a', 'b', 'c']
for s in s:
    if s == 'b':
        print("sorry, we are out.")
    else:
        print("adding " + s + ".")
        print("\nfinished!")
#+end_src

在运行 for 循环前确定列表是否为空很重要！

#+begin_src python
a = []
if a:
    for b in a:
        print("sd")
        print("\nfinishing")
else:
    print("c")
#+end_src

*** continue
与 if 语句相比，循环的 else 子句更像 try 的 else 子句： try 的 else 子句在未触发异常时执行，循环的 else 子句则在未运行 break 时执行。try 语句和异常详见 处理异常。

continue 语句也借鉴自 C 语言，表示继续执行循环的下一次迭代：
#+begin_src python
for num in range(2, 10):
    if num % 2 == 0:
        print("found an even number", num)
        continue
    print("found an odd number", num)
    # => found an even number 2
    #    found an odd number 3
    #    found an even number 4
    #    found an odd number 5
    #    found an even number 6
    #    found an odd number 7
    #    found an even number 8
    #    found an odd number 9
#+end_src

上面那个代码等价于下列代码

#+begin_src python :results output
for num in range(2,10):
    if num % 2 == 0:
        print("found an even number", num)
    else:
        print(num, "is found an odd number")
#+end_src

*** break
break 语句和C 中的类似，用于跳出最近的for 或 while 循环。

#+begin_src python :results output
for num in range(2,10):
    if num % 2 == 0:
        print("found an even number", num)
        break
    else:
        print(num, "is found an odd number")
        # => found an even number 2
#+end_src

*** 引号
**** 单引号、双引号
单引号和双引号工作机制完全相同.可以通过单引号、双引号指定字符串。
#+begin_src python
  '''
  这是一段多行字符串。这是它的第一行。
This is the second line.

"What's your name?," I asked.

He said "Bond, James Bond."
  '''
#+end_src

**** 三引号
*** enumerate
当遍历一个非数值序列时，有时候会需要将元素和索引一起取出，这时候便可以到 enumerate()函数。enumerate()函数接受一个序列或者迭代器，返回一个元组，里面包含元素及其索引数值。

#+begin_src python
seasons = ['spring', 'summer', 'Fall', 'Winter']
list(enumerate(seasons))
#> [(0, 'spring'), (1, 'summer'), (2, 'Fall'), (3, 'Winter')]
#+end_src

还可以通过调整 start 参数，规定序列数值的起始值。
#+begin_src python
seasons = ['spring', 'summer', 'Fall', 'Winter']
list(enumerate(seasons, start=1))
#> [(1, 'spring'), (2, 'summer'), (3, 'Fall'), (4, 'Winter')]
#+end_src

#+begin_src python
for i,v in enumerate(['a', 'b', 'c']):
    print(i, v)
#> 0 a
#> 1 b
#> 2 c
#+end_src

*** map
map()方法会将一个函数映射到序列的每一个元素上，生成新序列，包含所有函数返回值。这么说确实像 R 中的 map 函数。

Map applies a function to all the items in an input_list. Here is the blueprint:
map(function_to_apply, list_of_inputs).
Most of the times we want to pass all the list elements to a function one-by-one and then collect the output.

#+begin_src python
items=[1,2,3,4,5]
squared=list(map(lambda x:x**2,items))
squared
#+end_src

这个函数可以参照 case_when.比如下列命令可以将 yes 替换成 True, 将 no 替换成 False.

#+begin_src python
df.assign(priority = df.priority.map({'yes':True,'no':False}))
#+end_src

*** filter
As the name suggests, filter creates a list of elements for which a function returns true.

filter()函数轻松完成了任务，它用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象。filter()函数和 map()、reduce()函数类似，都是将序列里的每个元素映射到函数，最终返回结果。

#+begin_src python
nums = [1, 2, 3, 4, 5]
list(filter(lambda x:x%2!=0, nums))
#> [1, 3, 5]
chars = ['apple', 'watermelon', 'pear', 'banana']
list(filter(lambda x:'w' in x, chars))
#> ['watermelon']
number_list = range(-5, 5)
less_than_zero = list(filter(lambda x: x < 0, number_list))
print(less_than_zero)
#+end_src

在df 中filter 函数实现方法有：

#+begin_src python
iris[iris.sepal_width > 0.2]
iris.query("sepal_width > 0.2")
iris[iris.sepal_width > 0.2]
iris[(iris.species == "setosa") | (iris.species == "versicolor")]
iris[iris.species.isin(['setosa','versicolor'])].head()
#+end_src

如果要反选，可以用以下代码

#+begin_src python :results output
iris[~iris.species.isin(['setosa','versicolor'])].head()
#+end_src


注意query 函数中是字符串。

*** reduce
Reduce is a really useful function for performing some computation on a list and returning the result.

#+begin_src python
from functools import reduce
product = reduce((lambda x, y: x * y), [1, 2, 3, 4])
product
#+end_src

还可以这么写这个函数：

#+begin_src python
from functools import reduce
lambda x:__import__('functools').reduce(int.__mul__, range(1,x+1),1)
#+end_src

如果把序列 [1,3,5,7,9] 变换成整数 13579, reduce 就可以派上用场了。

#+begin_src python :results output
from functools import reduce
def fn(x,y):
    return x*10+y
reduce(fn, [1,3,4,5,7])
#+end_src

*** format
python 中 format 方法所做的事情便是将每个参数值替换至格式所在的位置。这之中可以有更详细的格式。所以，format 函数的入参是 str?
format 方法是格式化输出，也就是在 {} 的地方替换为变量的值。

#+begin_src python
print('{0:.3f}'.format(1.0/3))
print('{0:_^11}'.format('hello'))
print('{name} wrote {book}'.format(name='swaroop',book='python'))
#+end_src

*** f''
格式化的字符串前缀 f' 和接受的格式字符相似 str.format.

#+begin_src python :results output
name = ['a','b','c']
print(f'Python 列表有:{name}')
#+end_src

*** while
while 语句同其他编程中 while 的使用方式大同小异。
#+begin_src python
while condition:
    expressions
#+end_src

在使用 while 句法的时候一定要注意在循环内部一定要判断条件的值，否则程序会一直执行下去。
#+begin_src python
condition = 0
while condition < 10:
    print(condition)
    condition += 1
#+end_src

整数和浮点数也能进行 Boolean 数据操作, 具体规则，如果该值等于 0 或者 0.0 将会返回 False 其余的返回 True。在 Python 中集合类型有 list、 tuple 、dict 和 set 等，如果该集合对象作为 while 判断语句， 如果集合中的元素数量为 0，那么将会返回 False, 否则返回 True。

#+begin_src python
condition = 10
while condition:
    print(condition)
    condition -= 1
a = range(10)
while a:
    print(a[-1])
    a = a[:len(a)-1]
# fibonacci series
a,b = 0,1
a
b
while a < 10:
    print(a)
    a,b = b,a+b
#+end_src

#+begin_src python
number = 23
running = True
while running:
    guess = int(input('Enter an integer : '))

    if guess == number:
        print('Congratualtions, you guessed it.')
        running = False
    elif guess < number:
        print('No, it is a little higher than that.')
    else:
        print('No,it is a little lower than that.')
else:
    print('The while loop is over.')

    print('Done.')
    #+end_src

*** for
for...in 语句是另一种循环语句，其特点是会在一系列对象上进行迭代。

    #+begin_src python
      for i in range(1,5):
          print(i)
else:
    print('The for loop is over')
    #+end_src

*** _

在 python 中，下划线你可以当他是一个变量，但是一般习惯不用这个变量。这个循环的用途是循环5次，但是不用这个变量。

#+begin_src python :results output
for _ in range(5):
    print(_)
#+end_src

*** dir
内置的 dir() 函数能够返回由对象所定义的名称列表。有点像 R 中的 ls()。
#+begin_src python
  dir(pandas)
  dir()
  a = 5
  dir()
#+end_src

*** do.call
python 版的 do.call 可以用以下代码实现，可以看出 python 的编程思想和 r 还是有些区别的。

#+begin_src python
import builtins
def do_call(what, *args, **kwargs):
    return getattr(builtins, what)(*args, **kwargs)

do_call("sum", range(1,11))

functions = {
    "sum": sum,
    "mean":lambda v:sum(v)/len(v)
}
functions['sum'](range(1,11))
#+end_src

*** rownames_to_column/column_to_rownames

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  #将行名转移到 column
  a=rownames_to_column(iris, var = "C") #新建一个列名 C，用 id 填充
  column_to_rownames(a, var = "C") #用变量 C 填充行名
#+END_SRC

在R 中，列名的重新命名有这2个命名，在python中，可以用 set_index 和 reset_index 来做同样的事情。

#+begin_src python
import seaborn as sns
import pandas as pd
import numpy as np
df = sns.load_dataset('iris')
df.set_index('species',inplace= True, append= True)
df.reset_index(inplace= True, level= 'species')
df.head()
#+end_src

*** break 语句
break 语句用以中断（break）循环语句，也就是中断循环语句的执行，即使循环条件没有变更为 False,或队列中的项目尚未完全迭代依旧如此。

#+begin_src python
while True:
    s = input('Enter something:')
  if s == 'quit':
      break
  print('Length of the string is', len(s))
  print('Done')
#+end_src

*** 基本数学运算
**** sqrt
    #+begin_src python
    from math import sqrt
    print('square root of 16 is', sqrt(16))
    #+end_src
*** 列表推导
列表推导的作用只有一个是生成列表。
#+begin_src python
listtwo = [2*i for i in listone if i >2]
listtwo
#+end_src

**** 笛卡尔积
双重 for 可以实现笛卡尔积。
#+begin_src python
colors = ['black', 'white']
sizes = ['s', 'M', 'L']
tshirts = [(color, size) for color in colors for size in sizes]
tshirts
print(tshirt)
#+end_src

这里得到的结果是先以颜色排列，再以尺码排列。

#+begin_src python
colors = ['black', 'white']
sizes = ['s', 'M', 'L']
for tshirt in ('%s %s' % (c, s) for c in colors for s in sizes):
    print(tshirt)
#+end_src

** pycharm 使用技巧
| 功能          | 快捷键             |
| main 函数补全 | tab                |
| alt+/         | 实现函数和变量补全 |
其实，我想从 tidyverse 对应的 Python 学起。
** numpy
*** 查看版本
#+begin_src ipython :session :exports both :results raw drawer
import numpy
numpy.__version
#+end_src
*** info
从命令行得到 numpy 的 help 文档。
#+begin_src python
import numpy as np
np.info(np.add)
#+end_src

查看data.frame 的内存

#+begin_src python
df = pd.DataFrame({
  '列1':['1','2','-']
})

df.astype({'列1':'float'}).dtypes
pd.to_numeric(df.列1,errors = 'coerce')

df.info(memory_usage='deep')
#+end_src

*** np.nonzero
可以找到数组中非 0 元素的位置索引。

#+begin_src python
import numpy as np
np.nonzero([1,2,0,0,4,1])
#+end_src

*** head
展示数据前 5 行。和 R 类似，用 head 需要将数据转换为 pd.DataFrame.

#+begin_src python
import seaborn as sns
import pandas as pd
import numpy as np
df = sns.load_dataset('iris')
print(df.head())
*** keys

和 R 不同，python 中察看数据结构还可以用下面命令。
#+begin_src python
from sklearn.datasets import load_boston
boston = load_boston()
print(boston.keys())
#+end_src

*** matrix
矩阵表示法。和 R 不同，这里面有 list 可以表示 matrix.

#+begin_src python
A = [[1, 4, 5],
[-5, 8, 9]]
np.array(A)
#+end_src

**** np.transpose
转置。
#+begin_src python
import numpy as np
A = [[1, 4, 5],
     [-5, 8, 9]]
np.transpose(A)
#+end_src
**** np.matmul
矩阵乘法。
#+begin_src python
A = [[1, 4, 5],
     [-5, 8, 9]]
B = [[1,2],[2,3]]
np.matmul(np.transpose(A),B)
#+end_src
**** type
数据类型。
#+begin_src python
A = [[1, 4, 5],
     [-5, 8, 9]]
type(A)
#+end_src

多层嵌套

#+begin_src python
my_lists = [
    [[1,2,3],[4,5,6]]
]

my_lists
[x for sublist1 in my_lists
 for sublist2 in sublist1
 for x in sublist2]
#+end_src

*** unique
查看特征枚举值。

#+begin_src python
df = sns.load_dataset('iris')
print(df.head())
df.index
df.species.unique()
#+end_src

*** where
np.where 相当于 ifelse。

#+begin_src python
a = np.arange(10)
np.where(a<5,a,10*a)
# array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])
a = np.array([[0, 1, 2],
              [0, 2, 4],
              [0, 3, 6]])
np.where(a<4,a,-2)
# array([[ 0,  1,  2],
#       [ 0,  2, -1],
#       [ 0,  3, -1]])
#+end_src
*** argmax
R 中的which.max.

#+begin_src python :results output
import numpy as np
np.argmax([1,2,3,4])
#+end_src

*** stack/unstack
这两个函数类似 R 中的 gather 和 spread。

#+begin_src python
df = sns.load_dataset('iris')
df.set_index('species', inplace = True, append = True)
df_short = df.stack()
df_long = df_short.unstack()
df_long.head()
#+end_src

#+begin_src python
import numpy
df = pd.DataFrame(np.random.random(size=(5, 3)))
df.unstack().sort_values()[-3:].index.tolist()
#+end_src

*** 给定 dataframe,将负值代替为同组的平均值

#+begin_src python
df = pd.DataFrame({'grps': list('aaabbcaabcccbbc'),
                   'vals': [-12,345,3,1,45,14,4,-52,54,23,-235,21,57,3,87]})
print(df)

def replace(group):
    mask = group<0
    group[mask] = group[~mask].mean()
    return group

df['vals'] = df.groupby(['grps'])['vals'].transform(replace)
df
#+end_src

*** 创建 series,将 2015 所有工作日作为随机值的索引

#+begin_src python
dti = pd.date_range(start='2015-01-01', end='2015-12-31', freq='B')
s = pd.Series(np.random.rand(len(dti)), index=dti)
#+end_src

s[s.index.weekday == 2].sum()

*** melt
这个 melt 函数就是 R 中 gather。

#+begin_src python
df = sns.load_dataset('iris')
df_melt = df.melt(id_vars = 'species')
df_melt.head()
#+end_src

*** create ndarray
构造一个 array.
#+begin_src python
data1 = [6, 7.5, 8, 0,1]
np.array(data1)
      data2 = [[1,2,3,4],[5,6,7,8]]
      arr2 = np.array(data2)
      arr2 = np.array(data2, dtype=np.float32) #dtype 可以修改数据类型
      arr2.ndim #2
      arr2.shape #(2,4)
      arr2.dtype
#+end_src

**** astype
这个函数可以修改数据类型。
#+begin_src python
import numpy as np
data1 = [6, 7.5, 8, 0,1]
data2 = [2, 3, 2, 1, 1]
data3 = [2]
temp1 = np.array(data1)
temp2 = np.array(data2)
temp3 = np.array(data3)
temp1 + temp2
temp1.__add__(temp2)
temp1.__iadd__(temp3)
temp.dtype
temp1 = temp.astype(np.int64)
temp1.dtype
#+end_src

和 R 一样，python 也可以字符串型转为数值型。

#+begin_src python
  data2 = ['6', '7.5', '8', '0,1']
  temp2 = np.array(data2, dtype=np.string_)
  temp2
  temp2.dtype
  temp2.astype(float) #有些问题，需要排查

df = pd.DataFrame({'列1':['1','2']})
df.astype({'列1':'float'}).dtypes
pd.to_numeric(df.列1,errors = 'coerce')
#+end_src

当数据既有数字同时也有字符时，不能使用 astype 实现数据类型转换，得用 to_numeric 命令实现。

#+begin_src python :results output
df = pd.DataFrame({'列1':['1','2','-']})
df.astype({'列1':'float'}).dtypes
pd.to_numeric(df.列1,errors = 'coerce')
#+end_src


**** 列表属性
- 数据拼接
___add___

#+begin_src python
import numpy as np
data1 = [1, 2]
data2=[2, 3]
data1.__add__(data2)

#+begin_src python
import numpy as np
data1 = [1, 2]
data2=[2, 3, 3]
data1.__iadd__(data2)
#+end_src

- clear

删除所有元素。
#+begin_src python
import numpy as np
data1 = [1, 2]
data1.clear()
data1
#+end_src

- __contains__
是否包含。

需要从新确认! 为啥下面结果返回的是 false。

#+begin_src python
import numpy as np
data1 = ["1", "2"]
data2 = ["1"]
data1.__contains__(data2)
#+end_src

- copy
复制。
python 里面复制需要用到 copy，而不能直接 df1 = df2 这样操作！
#+begin_src python
import numpy as np
data1 = ["1", "2"]
data2 = ["1"]
data1.copy()
# => ['1', '2']
#+end_src

- count

  #+begin_src python
import numpy as np
data1 = ["1", "2"]
data2 = ["1"]
data1.count("1")
  #+end_src

- delitem
把位于 p 的元素删除。
#+begin_src python
import numpy as np
data1 = ["1", "2"]
data1.__delitem__(1)
data1
#+end_src

- getitem

可以获得位置 p 的元素。

  #+begin_src python
import numpy as np
data1 = ["1", "2"]
data1.__getitem__(1)
data1
  #+end_src

- index

在 s 中找到元素 e 第一次出现的位置。

#+begin_src python
import numpy as np
data1 = ["1", "2"]
data1.index("2")

- mul

n 个 s 的重复拼接。

#+begin_src python
import numpy as np
data1 = ["1", "2"]
data1.__mul__(2)
data1 * 2 #更快速
#+end_src

- rmul

反向拼接。没懂啥意思？

#+begin_src python
import numpy as np
data1 = ["1", "2"]
data1.__rmul__(2)

**** np.zeros/np.empty
生成全为 0 的向量和空值矩阵。

#+begin_src python
import numpy as np
np.zeros(10)
np.zeros((3,6))
np.empty((2,3,2)) #空矩阵
**** np.arange
类似于 R 中的 seq().
#+begin_src python
np.arange(4)
np.arange(4)[::-1]
#+end_src

**** np.random
随机生成数。

#+begin_src python
import numpy as np
data=np.random.randn(2,3)
data
#+end_src

**** np.linspace
在指定的间隔内返回均匀间隔的数字。
这个 c 语言里也有。
#+begin_src python
  np.linspace(start = 0, stop = 19, num = 20)
#+end_src

*** 数据维度
需要注意 list 是没有 shape 的。
    #+begin_src python
data.shape
    #+end_src

相当于 r 中的 dim(data)

*** data type
list 型也无法使用这个命令。
    #+begin_src python
data.dtype  #typeof()
    #+end_src

**** str
等价于 as.character.
#+begin_src python
str(29)
#+end_src

****** find
find() 函数检测字符串中是否包含某一个字符，返回第一个字符的索引，如果不在字符里返回-1.

#+begin_src python
str1 = 'hello world'
str1.find('lo')

****** index
index() 函数是检查字符串中是否包含某一个字符，返回第一个字符的索引，如果不包含会报错。

#+begin_src python
str1.index("lo")
str1.index("kk")
#+end_src

****** count
count() 函数统计指定索引范围内【start,end）范围内某个字符或某些字符出现的次数。

#+begin_src python
str1.count('lo',1,len(str1))
#+end_src

****** replace
replace 函数将str 中的str1 替换str2,如果指定count,则不超过count 次数。

#+begin_src python
str2 = "2019.10.30"
str2.replace(".","-")
str2.replace(".","-",1)
#+end_src

****** split
函数以某字符来切分，返回值：返回分割后的字符串列表。

#+begin_src python
str2 = "2019.10.30"
str2.split(".")
str2.split(".",1)
str2.split(".",2)
#+end_src

****** strip
去除字符串两边的空白。

#+begin_src python
str2.strip("2")
#+end_src

****** lsstrip
lsstrip() 函数去除字符串左边的空格。

#+begin_src python
str3= " sdf"
str3.lstrip(" ")
#+end_src

****** rsstrip
rsstrip() 函数去除字符串右边的空格。

#+begin_src python
str3= "sdf "
str3.rsstrip(" ")
#+end_src

****** join
join() 函数表示字符串中每个字符中间都插入一个字符串。

#+begin_src python
str3= " sdf"
'+'.join(str3)

**** int

#+begin_src python
int('-99')
#+end_src
注意 int 不能求值为整数的值传递给 int().

#+begin_src python
int('99.99')
# Traceback (most recent call last):
# File "<input>", line 1, in <module>
# ValueError: invalid literal for int() with base 10: '99.99'
#+end_src

**** float

#+begin_src python
float('3.14')
#+end_src

*** 生成数据
随机生成一组 2*3 维度数据。

#+begin_src python
import numpy as np
data = np.random.randn(2, 3) #生成2*3 维float 型数据
print(data.shape) #数据维度
print(data.dtype) #显示数据类型
print(data) #打印数据
#+end_src

#+begin_src python
import pandas
from dplython import (DplyFrame, X, diamonds, select, sift, sample_n,
                        sample_frac, head, arrange, mutate, group_by, summarize, DelayFunction)
diamonds >> select(X.carat) >> head(5)
#+end_src

*** np.dot
点乘。
#+begin_src python
np.dot([1,2], [1,2])
#+end_src

*** linalg.eig
Compute the eigenvalues and right eigenvectors of a square array.
#+begin_src python
from numpy import linalg as LA
w, v = LA.eig(np.diag((1,2,3)))
w
v
#+end_src

*** np.c_
有点像 cbind,可以将 array 连接起来。
#+begin_src python
np.c_[np.array([1,2,3]), np.array([4,5,6])]
#+end_src

*** np.r_
这个函数不象 rbind, 类似 append 函数。
#+begin_src python
  np.r_[np.array([1,2,3]), np.array([4,5,6])]
#+end_src

*** 单位矩阵、对角矩阵、三角矩阵
numpy 函数命名方式很像 matlab.
#+begin_src python
np.eye(5)
import numpy as np
x = np.array([[10,2,7],
              [3,5,4],
              [4,2,1],
              [2,4,5]])
x
np.diag(x)
#+end_src

    #+begin_src python
      np.triu(x) #上三角矩阵
      np.tril(x) #下三角矩阵
    #+end_src
*** 特征值问题解

    #+begin_src python
      np.random.seed(1010)
      x = np.random.randn(5, 3)
      va, ve = np.linalg.eig(np.cov(x))
      va
      ve
    #+end_src
*** svd 分解

    #+begin_src python
      u,d,v = np.linalg.svd(x) #奇异值分解
    #+end_src

*** cholesky 分解
    #+begin_src python
      Z = np.array([[1, -2j], [2j, 5]])
      L = np.linalg.cholesky(Z)
      L
import numpy as np
from scipy import linalg
a = np.array([[4, 12, -16],
              [12, 37, -43],
              [-16, -43, 98]])

L = linalg.cholesky(a, lower=True)
L
np.allclose(np.dot(L, L.T) , a)
    #+end_src
*** LU 分解
这里的 L 是下三角矩阵（lower triangular matrix）, U 是一个上三角矩阵（upper triangular matrix） 的乘积。

LU 分解是利用消去法进行矩阵分解。具体请见。

https://zhuanlan.zhihu.com/p/55056353

** pandas
| 函数       | dplyr     | pandas      |
| 创建列     | mutate    | assign      |
| 选择列     | select    | filter      |
| rename     | rename    | rename      |
| 过滤行     | filter    | query       |
| 排序       | arrange   | sort_values |
| 分组       | group_by  | groupby     |
| 摘要统计   | summarize | agg         |
| 判定是否 na | is.na     | isna            |


*** 查看一列的基本信息
data.columnname.describe()

#+begin_src python
import pandas as pd
data = pd.read_csv("/Users/luyajun/Documents/坚果云/我的坚果云/学习/信用评分卡/score_card/cs-training.csv")
data.age.describe()

*** 选择一列

#+begin_src python
data = pd.read_csv("/Users/luyajun/Documents/坚果云/我的坚果云/学习/信用评分卡/score_card/cs-training.csv")

data.columnname.describe()
data['age']
#+end_src

*** 选择一列的前几行数据
    #+begin_src python
data['columnsname'][:n]
    #+end_src

    #+begin_src python
 data['age'][:5]
    #+end_src

*** 选择多列
data[[[['column1', 'column2']]]]

如果只是一列，可以用data['column1'],这种选择数据的方法适用于pandas.

#+begin_src python :results output
import seaborn as sns
import pandas as pd
import numpy as np
df = sns.load_dataset('iris')
df[["species","petal_width"]]
df["species"]
#+end_src

*** filter
类似于 dplyr 中的 filter.data[data['columnname'] > condition]

#+begin_src python
data[data.age>45]
min(df[df.petal_width>0.2].petal_width)
#+end_src

#+begin_src python :results output
import tushare as ts
pro = ts.pro_api()
df = pro.daily(ts_code='000001.SZ,600000.SH', start_date='20210101', end_date='20210330')
df[df.ts_code == "000001.SZ"]
#+end_src

*** slice & select
loc 函数充当 slice, if slicing only one row, use df.loc[[3],:].

#+begin_src python
df.loc[3:4,]
df.loc[[3],]
df.loc[:,"A":"B"] #选择列
#+end_src

*** select(-A)

#+begin_src python
df = pd.DataFrame(np.arange(12).reshape(3, 4),
                  columns=['A', 'B', 'C', 'D'])
df.drop(['species'], axis=1)
df.drop(columns = ['species']).loc[1:2,]
#+end_src

*** rename
对数据进行重新命名。
#+begin_src python
df = pd.DataFrame({'列1':[100, 200], '列2':[300, 400]})
df.rename({'列1':'列 1','列2':'列 2'}, axis = 'columns')
#+end_src

只想替换列名中里的空格，还有更简单的操作，直接用str.replace 方法。

#+begin_src python :results output
df = pd.DataFrame({'列1':[100, 200], '列2':[300, 400]})
df = df.rename({'列1':'列 1','列2':'列 2'}, axis = 'columns')
df.columns = df.columns.str.replace(' ','_')
#+end_src

用add_prefix 与 add_suffix 函数可以为所有列名添加前缀或后缀。

#+begin_src python :results output
df.add_prefix('X_')
df.add_suffix('_Y')
#+end_src

*** case_when

#+begin_src python :results output
def num_to_string(num):
    numbers = {
        0:"zero",
        1:"one",
        2:"two"
}
    return numbers.get(num, None)
num_to_string(2)
# => 'two'
#+end_src

map 也可以实现cash when 的功能

#+begin_src python :results output
import seaborn as sns
import pandas as pd
import numpy as np
df = sns.load_dataset('iris')
df.species.map({'setosa':'test'})
#+end_src

*** read_csv
这个类似 fread 函数。

当要你所读取的数据量特别大时，试着加上这个参数 nrows=100，就可以在载入全部数据前先读取一小部分数据。

此外，还可以加上 usecols = [‘c1’, ‘c2’, … ]来载入所需要的指定列。另外，如果你知道某些列的类型，你可以加上 dtype = {‘c1’: str, ‘c2’: int, …} ，这样会加快载入的速度。

加入这些参数的另一大好处是，如果这一列中同时含有字符串和数值类型，而你提前声明把这一列看作是字符串，那么这一列作为主键来融合多个表时，就不会报错了。

#+begin_src python
import pandas as pd
df = pd.read_csv('myfile.csv', sep=',')
print(df)
df = pd.read_csv('data.csv', nrows=100, usecols=['c1', 'c2'], dtype = {'c1': str, 'c2': int})
#+end_src

*** to_csv

#+begin_src python
result.to_csv("D:\\history_A_stock_k_data.csv",encoding="utf_8_sig")
#+end_src

*** read_clipboard
想从剪贴板创建dataframe,可以用 read_clipboard() 函数。

#+begin_src python :results output
df = pd.read_clipboard()
df
df.index
#+end_src

*** info
这个函数类似于 glimpse.
    #+begin_src python
import pandas as pd
data = pd.DataFrame(boston.data)
data.columns = boston.feature_names
data.head()
data['price'] = boston.target
data.info()
import numpy as np
    #+end_src

*** describe
类似 R 中的 summary!
#+begin_src python
import pandas as pd
data = pd.DataFrame(boston.data)
data.columns = boston.feature_names
data.head()
data['price'] = boston.target
data.info()
data.describe()
#+end_src

*** T
转置。
#+begin_src python
 x = diamonds >> select(X.carat, X.cut) >> head
 x.T
#+end_src

*** columns
生成数据的样例可以用下列代码生成。
从以下的代码可以看出，columns 可以确定列名，index 可以确定行名。
#+begin_src python
import pandas as pd
df=pd.DataFrame(np.random.randn(4,3),columns=list('bde'),index=['utah','ohio','texas','oregon'])
df

数据列名重命名。
#+begin_src python
import pandas as pd
data = pd.DataFrame(boston.data)
data.columns = boston.feature_names
    #+end_src

生成一个新列，真的和 R 一样！

#+begin_src python
import pandas as pd
data = pd.DataFrame(boston.data)
data.columns = boston.feature_names
data.head()
data['price'] = boston.target
#+end_src

**** 列名
如何显示数据框的列名。
#+begin_src python
data.columns # 返回index, 可以通过list() 转换为list
data.columns.values #返回array
#+end_src

*** Series
类似于 R 中的 vector.pandas.Series(data, index, dtype, copy).

1 data    data takes various forms like ndarray, list, constants

2 index   Index values must be unique and hashable, same length as data. Default np.arrange(n) if no index is passed.

3 dtype   dtype is for data type. If None, data type will be inferred. category
为因子型。

4 copy    Copy data. Default False.

#+begin_src python
  import pandas as pd
  s = pd.Series()
  print(s)

  import numpy as np
  data = np.array(['a', 'b', 'c'])
  s = pd.Series(data)
  print(s)
#+end_src

因子型变量如下。
#+begin_src python
import pandas as pd
s = pd.Series(["a", "b"], dtype="category")
s
#+end_src

在 dataframe 是也可以将变量转换为因子型。

#+begin_src python
df = pd.DataFrame({"A":["a","b"]})
df["A"].astype("category")
#+end_src

把series 里的列表转换为 dataframe

#+begin_src python :results output
df = pd.DataFrame({'列1':["噪 乘", "随 意"], '列2':[[50,100], [10,400]]})
df.列2.apply(pd.Series)
#+end_src


*** dict
Create a series from dict.A dict can be passed as input and if no index is specified, then the dictionary keys are taken in a sorted order to construct index. If index is passed, the values in data corresponding to the labels in the index will be pulled out.

注意dict 的 key 必须是 *不可变对象*.

#+begin_src python
a = dict(one = 1, two = 2, three = 3)
a

如何判定 key 是否存在，通过 in 判断key 是否存在

#+begin_src
data = {'a' : 0., 'b' : 1., 'c' : 2.}
'a' in data
#+end_src

可以通过get 函数得到value.

#+begin_src
dict_items([('a', 0.0), ('b', 1.0), ('c', 2.0)])
data.get('a')
#+end_src

#+begin_src python
import pandas as pd
import numpy as np
data = {'a' : 0., 'b' : 1., 'c' : 2.}
s = pd.Series(data)
print s
s.columns
#+end_src

#+begin_src python
import pandas as pd
import numpy as np
data = {'a' : 0., 'b' : 1., 'c' : 2.}
s = pd.Series(data, index=['b','c','d','a'])
print(s["b"])
#+end_src

如何更新，添加数值？

#+begin_src python
a = {'A':1, "B":2}
b = {"C":3, "D":4}
a.update(b)
a
a.clear()
a
#+end_src

merge two dict

#+begin_src python :results output
x = {'a':1,'b':2}
y = {'b':10,'c':11}
z = x | y
z = {**x, **y}
#+end_src

**** items
Python 字典(Dictionary) items() 函数以列表返回可遍历的(键, 值) 元组数组。

#+begin_src python
import pandas as pd
import numpy as np
data = {'a' : 0., 'b' : 1., 'c' : 2.}
# dict_items([('a', 0.0), ('b', 1.0), ('c', 2.0)])
#+end_src

*** isnull/notnull
可以迅速地判断对象是否为 null.

#+begin_src python
import pandas as pd
import numpy as np
data = {'a' : 0., 'b' : 1., 'c' : 2.}
s = pd.Series(data, index=['b','c','d','a'])
print(s["b"])
s.isnull()
#+end_src

**** isnull().any()
用来判断某列是否有缺失值。
#+begin_src python
data = pd.read_csv("/Users/luyajun/Documents/坚果云/我的坚果云/学习/信用评分卡/score_card/cs-training.csv")
data.isnull().any()
#+end_src

**** isnull().all()
用来判断某列是否全部为空值。
#+begin_src python
data = pd.read_csv("/Users/luyajun/Documents/坚果云/我的坚果云/学习/信用评分卡/score_card/cs-training.csv")
data.isnull().all()
#+end_src

*** isna
pd.isna() 可以用来判定该序列是否存在 na 值。pd.notna() 评定序列值是否不为 na.
#+begin_src python
df = pd.DataFrame(np.random.randn(5, 3), index=['a', 'c', 'e', 'f', 'h'],
                      columns=['one', 'two', 'three'])
df
df['four'] = 'bar'
df
df['five'] = df['one'] > 0
df
df2 = df.reindex(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'])
df2
df2['one']
pd.isna(df2['one'])
pd.notna(df2['one'])
#+end_src

查看每列有多少缺失值，可以使用 isna() 方法，然后使用 sum() 函数。

#+begin_src python :results output
df = pd.DataFrame(np.random.randn(5, 3), index=['a', 'c', 'e', 'f', 'h'],
                      columns=['one', 'two', 'three'])

df.iloc[0,0] = None
df.isna().sum()
df.isna().mean() #可以用mean() 函数计算缺失值占比
#+end_src

*** insert na
python 中缺失值也是 None.
#+begin_src python
import pandas as pd
s = pd.Series([1,2,3])
s.loc[0] = None
s
s[0] = None
s
#+end_src

*** scalar
If data is a scalar value, an index must be provided. The value will be repeated to match the length of index.
#+begin_src python
  s = pd.Series(5, index=[0,1])
  s
  print(s[0])
  print(s[:3])
  print(s[-3:])
#+end_src

retrieve multiple elements using a list of index label values

#+begin_src python
data = {'a' :0.,'b' : 1., 'c' : 2.}
s = pd.Series(data, index=['b','c','d','a'])
print(s[["b",'a']])
#+end_src

*** ndarray

create a series from ndarray.

#+begin_src python
import numpy as np
import pandas as pd
from pandas import Series, DataFrame
pd.Series([4, 7, -5, 3])
  import pandas as pd
  import numpy as np
  data = np.array(['a', 'b', 'c', 'd'])
  print(data)
  print(data.dtype)
  s = pd.Series(data)
  print(s)
  print(s.dtype)

import nump
import numpy
import
import numpy as
import numpy as np
#+end_src
pd.series 中的 index

#+begin_src python
  data = np.array(['a', 'b', 'c', 'd'])
  s = pd.Series(data, index = [100, 101, 102, 103])
  print(s)
#+end_src

*** DataFrame
pandas.DataFrame(data, index, columns, dtype, copy)

create a pandas dataframe using various inputs like

- lists
- dict
- series
- numpy ndarray
- another dataframe.

**** create dataframe
     #+begin_src python
import pandas as pd
df = pd.DataFrame()
print(df)
pd.Series(['a', 'b', 'c']) #一组数据与两组索引（行列索引组成的数据结构）
pd.Series([['a', 'A'], ['b', 'B'], ['c', 'C']],columns = ['小写', '大写'],index=['一', '二', '三'])
     #+end_src

**** create a dataframe from lists
     #+begin_src python
data = [1,2,3,4,5]
df = pd.DataFrame(data)
print(df)
     #+end_src

#+begin_src python
data = [['Alex',10],['Bob',12]]
df = pd.DataFrame(data, columns=['Name','Age'])
df = pd.DataFrame(data, columns=['Name','Age'], dtype=float)
df.keys()
print(df)
#+end_src

**** create a dataframe from dict of ndarrays/lists

#+begin_src python
data = {'Name':['Tom'],'Age':[28]}
df = pd.DataFrame(data)
print(df)
#+end_src

#+begin_src python
import pandas as pd
data = {'Name':['Tom'],'Age':[28]}
df = pd.DataFrame(data, index = ['rank1'])
print(df)
#+end_src

****  create a dataframe from list of dicts
List of Dictionaries can be passed as input data to create a DataFrame. The dictionary keys are by default taken as column names.

#+begin_src python
  data = [{'a' : 1, 'b' : 2},{'a':5,'b':10,'c':20}]
  df = pd.DataFrame(data, index=['rank1','rank2'])
  print(df)
#+end_src

#+begin_src python
  df1 = pd.DataFrame(data, index=['first', 'second'], columns=['a','b'])
  df2 = pd.DataFrame(data, index=['first', 'second'], columns=['a','b1'])
  print(df1)
  print(df2)
#+end_src

**** create a dataframe from dict of series
     #+begin_src python
       d = {'one':pd.Series([1,2,3],index=['a','b','c']),
            'two':pd.Series([1,2,3,4],index=['a','b','c','d'])}
       df = pd.DataFrame(d)
       print(df)
       print(df['one'])
     #+end_src

**** column addition
     #+begin_src python
       import pandas as pd
       d = {'one': pd.Series([1,2,3], index = ['a', 'b', 'c']),
            'two': pd.Series([1,2,3,4], index = ['a', 'b', 'c', 'd'])}

df = pd.DataFrame(d)

df['three'] = pd.Series([10,20,30],index=['a', 'b', 'c'])
print(df)
       df['four'] = df['one'] + df['three']
       print(df)
     #+end_src

**** 删除某一列
     #+begin_src python
       del df['one']
       print(df)
     #+end_src

**** loc
row can be selected by passing row label to a loc function.

可以提取特定的行！
#+begin_src python
print(df.loc['a'])
#+end_src

数据实现反转。要想索引从0到1,需要用reset_index 方法，并用drop 关键字去掉原有索引。

#+begin_src python :results output
df = pd.DataFrame({'列1':[100, 200], '列2':[300, 400]})
df = df.rename({'列1':'列 1','列2':'列 2'}, axis = 'columns')
df.loc[::-1]
df.loc[::-1].reset_index(drop=True)
#+end_src

除了反转行数据，loc 还可以反转列。

#+begin_src python :results output
df.loc[:,::-1]
#+end_src

**** iloc
rows can be selected by passing integer location to an iloc fucntion.

#+begin_src python
print(df.iloc[2])
#+end_src

**** at
确定位置元素。
#+begin_src python
 df = pd.DataFrame(np.random.randn(5, 3),
                  index=['a', 'c', 'e', 'f', 'h'],
                  columns=['one', 'two', 'three'])
df.at["a", "one"]
#+end_src

**** slice rows
multiple rows can be selected using ":" operator.

#+begin_src python
  print(df[0:3])
#+end_src

**** addition of rows
add new rows to a dataframe using the append function.

#+begin_src python
df = pd.DataFrame([[1,2],[3,4]],columns=['a','b'])
  df2 = pd.DataFrame([[5,6],[7,8]],columns=['a','b'])
  df = df.append(df2)
  print(df)
#+end_src

**** deletion of rows

#+begin_src python
df = df.drop(0)
print(df)
#+end_src

**** drop
删除特定的行。
#+begin_src python
df.loc['k'] = [5.5, 'dog', 'no', 2] #特定行赋值
df
df = df.drop('k')
df
import seaborn as sns
sns.set()
iris = sns.load_dataset('iris')
df = iris
df.drop('species',1).head()
df.drop(columns=["col1"])
df.drop([0,1]) #删除前2行数据
#+end_src

**** drop_duplicates
删除重复值。
#+begin_src python
df = pd.DataFrame({'A':[1,2,2]})
df
df.loc[df['A'].shift() != df['A']]
df.drop_duplicates(subset = 'A')
#+end_src

或者
#+begin_src python
df = pd.DataFrame({'A':[1,2,2]})
df
df.loc[df['A'].shift() != df['A']]
df.drop_duplicates(subset = 'A')
#+end_src

**** sub
相减。
#+begin_src python
df = pd.DataFrame(np.random.random(size=(5, 3)))
print(df)
df1 = df.sub(df.mean(axis=1), axis=0)
print(df1)
#+end_src

**** idxmin
有 5 列的 dataframe, 求哪一列的和最小。
#+begin_src python
df = pd.DataFrame(np.random.random(size=(5, 5)), columns=list('abcde'))
print(df)
df.sum().idxmin()
#+end_src

*** function application
**** table-wise function application

#+begin_src python
def adder(ele1,ele2):
    return ele1 + ele2
df = pd.DataFrame(np.random.randn(5,3),columns=['col1', 'col2', 'col3'])
print(df)
print(df + 2)
print(df.pipe(adder,2)) #与df+2 等价
#+end_src

**** row/column wise function application

#+begin_src python
import numpy as np
def adder(ele1,ele2):
    return ele1 + ele2

df = pd.DataFrame(np.random.randn(5,3),columns=['col1', 'col2', 'col3'])
df.pipe(adder,2)
print(df.apply(np.mean)) #列
print(df.apply(np.mean, axis=1)) ##行
#+end_src

#极大值与极小值相减
#+begin_src python
print(df.apply(lambda x:x.max() - x.min()))
#+end_src

**** element wise function application
只对一列元素作变换
#+begin_src python
import numpy as np
df['col1'].map(lambda x:x*100)
#+end_src

对所有元素作变换
#+begin_src python
df.applymap(lambda x:x*100)
#+end_src

*** DocStrings
python 注释语言功能就是 docstring.当程序运行时，可以通过一个函数来获取文档。

下面函数的第一行的字符串就是该函数的文档字符串（docstring）。

该文档字符串所约定的是一串多行字符串，其中第一行以某一大写字母开始，以句号结束。
第二行为空行，后跟的第三行开始是任何详细的解释说明。在此强烈建议你在你所有重要功 能的所有文档字符串中都遵循这一约定。

可以通过使用函数的__doc__(注意其中的双下划线)属性（属于函数的名称）来获取函数 print_max 的文档字符串属性。

#+begin_src python
def print_max(x,y):
    ''' Prints the maximum of two numbers.打印两个数值中的最大数。

  The two values must be integers.这两个数都应该是整数'''
    x = int(x)
    y = int(y)

  if x > y:
      print(x, 'is maximum')
  else:
      print(y, 'is maximum')

print_max(3 ,5)
print(print_max.__doc__) #获取注释
  Prints the maximum of two numbers.

  The two values must be integers.
#+end_src

*** index/value
index 更像 R 中的行元素名称。可以进行筛选。

#+begin_src python
spam = ['hello', 'hi']
spam.index('hello')
spam.index('hi')

import pandas as pd
obj = pd.Series([4, 7, -5, 3])
obj.values
obj.index
obj1 = pd.Series([4, 7, -5, 3], index= ['d', 'b', 'a', 'c'])
obj1.index
#+end_src

可以挑选元素大于 0 的元素，这点和 R 一样。
#+begin_src python
obj1[obj1 > 0]
#+end_src

可以利用下面函数查询 index 是否会在 series 中。
#+begin_src python
"b" in obj1
#+end_src

*** value
value 是返回数值。
#+begin_src python :results output
import pandas as pd
obj = pd.Series([4, 7, -5, 3])
obj.values
#+end_src

*** iloc,loc
iloc,loc 两个操作类似于 dplyr 中的 select。

#+begin_src R :results output graphics :file fig_1.png :exports both
library(dplyr)
select(df,var1,var2)
select(df,-var3)
#+end_src

#+begin_src python
df[['var1', 'var2']]]]
df.drop('var3', 1)
import seaborn as sns
sns.set()
import pandas as pd
tips = sns.load_dataset("tips")
iris = sns.load_dataset('iris')
iris.info(null_counts=True) #类似于R 中的 glimpse(iris)
##filter
iris[iris.sepal_width > 0.2]
iris.query("sepal_width > 0.2")
##select
iris.loc[:, [["sepal_width", "sepal_length"]]]
iris.loc[1, :] #第一列数据
iris.loc[[1], :] #第一行数据
df %>% select(-col1)
df.drop(columns=["col1"])
#+end_src

**** regex
这部份在 dplyr 里面是 tidyselect 包中的内容。contain,match 等等。
这里面的filter 是指select 某些列。

#+begin_src python
df = sns.load_dataset('iris')
df.filter(regex='length$')
#+end_src

*** arrange

#+begin_src R :results output graphics :file fig_1.png :exports both
df %>%
     arrange(desc(col1))
#+end_src

#+begin_src python
df.sort_values(by="col1", ascending=False)
#+end_src

sort_values 命令还可以实现对多个变量的排序。
#+begin_src python
df.sort_values(by = ['age', 'visits'], ascending=[False, True])
#+end_src

*** assign
等价于 R 中的 mutate 函数。
#+begin_src python
iris.assign(new=iris.sepal_width/iris.petal_width,
            newcol=lambda x:x["new"]+1)
df.assign(AoverC = df.A/df.C,
          Bplus = lambda df:df["B"] + 1)
#+end_src

lambda 函数真是一个好东西啊。
#+begin_src python
df.assign(AoverC = df.A/df.C,
         Bplus = df.AoverC + 1)
#+end_src
上式肯定会报错，但是用 lambda 函数就没有问题。

#+begin_src python
df.assign(AoverC = df.A/df.C,
          Bplus = lambda x: x['AoverC'] + 1)
#+end_src

这就对了！

#+begin_src python
def is_b(letter):
    return letter == "b"

df.assign(is_alphabet_b = lambda df:df.Alphabet.apply(is_b))
#+end_src

*** group_by
R,特别是tidyverse 包的rlang 功能特别方便。

#+begin_src python
import pandas as pd
df = pd.DataFrame({'Animal':['Falcon','Falcon','Parrot','Parrot'],'Max Speed':[380.,370.,24.,26.]})
df.groupby(['Animal']).mean #对animal 进行分组然后求mean()
arrays = [['Falcon','Falcon','Parrot', 'Parrot'],
           ['Captive', 'Wild', 'Captive', 'Wild']]

index = pd.MultiIndex.from_arrays(arrays, names=('Animal', 'Type'))
df = pd.DataFrame({'Max Speed':[390., 350., 30., 20.]}, index=index)
df.groupby(level=0).mean()
df.groupby(level=1).mean()
#+end_src
select a group. 用 get_group 选择一个组。

#+begin_src python :results output
import pandas as pd
df = pd.DataFrame({'Animal':['Falcon','Falcon','Parrot','Parrot'],'Max Speed':[380.,370.,24.,26.]})
df.groupby(['Animal']).mean #对animal 进行分组然后求mean()
df.groupby(['Animal']).get_group("Falcon") #对animal 进行分组然后求mean()
#+end_src

*** select
select_dtypes

如果已经在 Python 中完成了数据的预处理，这个命令可以帮你节省一定的时间。在读取了表格之后，每一列的默认数据类型将会是 bool，int64，float64，object，category，timedelta64，或者 datetime64。首先你可以观察一下大致情况，使用：

#+begin_src python
df.dtypes.value_counts()
#+end_src
来了解你的 dataframe 的每项数据类型，然后再使用：
#+begin_src python
df.select_dtypes(include=['float64', 'int64'])
df.select_dtypes(exclude=['float64', 'int64'])
#+end_src
获取一个仅由数值类型组成的 sub-dataframe。

*** dtypes
查看数据类型


*** agg
等价于 R 中的 summarize 函数.
#+begin_src python
import pandas as pd
df = pd.DataFrame({'Alphabet': ['a', 'b', 'c', 'd','e', 'f', 'g', 'h','i'],
                   'A': [4, 3, 5, 2, 1, 7, 7, 5, 9],
                   'B': [0, 4, 3, 6, 7, 10,11, 9, 13],
                   'C': [1, 2, 3, 1, 2, 3, 1, 2, 3]})

df.groupby("Alphabet")\
    .agg({'A':['mean']})
#+end_src

可以 apply different functions to dataframe columns.
#+begin_src python
df.groupby("Alphabet")\
    .agg({'A':'sum',
          'B':'mean'})
#+End_src

#+begin_src python
animals = pd.DataFrame({'kind': ['cat', 'dog', 'cat', 'dog'],
                            'height': [9.1, 6.0, 9.5, 34.0],
                            'weight': [7.9, 7.5, 9.9, 198.0]})

animals.groupby("kind").agg(
    min_height = pd.NamedAgg(column='height', aggfunc='min')
)
#+end_src

*** transform

当一个数据进行分组计算时候，会生成汇总类型数据，而确保每行数据都保留计算结果就要用 transform.

#+begin_src python :results output
from sklearn.datasets import load_iris
from sklearn.tree import DecisionTreeClassifier
iris = load_iris()
iris.groupby("species").petal_width.sum #可以试试这个命令和下面命令差异
iris.groupby("species").petal_width.transform('sum')
len(iris.petal_width)
#+end_src

*** join

#+begin_src python
import pandas as pd
left = pd.DataFrame({
    'id':[1,2,3,4,5],
    'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
    'subject_id':['sub1','sub2','sub4','sub6','sub5']})

left

right = pd.DataFrame(
    {'id':[1,2,3,4,5],
     'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
     'subject_id':['sub2','sub4','sub3','sub6','sub5']})

pd.merge(left, right, on = "id")
pd.merge(left, right, on = ["id", "subject_id"])
pd.merge(left, right, on = ["id", "subject_id"], how="left")
pd.merge(left, right, on = ["id", "subject_id"], how="right")
pd.merge(left, right, on = ["subject_id"], how="outer")
pd.merge(left, right, on = ["subject_id"], how="inner")
#+end_src

*** date
python 中可以将 char 型转换成 date 型。

#+begin_src python
import pandas as pd
today = pd.to_datetime('2020-12-11')

#+begin_src python
import pandas as pd
df = pd.DataFrame(iris.data, columns=iris.feature_names)
print(pd.Timedelta(days=2))
import pandas as pd
s = pd.Series([pd.date_range('2012-1-1', periods=3, freq='D')])
td = pd.Series([pd.Timedelta(days=i) for i in range(3)])
df = pd.DataFrame(dict(A=s,B=td))
#+end_src
*** date_range
可以生成日期型数据。
#+begin_src python
import pandas as pd
s = pd.Series([pd.date_range('2012-1-1', periods=3, freq='D')])
#+end_src

*** string

在python 中，string 类型被称为 object.

#+begin_src python
price_data.dtypes
#+end_src

**** str.replace

#+begin_src ipython :session :exports both :results raw drawer
str = 'this is string'
print(str.replace("is", "was"))
#+end_src

**** str.lower/str.upper

#+begin_src ipython :session :exports both :results raw drawer
import pandas as pd
import numpy as np
s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])
print(s.str.lower()) #小写
print(s.str.upper()) #大写
#+end_src

**** str.len
字符长度
#+begin_src ipython :session :exports both :results raw drawer
import pandas as pd
import numpy as np
s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])
print(s.str.len())
#+end_src

**** str.cat
类似于 R 中的 str_c.
#+begin_src ipython :session :exports both :results raw drawer
import pandas as pd
import numpy as np
s = pd.Series(['Tom ', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])
print(s.str.cat(sep='_'))
#+end_src

**** str.contains
类似于 str_detect.
#+begin_src ipython :session :exports both :results raw drawer
import pandas as pd
import numpy as np
s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])
print(s.str.contains(' '))
#+end_src

**** str.repeat
重复字符串。
#+begin_src ipython :session :exports both :results raw drawer
import pandas as pd
import numpy as np
s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])
print(s.str.repeat(2))
#+end_src

**** str.count
字符串计数。
#+begin_src ipython :session :exports both :results raw drawer
import pandas as pd
import numpy as np
s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])
print(s.str.count('m'))
#+end_src

**** startswith
检查字符串是否以固定字符开头。
#+begin_src ipython :session :exports both :results raw drawer
import pandas as pd
import numpy as np
s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])
print(s.str.startswith('T'))
#+end_src

**** endswith
检查字符串是否以固定字符结尾。
#+begin_src python
import pandas as pd
import numpy as np
s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])
print(s.str.endswith('t'))
#+end_src

**** str.find
发现字符出现位置，如果返回-1,说明字符里面没有匹配的字符。
#+begin_src python
import pandas as pd
import numpy as np
s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])
print(s.str.find('e'))
#+end_src

**** str.findall
上面 str.find 的加强版。

#+begin_src python
import pandas as pd
import numpy as np
s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])
print(s.str.findall('i'))
#+end_src

**** str.swapcase
将字符串中第一个字符确定为小写，其他字符均为大写。

#+begin_src python
import pandas as pd
import numpy as np
s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])
print(s.str.swapcase())
#+end_src

**** str.islower
判断字符是否为小写。
     #+begin_src python
       import pandas as pd
       import numpy as np
       s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])
       print(s.str.islower())
     #+end_src
**** str.isupper
判断字符是否为大写。
     #+begin_src python
       import pandas as pd
       import numpy as np
       s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])
       print(s.str.isupper())
     #+end_src

**** str.isnumeric
判断字符是否为数字型。
     #+begin_src python
       import pandas as pd
       import numpy as np
       s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])
       print(s.str.isnumeric())
     #+end_src

**** capitalize
大写句首字母。
#+begin_src python
t1 = "i love Python"
t1.capitalize()
#+end_src

**** split
把句子分成单词。

#+begin_src python
t1 = "i love Python"
t1.split()

df = pd.DataFrame({'列1':["张 三", "李 四"], '列2':[300, 400]})
df.列1.str.split(" ", expand = True)
#+end_src

通过赋值语句将这两列添加到原 dataframe 中。

#+begin_src python :results output
df[["姓","名"]] = df.列1.str.split(" ", expand = True)
#+end_src


**** find

#+begin_src python
t1 = "i love Python"
t1 = "i love Python"
t1.find("love")
#+end_src

**** replace
用于字符替换。
#+begin_src python
t1 = "i love Python"
t1.replace("love Python", "hate R")
#+end_src

*** apply

Python 中 apply 函数的格式为：apply(func,*args,**kwargs).apply 的返回值就是函数 func 函数的返回值。用途：当一个函数的参数存在于一个元组或者一个字典中时，用来间接的调用这个函数，并将元组或者字典中的参数按照顺序传递给参数。

#+begin_src python
def is_b(letter):
    return letter == "b"
df.assign(is_alphabet_b = lambda df:df.Alphabet.apply(is_b))
    #+end_src

*** 统计函数
**** 方差
#+begin_src python
import pandas as pd
import numpy as np
s1 = pd.Series(np.random.randn(10))
s2 = pd.Series(np.random.randn(10))
print(s1.cov(s2))
** generator
生成器可以生成一个有限或无限的数值序列。
   #+begin_src python
def create_counter(n):
    print("create_counter")
    while True:
        yield n
        n +=1

gen = create_counter(0)
print(next(gen))
print(next(gen))
print(next(gen))

gen2 = create_counter(100)
print(next(gen2)) #输出100
print(next(gen2)) #输出101
print(next(gen2)) #输出102
   #+end_src
** 装饰器
python 中的@ 的用法，针对函数，起调用传参的作用。

由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。

#+begin_src python :results output
def now():
    print("2015-03-23")

f = now
f()
#+end_src


函数对象有一个 ___name___ 属性，可以拿到函数的名字：

#+begin_src python :results output
now.__name__
f.__name__
#+end_src

现在，假设我们要增强now() 函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now() 函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器” （decorator）。

#+begin_src ipython :session :exports both :results raw drawer
def funA(descA):
    print("It's funA")

def funB(desB):
    print("It's funB")

@funA
def funC():
    print("It's funC")
#+end_src

把 @funA 放到 funC() 函数的定义处，相当于执行了语句：

#+begin_src python :results output
funC = funA(funC)
#+end_src

#+begin_src python :results output
def funA(desA):
    print("It's funA")

    print("---")
    print(desA)
    desA()
    print("---")

def funB(desB):
    print("It's funB")

@funB
@funA
def funC():
    print("It's funC")
#+end_src

为了更直观地看参数传递，打印desA,其传的是funC() 的地址，即desA 现在为函数desA(). 执行desA() 即执行funC(), desA = desA() = funC().

** pivot_table
对每种 animal 的每种不同数量 visits, 计算平均 age,即返回一个表格，行是 animal 种类，列是 visits 数量，表格值是行动物种类列访客数量的平均年龄。

#+begin_src python
df.pivot_table(index = 'animal', columns = 'visits', values= 'age', aggfunc='mean')
#+end_src

** 修改列表元素

#+begin_src python
age=23
str(age)

** 转换
#+begin_src python
motorcycles = ['honda', 'yamaha', 'suzuki']
print(motorcycles)
motorcycles[0] = 'dycati'
print(motorcycles)
#+end_src
给我的感觉，python 在数据类型转换方面显得很笨拙。list 型转 string.在 R 中，只需要 as.str(L) 即可。
type() 可以确定数据类型。
#+begin_src python
L = list(range(10))
type(L[0])
L2 = [str(c) for c in L]
L2
#+end_src
从这个 L2 中，可以看出 L2 第一个 str(c) 显然是 L2 的数据类型，后面 strin 是一个 for 循环。

#+begin_src python
L3 = [True, "2", 3, 4]
[type(item) for item in L3]
#+end_src

** 列表中添加元素
在列表末尾添加元素，使用 append 的方法。任意位置插入元素使用 insert 的方法。
#+begin_src python
motorcycles.append("ducati")
print(motorcycles)
motorcycles.insert(0,'ducati')
motorcycles.insert(1,'anyone')
motorcycles
#+end_src

** 列表删除元素
使用 del 对列表中的确定位置元素进行删除。可以使用 pop() 删除任意  一个元素，值得注意的是，每当使用 pop() 时，被弹出的元素就不再列表中了。

除了 del,pop(), 还有 x.remove('python') 可以删除.

#+begin_src python
del motorcycles[0]
motorcycles
im
poped_motorcycles=motorcycles.pop()
motorcycles
poped_motorcycles

motorcycles = ['honda', 'yamaha', 'suzuki']
last_owned=motorcycles.pop()
motorcycles
print("the last motorcycle I owned was a " + last_owned.title() + ".")
first_owned = motorcycles.pop(0) #截取第一个元素
motorcycles = ['honda', 'yamaha', 'suzuki']
motorcycles.remove('honda')
motorcycles
#+end_src

** 根据值删除元素
可以使用 remove 将元素移除，但是也可以接着使用它的值。

#+begin_src python
motorcycles = ['honda', 'yamaha', 'suzuki']
motorcycles.remove('suzuki') #把suzuki 从元素列表中移除
#+end_src

** 组织列表
*** sort
可以使用 sort() 对字符串进行排序，参数 reverse=T 可以倒序显示。利用 sorted() 对列表进行临时排序。
*** reverse
注意 reverse() 不是指按与字母顺序相反的顺序排列列表元素，而只是反转表元素顺序。
*** len
字符长度。
#+begin_src python
len(cars)
*** 索引
#+begin_src python
  cars=['bmw','audi','toyota']
  cars.sort()
  cars
sorted(cars)
#+end_src

#+begin_src python
cars=['bmw','audi','toyota']
cars.reverse()
cars

索引－1 总是返回最后一个列表元素。
#+begin_src python
print(cars[-1])

** 循环
*** 遍历整个列表

#+begin_src python
magicians = ['alice', 'david', 'carolina']
for magician in magicians:
    print(magician)

magicians = ['alice', 'david', 'carolina']
for magician in magicians:
    print(magician.title()+",that was a great trick!")
#+end_src

** 创建数字列表
*** 使用函数 range()
#+begin_src python
for value in range(1,5):
    print(value)
#+end_src
*** 使用 range() 创建数字列表
#+begin_src python
numbers=list(range(1,6))
print(numbers)
#+end_src
range 还可以指定步长。
#+begin_src python
even_numbers=list(range(2,11,2))
print(even_numbers)
#+end_src

#+begin_src python
squres=[]
for value in range(1,11):
    squre=value**2
    squres.append(squre)

print(squres)
#+end_src

上述代码可以写的更加简洁一些。
#+begin_src python
squres=[]
for value in range(1,11):
    squres.append(value**2)
print(squres)
#+end_src
** 字典
简单示例：

#+begin_src python
alien_0 = {'color':'green','points':5}
alien_0['color']
# 'green'
#+end_src
*** 添加键－值对

#+begin_src python
alien_0 = {'color':'green','points':5}
alien_0
alien_0['x_pos'] = 0
alien_0['y_pos'] = 1
alien_0
# {'color': 'green', 'points': 5, 'x_pos': 0, 'y_pos': 1}
#+end_src

*** 创建空字典
#+begin_src python
alien_0 = {}
alien_0['color'] = "green"
alien_0['points'] = 5
alien_0
# {'color': 'green', 'points': 5}
#+end_src

*** 修改字典中的值
下面这个示例可以看出 python 在打印时没有 R 那么的灵活方便。
#+begin_src python
  alien_0 = {}
  alien_0['color'] = "green"
  print("Alien is " + alien_0['color'])
  alien_0['color'] = 'blue'
  print('alien is ' + alien_0['color'])
#+end_src

这点 python 没有 R 那么的方便，在 R 中，如果打印的话，直接是  print('alien is
' + alien_0) 即可。

#+begin_src python
  alien_0['color'] = 0
  print('alien is ' + str(alien_0['color']))
#+end_src

*** 删除键-值对
使用 del 语句时，必须指定字典名和要删除的键。
    #+begin_src python
      alien_0 = {'color':'green', 'point':5}
      del alien_0['point']
      alien_0
      # {'color': 'green'}
    #+end_src

*** 遍历字典

#+begin_src python
  import pandas as pd
  import numpy as np
  user_0 = {
      'username':'eferni',
      'first':'enrico',
      'last':'fermi'
  }

for key,value in user_0.items():
    print('\nKey:' + key)
    print('Value:' + value)
#+end_src

for 语句的第二部分包含字典名和方法 items()，它返回一个键-值对列表。

*** 遍历字典中的所有键
.keys

#+begin_src python
user_0 = {
    'username':'eferni',
    'first':'enrico',
    'last':'fermi'
}
user_0.keys
for name in user_0.keys():
    print(name.title())
#+end_src

*** 按顺序遍历字典中的所有键
    #+begin_src python
      favorite_lang = {
          'jen':'python',
          'sarah':'c',
          'edward':'R'
      }

for name in sorted(favorite_lang.keys()):
    print(name.title() + ", thank you for talking the poll.")

    # Edward, thank you for talking the poll.
    # Jen, thank you for talking the poll.
    # Sarah, thank you for talking the poll.
    #+end_src

上述 for 语句类似于其他 for 语句，但对方法 dictinary.keys() 的结果调用了函数
sorted().这让 python 列出字典中的所有键，并在遍历前对这个列表进行排序。

*** 遍历字典中的所有值
    #+begin_src python
      favorite_lang = {
          'jen':'python',
          'sarah':'c',
          'edward':'R',
          'lu':'python'
      }
for name in favorite_lang.values():
    print(name.title() + ', is favorite language.')

    # Python, is favorite language.
    # C, is favorite language.
    # R, is favorite language.
    # Python, is favorite language.
    #+end_src

可以看出上述输出有重复值，利用 set(),可以去重。

#+begin_src python
 favorite_lang = {
    'jen':'python',
    'sarah':'c',
    'edward':'R',
    'lu':'python'
}
for name in set(favorite_lang.values()):
    print(name.title() + ', is favorite language.')
 # Python, is favorite language.
    # C, is favorite language.
    # R, is favorite language.
#+end_src

*** 嵌套
有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这成为“嵌套”。
#+begin_src python
  alien = []
  #创建30个绿色的外星人
for alien_number in range(30):
    new_alien = {'color': 'green', 'points':5,'speed':'slow'}
    alien.append(new_alien)

    len(alien)
#+end_src

*** 在字典中存储列表
字典中还有列表型数据。
    #+begin_src python
      favorite_lang = {
          'jen':['python', 'ruby'],
          'sarah':['c'],
          'edward':['ruby','go'],
          'phil':['python', 'haskell']
      }

for name, languages in favorite_lang.items():
    print("\n" + name.title() + "'s favorite languages are:")
    for languages in languages:
        print('\t' + languages.title())
    #+end_src

*** 字典中还有字典
    #+begin_src python
      users = {
          'aeinstein':{
              'first':'albert',
              'last':'einstein',
              'location':'princeton',
          },
          'mcurie':{
              'first':'marie',
              'last':'curie',
              'location':'paris',
          }
      }

for username, user_info in users.items():
    print("\nUsername:" + username)
    full_name = user_info['first'] + " " + user_info['last']
    location = user_info['location']
    print("\tFull name: " + full_name.title())
    print("\tLocation: " + location.title())
    #+end_src

*** 字典推导

#+begin_src python
Dial_codes = [
    (86, 'china'),
(91, 'india'),
]

Dial_codes
country_code = {country:code for code, country in Dial_codes}
country_code
#+end_src

** 正则表达式
在 python 中 re 模块可以完成对文本的正则化处理。匹配对象的两种方法：group() 和 groups().
*** re.match
在正则表达式中，通常会选用 | 符号匹配多个字符串。
#+begin_src python
  bt = 'bat|bet|bit'
  m = re.match(bt, "bat")
  m.group()
#+end_src

*** 匹配任何单个字符
**** .可以匹配任何字符
python 和 r 不同，在正则表达式中，模式在前，字符串在后面。
#+begin_src python
import re
anyend = '.end'
m = re.match(anyend, 'bend')
m.group()
#+end_src
** 用户输入和 while 循环
*** 函数 input
    #+begin_src python
      message = input("tell me something, and I will repeat it back to you:")
      print(message)
    #+end_src

    #+begin_src python
      import numpy as np
      import pandas as pd
      name = input("Please enter your name: ")
      print("Hello, " + name + "!")
    #+end_src

    #+begin_src python
      x = eval(input('Enter a number'))
      print(x, type(x))
    #+end_src

*** int() 获取数值输入

    #+begin_src python
      age = input("how old are you?")
      age
      21
    #+end_src

*** %
%,这点和 R 一样。
#+begin_src python
  4 % 3
  # 1
#+end_src

*** while

for 循环用于针对集合中的每个元素的一个代码块，而 while 循环不断地运行，直到指定的条件不满足为此。

#+begin_src python
current_num = 1
while current_num <= 5:
    print(current_num)
    current_num +=1
current_num
 #+end_src

*** def
定义函数：

#+begin_src python
def function_name(para_1,...,para_n=defau_n,..., para_m=defau_m):
    expressions
#+end_src
函数声明只需要在需要默认参数的地方用 = 号给定即可, 但是要注意所有的默认参数都不能出现在非默认参数的前面。

**** 向函数传递信息
    #+begin_src python
      def greet_user(usename):
          print("Hello, " + usename.title() + "!")

          greet_user('jesse')
    #+end_src

#+begin_src python
  def greet_user():
      """显示简单的问候语"""
      print("Hello!")

      greet_user()

      #Hello!
#+end_src

在上面的函数参数中，usename 是形参，jesse 是实参。和 R 不同，python 可以返回字典。

#+begin_src python
def build_person(first_name, last_name):
    person = {'first': first_name, 'last': last_name}
    return person

musician = build_person('jimi', 'hendrix')
print(musician)
# {'first': 'jimi', 'last': 'hendrix'}
#+end_src

**** 传递列表
    #+begin_src python
      def greet_user(names):
    for name in names:
        msg = "Hello, " + name.title() + "!"
        print(msg)

usernames = ['hannah', 'ty', 'margot']
      greet_user(usernames)
    #+end_src

**** 传递任意数量的实参
    #+begin_src python
      def make_pizza(*toppings):
          print(toppings)

make_pizza('pepperoni')
      make_pizza('pepperoni','green peppers')
    #+end_src

形参名*toppings 中的星号让 python 创建一个名为 toppings 的空元组，并将收到的所有
值都封装到这个元组中。这点跟 R 不一样。

**** 可更改（mutable）与不可更改（immutable）对象

在 python 中，strings,tuples 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。

不可变类型：变量赋值 a = 5 后再赋值 a = 10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a.

可变类型：变量赋值 la =［1，2，3，4］后再赋值 la[2] = 5 则是将 list la 的第三个元素值更改，本身 la 没有动，只是其内部的一部分值被修改了。

python 函数的参数传递：

不可变类型：类似 C++ 的值传递，如 整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a)内部修改 a 的值，则是新生成来一个 a。

可变类型：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响

python 传不可变对象实例

#+begin_src python
def change(a):
    print(id(a))
    a=10
    print(id(a))

a=1
print(id(a))
change(a)

传可变对象实例

#+begin_src python
def changeme(mylist):
    ""
    mylist.append([1, 2, 3, 4])
    print("函数内取值：", mylist)
    return

#调用changeme 函数
mylist = [10, 20, 30]
changeme(mylist)
print("函数外取值：", mylist)


*** 导入整个模块
这块类似于 R 中的.R 执行文件，文件中可以包含 function 函数。

要让函数是可导入的，得先创建模块。模块是扩展名为.py 的文件。

*** 导入特定的函数

    #+begin_src python
from module_name import function_name
    #+end_src

通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数。

#+begin_src python
from module_name import function_0, function_1, function_2
#+end_src

使用 as 给函数指定别名，如：

#+begin_src python
import numpy as np
#+end_src

指定别名的通用语法如下：

#+begin_src python
  from module_name import function_name as fn
#+end_src

*** 使用 as 给模块指定别名
不光可以给函数命名，还可以给模块命名。
#+begin_src python
  import pizza as p
  p.make_pizza(16, 'pepperoni')
#+end_src
*** 导入模块中的所有函数
    #+begin_src python
      from pizza import *
      make_pizza(16, 'pepperoni')
    #+end_src

** lambda
lambda 函数也叫匿名函数或内联函数，即没有具体名称的函数，它允许快速定义单行函数，可以用在任何需要函数的地方。这区别于 def 定义的函数。
lambda 与 def 的区别：

1）def 创建的方法是有名称的，而 lambda 没有。

2）lambda 会返回一个函数对象，但这个对象不会赋给一个标识符，而 def 则会把函数对象赋值给一个变量（函数名）。

3）lambda 只是一个表达式，而 def 则是一个语句。

4）lambda 表达式” : “后面，只能有一个表达式，def 则可以有多个。

#+begin_src python
names = ['tony',  'bob']
sorted(names, key = lambda name:name.split()[-1].lower())
#+end_src

匿名函数需要注意的地方是:
你用 lambda 定义了一个匿名函数，并想在定义时捕获到某些变量的值。

#+begin_src python
x = 10
a = lambda y:x + y
x = 20
b = lambda y: x + y
a(10)
#> 30
b(10)
#> 30
#+end_src

从上面例子可以知道 lambda 表达式中的 x 是一个自由变量，在运行时绑定值，而不是定义时就绑定，这跟函数的默认值参数定义是不同的。

** class
类与对象是面向对象编程的两个主要方面。一个类（class）能够创建一种新的类型（type），其中对象（object）就是类的实例（instance）。python 中的 self 相当于 c++ 中的 this 指针及 java 与 C# 中的 this 引用。面向对象编程，在编写类时，定义一大类对象都有通用的行为。

类方法与普通函数只有一种特定的区别——前者必须多加一个参数在参数列表开头，这个名字必须添加到参数列表的开头，但是你不用在你调用这个功能时为这个参数赋值，Python 会为它提供。这种特定的变量引用的是对象本身，按照惯例，它被赋予 self 这一名称，以表示该类自身。

类对象支持两种操作：属性引用和实例化。属性引用使用 python 中所有属性所使用的标准语法：obj.name, 有效的属性名称是类对象被创建时存在于类命名空间中的所有名称。

如果类的定义是这样：

#+begin_src python
   class MyClass:
       """A simple example class"""
       i = 12345

     def f(self):
         return 'hello world'
#+end_src

 那么 MyClass.i 和 MyClass.f 就是有效的属性引用，将分别返回一个整数和一个函数对象。
 类属性也可以被赋值，因此可以通过赋值来更改 MyClass.i 的值。__doc__ 也是一个有效
 属性，将返回所属类的文档字符串："""A simple example class""".

 类的实例化使用函数表示法。可以把类对象视为是返回该类的一个新实例的不带参数的函数。

#+begin_src python
class Complex:
   def __init__(self, realpart, imagpart):
       self.r = realpart
       self.i = imagpart

x = Complex(3.0, -4.5)
x.r,x.i
#+end_src

 #+begin_src python
   class Dog:
       kind = 'canine'

     def __init__(self, name):
         self.name = name

 d = Dog('Fido')
 e = Dog('Buddy')
 d.kind
   # 'canine'
   e.kind
   # 'canine'
 #+end_src
*** 字符串
isdecima(),isdigit(),isalpha(),isalnum().可以测试字符串 S 是否是数字\字母\字母或数字，对于非 Unicode 字符串。
#+begin_src python
  print('34'.isdigit())
  print('34'.isalnum())
  print('34'.isdecimal())
#+end_src

** 向量
*** 将序列分解为单独变量
    #+begin_src python
      p = (4, 5)
      x, y = p
      x
      y

data = ['a', 50, 10, {2012,12,30}]
      name, share, price, date = data
      name
      share
      price
      date
    #+end_src

实际上不仅仅是元组或列表，只要对象恰好是可迭代的，那么就可以执行分解操作。这包括字符串\文件\迭代器及生成器。

*** 从任意长度的可迭代对象中分解元素

如果需要从某个可迭代对象中分解出 N 个元素，但是这个可迭代对象的长度可能超过 N.

#+begin_src python
import pandas as pd
import numpy as np
def drop_first_last(grades):
    first, *middle, last = grades
    return np.mean(middle)

drop_first_last((1,2,3,4))
#+end_src

可以利用*表达式解决这个问题，这个表达式有点类似于 R 中的 everything。

#+begin_src python
  record = ("a", 'b', '1',"2")
  a, b, *other = record
  a
  b
  other
#+end_src

*** 找到最大或最小的 N 个元素
heapq 模块中有两个函数－nlargest() 和 nsmallest().
#+begin_src python
import heapq
nums = [1, 8, 2, 23, 7, -4]
print(heapq.nlargest(3, nums))
print(heapq.nsmallest(3, nums))
*** set
当需要对一个列表进行去重操作的时候，set()函数就派上用场了。
#+begin_src python
      a = [1, 5, 2, 1, 9]
      set(a)
      # {1, 2, 5, 9}
#+end_src

要向set 中增加元素，可以通过 add 方法。

#+begin_src python :results output
s = set([1,2,3,4])
s.add(5)
s
#+end_src

移除一个元素，可以通过remove 的方法：

#+begin_src python :results output
s = set([1,2,3,4])
s.remove(4)
s
#+end_src

*** lambda
一个 lambda 函数是一个小的匿名函数。匿名函数不需要显示地定义函数名，使用【lambda + 参数 +表达式】的方式，语法是：
#+begin_src python
lambda arguments:expression

x = lambda a : a + 10
x(5)
#+end_src

lambda functions can take any number of arguments.

#+begin_src R :results output graphics :file fig_1.png :exports both
x = lambda a, b : a*b
x(5,6)
x = lambda a,b,c: a+b+c
print(x(5,6,2))
#+end_src

与 def 区别：
https://pic1.zhimg.com/80/v2-061aa0744539a1f7bfc301015e9594a2_720w.jpg

#+begin_src python
def f(x,y):
    return x*y
f(1,2)

func = lambda x,y: x*y
func(1,2)

匿名函数的优点：

- 不用取名称，因为给函数取名是比较头疼的一件事，特别是函数比较多的时候

- 可以直接在使用的地方定义，如果需要修改，直接找到修改即可，方便以后代码的维护工作

- 语法结构简单，不用使用 def 函数名(参数名):这种方式定义，直接使用 lambda 参数:返回值 定义即可

*** 全为 0/1 的数组

#+begin_src python
import numpy as np
np.ones((2, 2, 3))
np.zeros((2, 2, 3))
np.empty((2, 2, 3) )
#+end_src

** 元组
元组是一个固定长度，不可改变的 python 序列对象。创建元组的最简单方式，用用逗号分
隔一列值：

tuple 和 list 非常类似（一个用圆括号，一个用方括号），主要区别在于 tuple 不能增减
或更改其元素，而 dict 则是有索引的多元组（用花括号表示），有其方便的地方。

tuple 和 list 之间可以相互切换，list(tup)
#+begin_src python
tup = 4, 5, 6
tup
# (4, 5, 6)
list(tup)

#+begin_src python
nested_tup = (4,5,6),(7,8)
nested_tup
# ((4, 5, 6), (7, 8))
#+end_src

用 tuple 可以将任意序列或迭代器转换成元组：
#+begin_src python
tuple([4,0,2])
# (4, 0, 2)
tuple('string')
# ('s', 't', 'r', 'i', 'n', 'g')
#+end_src

如果元组中的某个对象是可变的，比如列表，可以在原位进行修改。

#+begin_src python
tup = tuple(['foo', [1,2], True])
tup[1].append(3)
tup
# ('foo', [1, 2, 3], True)
#+end_src

可以用加号运算符将远组串联起来。
#+begin_src python
(4,None,'foo') + (6,0) + ('bar',)
# (4, None, 'foo', 6, 0, 'bar')
#+end_src

元组乘以一个整数，像列表一样，会将几个元组的复制串联起来：

#+begin_src python
('foo', 'bar')*4
# ('foo', 'bar', 'foo', 'bar', 'foo', 'bar', 'foo', 'bar')
#+end_src

创建元组可以用小括号（），也可以什么也不用，为了可读性，建议还是用（）。此外对于含单个元素的元组，务必记住要多加一个逗号。
#+begin_src python
print(type(('ok')))
print(type(('ok', )))

元组也可以创建二维元组

#+begin_src python
nested = ((1,10,'python'),('data'))
nested
type(nested)
#+end_src

索引和切片

元组中可以用整数来对它进行索引和切片。

#+begin_src python
nested = ((1,10,'python'),('data'))
type(nested)
nested[0]
print(nested[0][0], nested[0][1], nested[0][2])
#+end_src

不可更改

元组具有不可更改性。虽然不可更改，但是可以通过以下方式来更改。

#+begin_src python
t = ('ok',[1,2],True)
t[2] = False

当tuple 只有一个元素时，必须加逗号, 来消除歧义

#+begin_src python
tuple = ('a','b','c','d','e')
tuple[1:3]
tuple[0] = 'A'
tuple = ('A',) + tuple[1:]
tuple

t = ('a','b',['A','B'])
t[2][0] = 'X'
t
#+end_src

但是只要元组中的元素可更改（mutable），那么我们可直接更改其元素。

#+begin_src python
t[1].append(3)
t

元组大小和内容都不可更改，因此只有 count 和 index 两种方法。

#+begin_src python
t = (1,10.31,'python')
t.count('python')
t.index(10.31)

这两个方法返回值都是 1，但意思完全不同。index(10.31) 是找到该元素在元组的索引。
元组拼接
元组拼接有 2 种方式，用 + 和 *，前者首尾拼接，后者复制拼接。

#+begin_src python
(1,10,'python') + ('data',11) + ('ok',)
(1,10,'python') * 2

解压元组

解压（unpack）一堆元组（有几个元素左边括号定义几个变量）
#+begin_src python
t = (1,10,'python')
(a, b, c) = t
print(a,b,c)

解压二维元组（按照元组里的元组结构来定义变量）

#+begin_src python
t = (1,10,('ok', 'python'))
(a,b,(c,d)) = t
print(a,b,c,d)
#+end_src

如果你只想要元组其中几个元素，用通配符*，在计算机语言中代表一个或多个元素，下例就是把多个元素给了 reset 变量。

#+begin_src python
t = 1,2,3,4,5
a,b,*rest,c = t
print(a,b,c)
print(rest)

** 列表（list）
与元组对比，列表的长度可变，内容可以被修改。属于 mutable.

#+begin_src python
tup = ('foo', 'bar')
b_list = list(tup)
b_list
b_list[1] = 'peekaboo'
b_list
#+end_src

附加（append，extend），插入（insert），删除（remove,pop）这些操作都可以用在它身上。

#+begin_src python
l = [1,10,'python']
l.append([4,3])
l
# => [1, 10, 'python', [4, 3]]
l.extend([1,2,'ok'])
l
# => [1, 10, 'python', 1, 2, 'ok']
#+end_src

严格来说 append 是追加，把一个东西整体添加在列表后，而 extend 是扩展，把一个东西里的所有元素添加在列表后。对着上面结果感受一下区别。

** 列表长度

#+begin_src python
len([1,2,3])
#+end_src

*** 笛卡尔积
python 真的很喜欢用 for 循环。

#+begin_src python
colors = ['black', 'white']
sizes = ['S', 'M', 'L']
tshirts = [(color, size) for color in colors for size in sizes]
tshirts
# [('black', 'S'), ('black', 'M'), ('black', 'L'), ('white', 'S'), ('white', 'M'), ('white', 'L')]
#+end_src

** 切片操作
在 python 里，像列表（list）\元组（tuple）\字符串（str）这类序列类型都支持切片操作。

#+begin_src python
  l = [10, 20, 30, 40]
  l[:2]
  # [10, 20]
  l[0:3]
  # [10, 20, 30]
#+end_src

还可以对对象进行切片。可以用 s[a:b:c] 的形式对 s 在 a 和 b 之间以 c 为间隔取值。c 的值还可以为负，负值意味着可以反向取值。

#+begin_src python
  s = 'bicycle'
  s[::3] #间隔为3
  s[1::3]
  # bye
  s[::-1]
  # 'elcycib'
  s[::-2]
  # 'eccb'
#+end_src

给切片赋值

#+begin_src python
  l = list(range(10))
  l
  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  l[2:5] = [20, 30]
  l
  # [0, 1, 20, 30, 5, 6, 7, 8, 9]
  del l[5:7]
  l
  l[3::2] = [11, 22]
  l
  # [0, 1, 20, 11, 5, 22, 9]
  l[2:5] = 100
  l[2:5] = [100]
  l
#+end_src

第一种索引器是 loc 属性，表示取值和切片都是显式。 python 代码的设计原则是“显式优于隐式”。

所以，索引器 loc 只是在 pandas 中应用。

#+begin_src python
import pandas as pd
data = pd.Series(['a', 'b', 'c'], index=[1, 3, 5])
data
data[1]
data[1:3]
data.loc[1]
data.loc[1:3]
#+end_src

** 推导式

#+begin_src python
[x for x in range(5)]
#> [0, 1, 2, 3, 4]

[x + 10 for x in range(10) if x % 2 == 0]
#> [10, 12, 14, 16, 18]
#+end_src

输出表达式：x+10; 数据源迭代：for x in range(10); 过滤表达式：if x % 2 == 0. 推导式还可以直接用作函数调用实参。

#+begin_src python
def test(data):
    print(type(data), data)

test({x for x in range(3)})
#> <class 'set'> {0, 1, 2}
#+end_src

推导式允许有多个 for 子句，每个子句都可选一个 if 条件表达式。

#+begin_src python
[f"{x}{y}" for x in "abc" if x != "c"
           for y in range(3) if y != 0]
#> ['a1', 'a2', 'b1', 'b2']
#+end_src

*** 字典

#+begin_src python
{k:v for k,v in zip("abc", range(10, 13))}
#> {'a': 10, 'b': 11, 'c': 12}
#+end_src

*** 集合

#+begin_src python
{x for x in "abc"}
#> {'a', 'b', 'c'}
#+end_src

** *

#+begin_src python
l = [1, 2, 3]
l * 2
2 * 'abc'
# 'abcabc'
#+end_src

*** 建立由列表组成的列表

    #+begin_src python

    #+end_src

** 聚合
reduce,类似于 R 中的函数。如果需要存储每次计算的中间结果，那么可以使用 accumulate. .sum,np.prod,np.cumsum,np.cumprod 这些函数都可以实现 reduce 的功能。
#+begin_src python
x = np.arange(1, 6)
x
np.add.reduce(x)
np.multiply.reduce(x)
np.multiply.accumulate(x)
** 外积

 #+begin_src python
np.multiply.outer(x, x)
 #+end_src

** 广播
对于同样大小的数组，二进制操作是对相应元素逐个计算：
#+begin_src python
a = np.array([0, 1, 2])
b = np.array([5, 5, 5])
a + b
a = np.array([0, 1, 2])
a + 5

** 统计记录个数
如果需要统计布尔数组中 True 记录的个数，可以使用 np.count_nonzero 函数。
#+begin_src python
X = np.random.random((10, 3))
X.mean(0) #对列进行统计
X.mean(1) #对行进行统计
X < 0.2 #对所有元素进行判断
np.count_nonzero(X<0.2) #统计True 的个数
#+end_src

** value_counts
value_counts() 相当于 dplyr 包中的 count(). 相当于 R 中的 table.具体用法是 df.colName.value_counts().
#+begin_src python
X = np.random.random((10, 3))
X.value_counts()
housing['income_cat'].value_counts()
count.nlargest(2).index
#+end_src

** nlargest

#+begin_src python :results output
count = iris.species.value_counts()
count.nlargest(2)
#+end_src

** 处理缺失值
*** isnull

#+begin_src python
import pandas as pd
df1 = pd.Series([1, np.nan, 2, None])
df1.isnull()
df1[df1.notnull()]
#+end_src

在 series 里使用的 isnull() 和 notnull() 同样适用于 dataframe
*** fillna
df.fillna()

#+begin_src python
df.fillna(0)
#+end_src

*** dropna
分别是 dropna() (剔除缺失值) 和 fillna() (填充缺失值).可以按着行或者列筛选 NA 值。
#+begin_src python
import pandas as pd
df1 = pd.Series([1, np.nan, 2, None])
df1.dropna()

默认情况下，dropna() 会剔除任何包含缺失值的整行数据。
#+begin_src python
df = pd.DataFrame([[1, np.nan, 2],
                  [2, 3, 5],
                  [np.nan, 4, 6]])
df
df.dropna(thresh = len(df)*0.9, axis = "columns")
#+end_src
可以设置按不同的坐标轴剔除缺失值，比如 axis = 1 (或 axis = 'columns') 会剔除任何包含缺失值的整列数据。

只想删除列中缺失值高于10% 的缺失值，可以设置 dropna() 里的阈值。

#+begin_src python
df.dropna(axis='columns')
df.dropna(axis='columns', how='all')
#+end_src

默认设置是 how = 'any',也就是只要有缺失值就是剔除整行或整列（通过 axis 设置座标轴），
还可以设置 how = 'all',这样就只会剔除全部是缺失值的行或列了。

#+begin_src python
df.dropna(axis='rows', thresh=3)
#+end_src

** 合并数据集
*** concat 与 append 操作
numpy 中可以用 np.concatenate 函数将 numpy 数组进行合并。np.vstack np.hstack

#+begin_src python
x = [1, 2, 3]
y = [4, 5, 6]
np.concatenate([x,y])
# array([1, 2, 3, 4, 5, 6])

x = np.array([[1,2],[3,4]])
y = np.array([[5,6],[7,8]])
np.concatenate((x, y), axis = 0) #x,y 纵向叠加合并成4乘2矩阵
np.concatenate((x, y), axis = 1) #x,y 纵向叠加合并成2乘4矩阵
np.vstack((x, y)) #np.concatenate((x, y), axis = 0)
np.hstack((x, y)) #np.concatenate((x, y), axis = 1)
#+end_src
*** pd.concat
这个函数不能将 list 型数据进行合并。 pd.concat(objs, axis=0, join='outer')
#+begin_src python
pd.concat([pd.Series(x),pd.Series(y)],axis=1)
#+end_src

#+begin_src python :results output
l = pd.DataFrame(data=None)
for date in df['cal_date'].values:
     l = pd.concat([l,get_daily(trade_date = date)])
#+end_src

用concat() 函数可以把原dataframe 与新dataframe 组合在一起。

#+begin_src python :results output
pd.concat([df, df_new], axis = 'columns')
#+end_src

*** 伪随机数

生成一个[1,100]以内的随机整数 random.randint(1,100)。

随机生成5个随机小数np.random.randn(5).

0-1 随机小数，random.random(),括号内不传参。

#+begin_src python
import random
random.seed(1010)
random.randint(1, 100)
random.choice([1,2,4,'word'])
random.sample(range(100), 5)
random.random()
#+end_src

** union/intersection/difference
基本模块的集合运算不能直接用于 list，但可以用于通过函数 set()转换的 list,这些计算包括集合的差（difference），并（union），交（intersection）。

#+begin_src python
set(['I', 'you', 'he', 'I'])
#+end_src

#+begin_src python
set.difference(set(['a',2,'5']),set(['a',7]))
set.union(set(['a',2,'5']),set(['a',7]))
set.intersection(set(['a',2,'5']),set(['a',7]))
#+end_src

** eval
和 R 一样，eval 的用法也类似。eval(str_expression)作用是将字符串转换成表达式，并且执行。
#+begin_src python
eval('[1,2,3]')
#> [1, 2, 3]
x = 7
eval('x**2')
#+end_src

** assert

#+begin_src python
a = 3
assert(a>1)
print("断言成功，程序继续向下执行")

b = 4
assert(b>7)
print("断言失败，程序报错")
#+end_src

** 统计
*** 最小值和最大值
#+begin_src python
min(L),max(L)
#+end_src

#+begin_src ipython :session :exports both :results raw drawer
import numpy as np
M = np.random.random((2, 2))
M.sum()
M.min(axis = 0)

from sklearn.preprocessing import MinMaxScaler
#区间缩放，返回值为缩放到[0, 1]区间的数据
minMaxScaler = MinMaxScaler().fit(X_train)
minMaxScaler.transform(X_train)
#+end_src

*** 数组值求和\累积\乘积\差分
#+begin_src python
import numpy as np
L = np.random.random(100)
sum(L)
np.prod(x)
np.cumsum(x)
#+end_src

当数组数据中有缺失值 None 时，就需要借助filter 函数，这点没有R 来的方便。

#+begin_src python :results output
sum(filter(None, [1,2,3,None]))
#+end_src

array 变成矩阵，可以通过限定 shape 来确定矩阵维数。

#+begin_src python
x = np.array([32, -12, 3, 5])
x.shape = 2, 2
np.diff(x, axis=0) #按行差分
np.diff(x, axis=1) #按列差分
#+end_src

*** kronecker 积

#+begin_src python
import numpy as np
A = np.eye(3)
B = np.array([[1,2], [3, 4]])
np.kron(A, B)
#+end_src

*** 舍入运算
在 R 里面是 round(x,6).

#+begin_src python
import numpy as np
x = np.array([1.234, 2.387, 3.673])
np.round(x, 2) #四舍五入
np.around(x, 2)
np.floor(x) #保留整数位
np.ceil(x)
#+end_src

指数，对数，符号函数，绝对值，极值

#+begin_src python
import numpy as np
x = np.array([-2, 7, 9, 6]).reshape(2, 2)
x
np.sign(x)
np.exp(x)
np.log(x)
np.abs(x)
x.max()
np.argmin(x, 0)
#+end_src

arange,range

#+begin_src python
np.arange(3,5,.5) #从3到5(不包含5)等间隔为0.5 的数列
np.arange(4)
# array([0, 1, 2, 3])
#+end_src

点乘法

#+begin_src python
x = np.arange(4,7,.4)
y = np.arange(1,5)
np.dot(x.reshape(len(x), 1),
       y.reshape(1, len(y)))
#+end_src

数组维度大小

#+begin_src python
np.shape(x)
np.shape(y)

转置
#+begin_src python
x = [[2,3],[7,5]]
z = np.asmatrix(x)
z
print(z, type(z))
print(z.transpose()*z)
print(z.T*z)
#+end_src

维数和大小
#+begin_src python
np.ndim(z)
z.shape
#+end_src

*** 画图

#+begin_src python
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import sklearn
def prepare_country_stats(oecd_bli, gdp_per_capita):
    oecd_bli = oecd_bli[oecd_bli["INEQUALITY"]=="TOT"]
    oecd_bli = oecd_bli.pivot(index="Country", columns="Indicator", values="Value")
    gdp_per_capita.rename(columns={"2015": "GDP per capita"}, inplace=True)
    gdp_per_capita.set_index("Country", inplace=True)
    full_country_stats = pd.merge(left=oecd_bli, right=gdp_per_capita,
                                  left_index=True, right_index=True)
    full_country_stats.sort_values(by="GDP per capita", inplace=True)
    remove_indices = [0, 1, 6, 8, 33, 34, 35]
    keep_indices = list(set(range(36)) - set(remove_indices))
    return full_country_stats[["GDP per capita", 'Life satisfaction']].iloc[keep_indices]

##load data
url1 = "https://raw.githubusercontent.com/WillKoehrsen/Hands-On-Machine-Learning/master/handson-ml-master/datasets/lifesat/oecd_bli_2015.csv"
oecd_bli = pd.read_csv(url1, thousands=',')

url2 = 'https://raw.githubusercontent.com/ageron/handson-ml/master/datasets/lifesat/gdp_per_capita.csv'
gdp_per_capita = pd.read_csv(url2, thousands=',', delimiter='\t', encoding='latin1',na_values="n/a")

#prepare the data
country_stats = prepare_country_stats(oecd_bli, gdp_per_capita)
x = np.c_[country_stats['GDP per capita']]
y = np.c_[country_stats['Life satisfaction']]

##visualize the data
country_stats.plot(kind='scatter', x="GDP per capita", y='Life satisfaction')
plt.show()
#+end_src

*** 线性模型

#+begin_src python
##load data
url1 = "https://raw.githubusercontent.com/WillKoehrsen/Hands-On-Machine-Learning/master/handson-ml-master/datasets/lifesat/oecd_bli_2015.csv"
oecd_bli = pd.read_csv(url1, thousands=',')

url2 = 'https://raw.githubusercontent.com/ageron/handson-ml/master/datasets/lifesat/gdp_per_capita.csv'
gdp_per_capita = pd.read_csv(url2, thousands=',', delimiter='\t', encoding='latin1',na_values="n/a")

#prepare the data
country_stats = prepare_country_stats(oecd_bli, gdp_per_capita)
x = np.c_[country_stats['GDP per capita']]
y = np.c_[country_stats['Life satisfaction']]

##visualize the data
country_stats.plot(kind='scatter', x="GDP per capita", y='Life satisfaction')
plt.show()

#select a linear model
lin_reg_model = sklearn.linear_model.LinearRegression()

#train the model
lin_reg_model.fit(x,y)
#Make a prediction for cyprus
x_new = [[22587]]
print(lin_reg_model.predict(x_new))
#+end_src

#+begin_src python
np.random.seed(1010)
X = np.random.randn(100, 3)
X1 = np.hstack((np.ones((100, 1)),X))
y = np.random.randn(100)
beta,SSR,rank,sv = np.linalg.lstsq(X, y)
beta
#+end_src

*** lasso
    #+begin_src python
      from sklearn import linear_model
      clf = linear_model.Lasso(alpha=0.1)
      clf.fit([[0, 0],
               [1, 1],
               [2, 2]],
              [0, 1, 2])
      clf.coef_
      clf.intercept_
    #+end_src

** 数据清理
*** 数字型变量
删除缺失值，删除一个特征，将缺失值填充为一个固定值。
#+begin_src python
housing.dropna(subset=['total_bedrooms']) #option 1 可以理解为删除缺失值
housing.drop('total_bedrooms', axis=1)  #删除一个特征
median = housing['total_bedrooms'].median()
housing['total_bedrooms'].fillna(median)
#+end_src
*** 字符串和文本
**** 使用多个界定符分割字符串
#+begin_src ipython :session :exports both :results raw drawer
line ='asdf fjjdk; afed, fjek'
import re
fields = re.split(r'[;,\s]\s*', line)
values = fields[::2]
delimiters = fields[1::2] + ['']
**** 字符串开头或结尾匹配
检查字符串开头或结尾的一个简单方法是使用 str.startswith() 或者是 str.endswith() 方法。比如：

#+begin_src ipython :session :exports both :results raw drawer
filename = 'spam.txt'
filename.endswith('.txt')
filename.startswith('file:')
url = 'http://www.python.org'
url.startswith('http')

如果想检查多种匹配可能，只需要将所有的匹配项放入到一个元组中去，然后传给 startswith() 或者 endswith() 方法：
#+begin_src ipython :session :exports both :results raw drawer
import os
filenames = os.listdir(".")
filenames[0:2]
[name for name in filenames if name.endswith(('.org'))] #展示以 org 结尾的文件名称
any(name.endswith('.py') for name in filenames) #判断目录下是否有py 文件
**** 用 shell 通配符匹配字符串

#+begin_src ipython :session :exports both :results raw drawer
from fnmatch import fnmatch,  fnmatchcase
fnmatch('foo.txt', '*.txt')
fnmatch('foo.txt', '?oo.txt')
fnmatch('Dat45.csv', 'Dat[0-9]*')
**** 字符串搜索和替换
#+begin_src ipython :session :exports both :results raw drawer
text = 'yeah, but no'
text.replace('yeah', 'yep')

对于复杂的模式，需要使用 re 模块中的 sub() 函数。
#+begin_src python
##LabelBinarizer 类可以一次性完成两个转换
from sklearn.preprocessing import LabelBinarizer
encoder = LabelBinarizer()
housing_cat_1hot = encoder.fit_transform(housing_cat)
housing_cat_1hot
#+end_src

** 类
Python 从设计之初就已经是一门面向对象的语言，正因为如此，在 Python 中创建一个类和对象是很容易的。
根据类来创建对象被称为实例化。一个简单的样例如下：使用类几乎可以模拟任何东西。下面一个简单的例子是模拟小狗，对于多数小狗，都会有名字和年龄，那么创造一个类就会包含这两个信息。
#+begin_src python
class Dog():
    """一次模拟小狗的简单尝试"""

    def __init__(self, name, age):
        """初始化属性name和age"""
        self.name = name
        self.age = age

    def sit(self):
        """模拟小狗被命令时蹲下"""
        print(self.name.title() + " is now sitting.")

    def roll_over(self):
        """模拟小狗被命令时打滚"""
        print(self.name.title() + " rolled over!")
#+end_src

在 python 中，首字母大写的名称就是类。这个类定义中的括号是空的。

#+begin_src python
print("RMSE: %f" % (rmse))
#+end_src

** 面向对象技术简介

*类(Class):* 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。

*方法：* 类中定义的函数。

类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。

数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。

方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。

局部变量：定义在方法中的变量，只作用于当前实例的类。

实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。

继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个 Dog 类型的对象派生自 Animal 类，这是模拟"是一个（is-a）"关系（例图，Dog 是一个 Animal）。

实例化：创建一个类的实例，类的具体对象。

对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。

类的定义：
#+begin_src python
class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
#+end_src

实例化类其他编程语言中一般用关键字 new，但是在 python 中并没有这个关键字，类的实例化类似函数调用方式。

类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。

类对象：

类对象支持两种操作：属性引用和实例化。属性引用使用和 python 中所有的属性引用一样的标准语法：obj.name.类对象创建后，类命名空间中所有的命名都是有效属性名。所有如果类定义是这样类的方法与普通函数只有一个特别的区别，它们必须有一个额外的第一个参数名称，按照惯例它的名称为 self。

在 python 中，可以使用点 . 来访问对象的属性，也可以使用以下函数的方式来访问属性：

- getattr(obj, name) 访问对象的属性

- hasattr(obj, name) 检查是否存在一个属性

#+begin_src python :results output
class myclass(object):
    def __init__(self):
        self.foo = 100

myinst = myclass()
hasattr(myinst, 'foo')
getattr(myinst, 'foo')
hasattr(myinst, 'bar')
getattr(myinst, 'bar')
setattr(myinst, 'bar','my attr')
getattr(myinst,'bar')
delattr(myinst, 'bar')
getattr(myinst, 'bar')

- setattr(obj, name, value) 设置一个属性，如果属性不存在，会创建一个新属性,存在的话，会覆盖掉原来的属性值。

- delattr(obj, name) 删除属性

python 内置类属性：

__dict__：类的属性（包含一个字典，由类的数据属性组成）

__doc__：类的文档字符串

__name__：类名

__module__：类定义所在的模块

__bases__：类的所有父类构成的元素（包含了一个由所有父类组成的元组）。

#+begin_src python
class MyClass:
    i = 12345
    def f(self):
        return 'hello world'

#实例化
x = MyClass()

##访问类的属性和方法
print('MyClass 类的属性 i 为：', x.i)
print('MyClass 类的方法 f 输出为：', x.f())

python 对象销毁（垃圾回收）：python 使用了引用计数这一简单技术来跟踪和回收垃圾。在 python 内部记录着所有使用中的对象各自有多少引用。一个完整的 python 类例子是：
#+begin_src python
class Employee:
    '所有员工的基类'
    empCount = 0

    def __init__(self, name, salary):
        self.name = name
        self.salary = salary
        Employee.empCount += 1

    def displaycount(self):
        print("Total Employee %d" % Employee.empCount)

    def displayEmployee(self):
        print("Name:", self.name, ", Salary:", self.salary)

print("Employee.__doc__:", Employee.__doc__)
print("Employee.__name__:", Employee.__name__)
print("Employee.__module__:", Employee.__module__)
print("Employee.__bases__:", Employee.__bases__)
print("Employee.__dict__:", Employee.__dict__)

类定义了__init__() 方法可以有参数，参数通过__init__()传递到类的实例化操作上的。

#+begin_src python
class Complex:
    def __init__(self, realpart, imagpart):
        self.r = realpart
        self.i = imagpart

x = Complex(3, -4.5)
print(x.r, x.i)

self 代表类的实例，而非类

#+begin_src python
class Test:
    def prt(self):
        print(self)
        print(self.__class__)

t = Test()
t.prt()

类的方法：

#+begin_src python
#类定义
class people:
    #定义基本属性
    name = ''
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print("%s 说: 我 %d 岁。" %(self.name,self.age))

# 实例化类
p = people('runoob',10,30)
p.speak()

*** 继承

python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下：

#+begin_src python
class DerivedClassName(BaseClassName1):
    <statement-1>
    .
    .
    .
    <statement-N>
#+end_src

BaseClassName(示例中的基类名)必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时非常有用。

#+begin_src python
#类定义
class people:
    #定义基本属性
    name = ''
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print("%s 说: 我 %d 岁。" %(self.name,self.age))

#单继承示例
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print("%s 说: 我 %d 岁了，我在读 %d 年级"%(self.name,self.age,self.grade))

s = student('ken',10,60,3)
s.speak()
#+end_src

** 转义
** Packages
*** seaborn
**** get_dataset_names()
获取dataset 名称。
#+begin_src python
import seaborn as sns
sns.get_dataset_names()
#+end_src
**** load_dataset

#+begin_src python
import seaborn as sns
flight_data = sns.load_dataset('flights')
#+end_src

*** sklearn
**** MinMaxScaler

#+begin_src python
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(-1,1))
train_data_normalized = scaler.fit_transform(train_data.reshape(-1,1))
#+end_src



*** dplython
这个包类似于 dplyr.
**** select

#+begin_src python
import pandas
from dplython import (DplyFrame, X, diamonds, select, sift, sample_n,
    sample_frac, head, arrange, mutate, group_by, summarize, DelayFunction)

diamonds >> select(X.carat) >> head
     #+end_src

     #+begin_src python
    #+begin_src python
class Car():
    """一次模拟汽车的简单尝试"""
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_descriptive_name(self):
        long_name = str(self.year) + " " + self.make + " " + self.model
        return long_name.title()

    def read_odometer(self):
        print("this car has " + str(self.odometer_reading) + " miles on it.")

    def update_odometer(self, mileage):
        if mileage >= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print("You can't roll back an odometer!")

    def increment_odometer(self, miles):
        self.odometer_reading += miles

class ElectricCar(Car):
    """电动车的独特之处"""
    def __init__(self, make, model, year):
        """初始化父类的属性"""
        super().__init__(make, model, year)


my_tesla = ElectricCar('tesla', 'model s', 2016)
print()
#+end_src

**** filter
在 python 中，filter 是 sift.

#+begin_src python
diamonds >> sift(X.carat > 4) >> select(X.carat, X.cut,
                                        X.depth, X.price)
#+end_src

在python 中，要像dplyr 那样优雅的处理数据，得load dply。

#+begin_src python :results output
from dplython import (DplyFrame, X, diamonds, select, sift,
  sample_n, sample_frac, head, arrange, mutate, group_by,
  summarize, DelayFunction)

price_data >> mask(price_data.name == "金徽酒")
price_data[price_data.name.str.contains("金徽酒")].sort_values(by = ["decrease_ratio","max_high"])
#+end_src

**** sample
随机抽样。

#+begin_src python
diamonds["column w/spaces"] = range(len(diamonds))
diamonds >> \
select(X["column w/spaces"])
#+end_src

#+begin_src python
diamonds.sample(100)
diamonds.sample(frac=0.2)
#+end_src

把dataframe 分为两个随机子集，一个占75%的数据量，另一个25%.

使用drop() 方法可以快速删掉price_data 中一部分数据。

#+begin_src python :results output
diamonds.sample(frac=0.2, random_state=1234)
temp1 = price_data.sample(frac=0.5,random_state=1234)
price_data.drop(temp1.index).shape
#+end_src

**** arrange

 #+begin_src python
 diamonds >> arrange(X.carat)
     #+end_src
这个函数不能实现降序。可以用下面这个函数实现。
     #+begin_src python
 diamonds >> sample_n(10)
 #+end_src

**** mutate
mutate 新建一列数据。
     #+begin_src python
 diamonds >> \
mutate(carat_bin = X.carat.round())
     #+end_src

以下语句可以实现相同的功能。

#+begin_src python
diamonds.sort_values("carat", ascending=False)
#+end_src

mutate by group

#+begin_src python
 diamonds.groupby('cut').apply(lambda x: np.mean(x.price)).reset_index(level=0, drop=True)
#+end_src
**** distinct
#+begin_src python
import pandas
from dplython import (DplyFrame, X, diamonds, select, sift, sample_n,
    sample_frac, head, arrange, mutate, group_by, summarize, DelayFunction)
diamonds.assign(carat_bin = diamonds.carat.round()).head()
#>    Unnamed: 0  carat      cut color clarity  depth  table  price     x     y  \
# 0           1   0.23    Ideal     E     SI2   61.5   55.0    326  3.95  3.98
# 1           2   0.21  Premium     E     SI1   59.8   61.0    326  3.89  3.84
# 2           3   0.23     Good     E     VS1   56.9   65.0    327  4.05  4.07
# 3           4   0.29  Premium     I     VS2   62.4   58.0    334  4.20  4.23
# 4           5   0.31     Good     J     SI2   63.3   58.0    335  4.34  4.35

#       z  carat_bin
# 0  2.43        0.0
# 1  2.31        0.0
# 2  2.31        0.0
# 3  2.63        0.0
# 4  2.75        0.0
#+end_src

#+begin_src python
diamonds.drop_duplicates()
df.drop_duplicates(subset='col1') # returns dataframe with unique values of col1
 diamonds.drop_duplicates("cut")
#+end_src

**** group_by

#+begin_src python
import pandas
from dplython import (DplyFrame, X, diamonds, select, sift, sample_n,
    sample_frac, head, arrange, mutate, group_by, summarize, DelayFunction)
diamonds >> \
mutate(carat_bin=X.carat.round()) >> \
group_by(X.cut, X.carat_bin) >> \
summarize(avg_price=X.price.mean()) >> \
head
# #>     cut  carat_bin     avg_price
# 0  Fair        0.0   1027.979275
# 1  Fair        1.0   3305.754579
# 2  Fair        2.0   9588.269737
# 3  Fair        3.0  13466.823529
# 4  Fair        4.0  15842.666667
#+end_src

**** T
转置。
     #+begin_src python
diamonds >> select(X.carat, X.cut) >> head >> X._.T
     #+end_src
*** reprex
类似于 R 中的 reprex.
#+begin_src python
from reprexpy import reprex
reprex()
#+end_src
*** pipe
管道符 |

#+begin_src python :results output
from pipe import *
[1,2,3,4] | where (lambda x:x%2) | tail(2) | select(lambda x: x*x) | add
#+end_src

*** pytorch
为啥选择pytorch?

- Pytorch中最重要的就是Variable模块，该模块集成了围绕一个张量所有的操作，包括前向传播、反向传播的各种求偏导数的数值。

- Pytorch所有的网络在nn包里，我们待会会实现经典的Lenet5模型。

- Pytorch计算GPU和CPU切换很快，直接使用x.cuda()即可

#+begin_src ipython :session :exports both :results raw drawer
import torch
import numpy as np
torch.tensor([[1, -1], [1, -1]])
torch.tensor(np.array([[1, 2, 3], [4, 5, 6]]))
#+end_src

#+begin_src python
from __future__ import print_function
import torch
x = torch.Tensor(5, 3)
x = torch.rand(5, 3)
x
x.size()
y = torch.rand(5, 3)
x + y
torch.add(x, y)
x[:, 1]

#Numpy 桥
a = torch.ones(5)
b = a.numpy()
a.add_(1)
b

#将numpy 的array 转换为torch的tensor
import numpy as np
a = np.ones(5)
b = torch.from_numpy(a)
np.add(a, 1, out=a)
b

if torch.cuda.is_available():
x = x.cuda()
y = y.cuda()
x + y

from torch.autograd import Variable
x = Variable(torch.ones(2, 2), requires_grad = True)
#+end_src

一些简单的例子

#+begin_src python
import torch
N,D_in,H,D_out = 64, 1000, 100, 10

#随机创建一些训练数据
x = torch.randn(N, D_in)
x.shape
y = torch.randn(N, D_out)
y.shape

w1 = torch.randn(D_in, H)
w2 = torch.randn(H, D_out)

learning_rate = 1e-6
for it in range(500):
    #forward pass
    h = x.mm(w1) #N*H
    h_relu = h.clamp(min=0) #N*H
    y_pred = h_relu.mm(w2)

    #compute loss
    loss = (y_pred - y).pow(2).sum().item()
    print(it, loss)

    #backward pass
    #compute the gradient
    grad_y_pred = 2 * (y_pred - y)
    grad_w2 = h_relu.t().mm(grad_y_pred)
    grad_h_relu = grad_y_pred.mm(w2.t())
    grad_h = grad_h_relu.clone()
    grad_h[h<0] = 0
    grad_w1 = x.t().mm(grad_h)

    #update weights of w1 and w2
    w1 -= learning_rate * grad_w1
    w2 -= learning_rate * grad_w2



import torch
N,D_in,H,D_out = 64, 1000, 100, 10

#随机创建一些训练数据
x = torch.randn(N, D_in)
x.shape
y = torch.randn(N, D_out)
y.shape

w1 = torch.randn(D_in, H,requires_grad=True)
w2 = torch.randn(H, D_out, requires_grad=True)

learning_rate = 1e-6
for it in range(500):
    #forward pass
    y_pred = x.mm(w1).clamp(min=0).mm(w2)
    #compute loss
    loss = (y_pred - y).pow(2).sum()
    print(it, loss.item())
    #backward pass
    loss.backward()
    #update weights of w1 and w2
    with torch.no_grad():
        w1 -= learning_rate * w1.grad
        w2 -= learning_rate * w2.grad
        w1.grad.zero_()
        w2.grad.zero_()
#+end_src


** python 习题

https://leetcode-cn.com/circle/discuss/wOEKvB/

这个习题答案是。

#+begin_src python :results output
import numpy as np
m = 50
n = 10
for i in range(int(np.floor(m/10)+1)):
    for j in range(int(np.floor(((m-10*i)+1)/5))):
        for k in range(int(np.floor(((m-10*i-5*j)+1)/2))):
            l = m-10*i-5*j-2*k
            if i+j+k+l == n and l>=0:
                print(i,j,k,l)
#+end_src

** 数据结构

*** 线性表

线性表是最常用且最简单的一种数据结构，它是 $n$ 个数据元素的有限序列。

实现线性表的方式一般有两种，一种是使用数组存储线性表的元素，即用一组连续的存储单元依次存储线性表的数据元素。另一种是使用链表存储线性表的元素，即用一组任意的存储单元存储线性表的数据元素（存储单元可以是连续的，也可以是不连续的）。

*** 链表

链表的结构：链表像锁链一样，由一节节节点连在一起，组成一条数据链。
链表的节点的结构如下： data next data为自定义的数据，next为下一个节点的地址。 链表的结构为，head保存首位节点的地址：

*** hash表

数组能够通过下标O(1) 访问，但是删除一个中间元素却要移动其他元素，时间O(n).

能不能给每个元素一种逻辑下标，然后直接找到它呢，hash 表就是这种实现？它通过一个hash 函数来计算一个元素应该放在数组哪个位置，当然对于一个特定的元素，哈希函数每次计算的下标必须要一样才可以，而且范围不能超过给定的数组长度。

假设有一个数组T, 包含 $M=13$ 个元素，可以定义个简单的hash 函数。

#+begin_src python :results output
h(key) = key % M
#+end_src

假设需要插入765, 431, 96, 142, 579, 226, 903, 388 元素，可以先计算下它们应用哈希函数的结果。

#+begin_src python :results output
M = 13
h(765) = 765 % M = 11
h(431) = 431 % M = 2
h(96) = 96 % M = 5
h(142) = 142 % M = 12
h(579) = 579 % M = 7
h(226) = 226 % M = 5
h(903) = 903 % M = 6
h(388) = 388 % M = 11
#+end_src


**** hash 冲突

如果有2个值均是一样，那么就有了哈希冲突（collision），如果有了冲突，这么解决呢？可以用一种链接法。

链接法的思想就是如果有了冲突，可以让数组中对应的槽变成一个链式结构。

https://python-data-structures-and-algorithms.readthedocs.io/zh/latest/07_%E5%93%88%E5%B8%8C%E8%A1%A8/hashtable/

具体可看上面那个链接。

还有一种开放寻址法，基本思想就是当一个槽被占用的时候，采用一种方式来寻找下一个可用的槽。
