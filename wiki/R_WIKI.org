#+TITLE: R_wiki
#+OPTIONS: TeX:t LaTeX:t TOC:nil
#+latex_class: article
#+latex_compiler: xelatex
#+OPTIONS: author:nil email:nil creator:nil timestamp:nil html-postamble:nil

#+begin_quot
这个文档专门用于记录 R 语言在使用过程中的心得体会，避免今后 coding 的重复劳动。
#+end_quote

* 问题
 
** 如何快速地删除确定的行？
** 如何对两个不同长度的向量作 map2?
比如：c("1","2","3"),c("1","2")month 想要得到 c("11","12","21","22","23")

#+begin_src R ::results output graphics :file fig_1.png :exports both
  purrr::cross(list("1","2","3"),list("1","2"))
  library(tidyverse)
  list(
      c("1","2","3"),
      c("1","2")
  ) %>% cross() %>% 
      map(lift(str_c))
#+end_src

* 0 R 语言编程规范

缩进：使用两个空格来缩进，不要用 tab 键（制表符），当括号内发生换行时，另起一行与括号内的第一个字符对齐。

空格：只使用单空格，在二元操作符和操作数之间插入空格，不要在函数名称和参数列表之间添加空格。

块：左括号“{”不能独占一行，右括号"}"应该独占一行。块内部的代码用两个空格缩进。

命名：用小写字母命名对象，并用句号分隔。

** 帮助文档
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  help.start() #打开帮助文档首页
  help("foo") #或？foo 查看函数foo的帮助
  help.search("foo") #或？？foo 以foo为关键词搜索本地帮助文档
  example("foo")
  example("lapply") #函数lapply 的使用示例 
  RSiteSearch("foo")                                      #以foo为关键词搜索在线文档和邮件
  apropos("foo",mode = "function") #列出名称中含有foo 的所有可用函数
  data()#列出当前已加载包中所含有的所有可用示例数据集
  vignette() #列出当前已安装包中所有可用的vignette文档
  vignette("foo") #为主题foo 显示指定的vignette 文档
#+END_SRC

** TODO 工作空间

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
getwd() #显示当前的工作目录
setwd() #修改当前的工作目录为mydirectory
ls()    #列出当前工作空间中的对象
rm(objectlist)  #移除（删除）一个或多个对象
help(options)   #显示可用选项的说明
options()       #显示或设置当前的选项
history(#) #显示最近用过的＃个命令（默认值为25）
savehistory("myfile") #保存命令历史到文件myfile 中（默认值为.Rhistory）
loadhistory("myfile") #载入一个命令历史文件（默认值为.Rhistory）
save.image("myfile")  #保存工作空间到文件myfile 中（默认值为.RData）
save(objectlist,file = "myfile") #保存指定对象到一个文件中
load("myfile") #读取一个工作空间到当前会话中（默认值为.RData）
q() #退出R.
#+END_SRC

** 输入和输出
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
source("filenames") #可在当前会话中执行一个脚本
sink("filenames",append = TRUE,split = TRUE) #将输出重定向到文件filename 中，如果文件已经存在，则它的内容将被覆盖，使用参数append=TRUE 可以将文本追加到文件后，而不是覆盖它，参数split=TRUE 可将输出同时发送到屏幕和输出文件中。

pdf("filename.pdf") #pdf 文件
win.metafile("filename.wmf") #windows 图元文件
png("filename.png") #png文件
jpeg("filename.jpg") #jpeg 文件
bmp("filename.bmp") #bmp 文件
postscript("filename.ps") #postscript 文件
#+END_SRC

** Rstudio vim 快捷键
谁用谁知道～

| 功能                  | 快捷键 |
| 查询函数              | K      |
| 将命令发送到 terminal | ctrl+alt+Enter |

* R 环境配置
** 重要的开始文件地址
 R_HOME 是安装 R 的文件地址。HOME 是用户的 home 文件。
 #+begin_src R :results output graphics :file fig_1.png :exports both 
   file.edit(file.path("~",".Rprofile")) # edit .Rprofile in HOME
   file.edit(".Rprofile") # edit project specific .Rprofile
 #+end_src

 #+begin_src R :results output graphics :file fig_1.png :exports both 
   user_renviron = path.expand(file.path("~", ".Renviron")) if(!file.exists(user_renviron)) # check to see if the file already exists

                                                                file.create(user_renviron) file.edit(user_renviron) # open with another text editor if this fails  
 #+end_src

 #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
   ## delete all saved object
   rm(list = ls())
   gc()
   library(rlang)
   library(tidyverse)
   library(tidyr)
   library(nycflights13)
   ## rscodeio::install_theme() #vs样式的界面
   library(data.table)
   library(styler) # 代码美观
   library(lintr) # 检查代码错误
   library(languageserver)
   options()#设置或检验全局参数；常用参数有：width，digits,error
   ls() #显示搜索路径下对象；指定 path=“path”时，按样式条件搜索。
   ls.str()#搜索路径下每个变量
   dir()#在当前的目录下显示文件 = list.files()
   help(languageserver)
   ## only style with scope = "spaces" when using the Addin
   options(
     styler.addins_style_transformer = "styler::tidyverse_style(scope = 'spaces')"
   )
                                         # Get a List of all files named with a key word, say all `.csv` files
   filenames <- ist.files("C:/your/folder", pattern = glob2rx("*.csv"), full.names = TRUE)
                                         # Load and bind all data sets
   data <- rbindlist(lapply(filenames, fread))
 #+END_SRC
** 获取错误信息
可以用 try 来获取错误信息。
 #+begin_src R :results output graphics :file fig_1.png :exports both 
   good=try(1+1,silent = T)
   good
   bad=try(1+"1",silent = T)
   bad
   if(class(bad) == "try-error")
    ## do something  
 #+end_src
** Rprofile 文件 
#+begin_src R :results output graphics :file fig_1.png :exports both 
  file.edit(file.path("~", ".Rprofile")) # edit .Rprofile in HOME
  file.edit(".Rprofile") ## edit project specific .Rprofile 
#+end_src
** .Renviron ﬁle
  #+begin_src R :results output graphics :file fig_1.png :exports both 
    user_renviron = path.expand(file.path("~", ".Renviron"))
    if(!file.exists(user_renviron)) # check to see if the file already exists
        file.create(user_renviron)
    file.edit(user_renviron) # open with another text editor if this fails    
  #+end_src

* 1 常见 R 函数
** 显示对象个数

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  x <- 1
  y <- 2
  z <- 3
  objects()
#+END_SRC
*** 搜索对象
apropos() 函数可以在全局环境空间中搜索所有可用对象。当不能确切想起函数名称时，这
个函数特别有用。
#+begin_src R :results output graphics :file fig_1.png :exports both 
  apropos("str_")  
#+end_src

dir() 函数可以列出一个目录下的所有文件。dir() 函数的 pattern 参数可以是一个正则
表达式，此时它只返回与这个模式相匹配的文件名。
#+begin_src R :results output graphics :file fig_1.png :exports both 
  dir(pattern = "\\.Rmd$")  
#+end_src

** 删除某个对象

   #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
     rm(x)
     objects()
   #+END_SRC

** 向环境中添加/删除对象
   
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
     attach() #将数据框添加到R 的搜索路径中
     detach(name,pos = 2,unload = FALSE)
detach("package:tidyverse",unload = TRUE)
#+END_SRC

** 捕获错误

   #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
     res <- try({x <- 1},silent = TRUE)
     res
     res <- try({open("file that doesn't exist")},silent = TRUE)
     res
   #+END_SRC

** 改变其他环境

*** 用户目录

    #+begin_src R :results output graphics :file fig_1.png :exports both 
      normalizePath('~') #显示用户目录      
    #+end_src

 <<-操作符，var <<- value。它会使解释器首先在当前环境中检索寻找符号 var。如果解释器无法在当前环境中找到符号 var，那么接下来就会在父环境中继续寻找。解释器将这样递归地在各个环境中寻找直到找到该符号或达到全局环境。

 #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
   rm(x)
   doesnt.assign.x <- function(i) {x <- i}
   doesnt.assign.x(4)
   x
   assign.x <- function(i){x <<- i}
   assign.x(4)
   x
 #+END_SRC

** namespace 概念 
命名空间（NAMESPACE）是 R 包管理包内对象的一个途径，它可以控制哪些 R 对象是对用户可见的，哪些对象是从别的包导入（import），哪些对象从本包导出（export）。为什么要有这么个玩意儿存在？主要是为了更好管理你的一堆对象。写 R 包时，有时候可能会遇到某些函数只是为了另外的函数的代码更短而从中抽象、独立出来的，这些小函数仅仅供你自己使用，对用户没什么帮助，他们不需要看见这些函数，这样你就可以在包的根目录下创建一个 NAMESPACE 文件，里面写上 export(函数名)来导出那些需要对用户可见的函数。自 R 2.14.0 开始，命名空间是 R 包的强制组成部分，所有的包必须有命名空间，如果没有的话，R会自动创建。

前面我们也提到 DESCRIPTION 文件中有 Imports 一栏，这里设置的包通常是你只需要其部分功能的包，例如我只想在我的包中使用 foo 包中的 bar()函数，那么 Imports 中就需要填 foo，而 NAMESPACE 中则需要写 importFrom(foo, bar)，在自己的包的源代码中则可以直接调用 bar()函数，R会从 NAMESPACE 看出这个 bar()对象是从哪里来的。

** profiling
   #+begin_src R :results output graphics :file fig_1.png :exports both 
     library(profvis)
     profvis(expr = {
                                        # Stage 1: load packages 
         library("rnoaa") 
         library("ggplot2")
                                        # Stage 2: load and process data 
         out = readRDS("data/out-ice.Rds") 
         df = dplyr::rbind_all(out, id = "Year")
                                        # Stage 3: visualise output
         ggplot(df, aes(long, lat, group = paste(group, Year))) + geom_path(aes(colour = Year))
         ggsave("figures/icesheet-test.png")
     }, interval = 0.01, prof_output = "ice-prof")       
   #+end_src
** 科学计算
   #+begin_src R :results output graphics :file fig_1.png :exports both 
     x <- 1:9; names(x) <- x
     # Multiplication & Power Tables
     x %o% x
     ## 1  2  3  4  5  6  7  8  9
     ## 1 1  2  3  4  5  6  7  8  9
     ## 2 2  4  6  8 10 12 14 16 18
     ## 3 3  6  9 12 15 18 21 24 27
     ## 4 4  8 12 16 20 24 28 32 36
     ## 5 5 10 15 20 25 30 35 40 45
     ## 6 6 12 18 24 30 36 42 48 54
     ## 7 7 14 21 28 35 42 49 56 63
     ## 8 8 16 24 32 40 48 56 64 72
     ## 9 9 18 27 36 45 54 63 72 81
     outer(1:9,1:9)     
   #+end_src
** paste
sep 用来横向拼接向量，比如把第一个向量和第二个向量按元素顺序逐对拼起来，而 collapse 是把一个向量内部所有元素按一个分隔符拼接为单个字符串。总结一下，sep 返回的仍然是一个向量，每个元素是所有向量中的相应位置上的元素拼出来的；而 collapse 把字符向量“坍缩”为一个字符串。
   #+begin_src R :results output graphics :file fig_1.png :exports both 
     paste(1:3, "a")
     ## [1] "1 a" "2 a" "3 a"
     paste(1:3, "a", sep = "-")
     ## [1] "1-a" "2-a" "3-a"
     paste(letters[1:10], collapse = "~")
     ## [1] "a~b~c~d~e~f~g~h~i~j"
     paste(1:3, "a", sep = "-", collapse = "+")
     ## [1] "1-a+2-a+3-a"
   #+end_src
** cat
Concatenate and Print.
#+begin_src R :results output graphics :file fig_1.png :exports both 
  iter <- stats::rpois(1, lambda = 10)
  ## print an informative message
  cat("iteration = ", iter <- iter + 1, "\n") %>% str()
                                        #> iteration =  13 
                                        #>  NULL  
#+end_src
* 2 导入数据
** fread/fwrite
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  library(data.table)
  modelpath <- "/home/work/rstudio-home/luyajun/project/project/juxinli_fqz"
  fread("/home/work/rstudio-home/luyajun/project/main_model_ws_cluster/rh_model/train_woe_data.csv", integer64 = "character", data.table = F)
  fwrite(app, "/home/work/rstudio-home/luyajun/mifi_model_test/model/main_model/app.csv")
  fwrite(app, sprintf("%s/dataset_sep.csv", modelpath))
  fread(sprintf("%s/dataset_sep.csv", modelpath), integer64 = "character", data.table = F)
#+END_SRC

** spark_read_parquet/spark_write_parquet

此函数可以迅速将 spark object 存储到 hdfs 上

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  spark_write_parquet(sdf_data3, path = "/user/h_data_platform/platform/mifi/mifimodel_antifraud_jxl_rule_replace_br/data", mode = "overwrite") #需注意sdf_data3必须是一个spark object
  hj_parser=spark_read_parquet(sc, "hj_parser",path = sprintf("%s/hujin_parser_1017", hdfs_report_path), memory = F)
  sdf_data <- spark_read_csv(sc, "sdf_data",path = sprintf("%s/data1.csv", hdfs_report_path)) #表名应该要取
#+END_SRC

** spark_read_csv/spark_write_csv

   #+begin_src R :results output graphics :file fig_1.png :exports both 
     spark_read_csv(sc, name = "sdf_ri_6_30_data", memory = F, overwrite = T, delimiter = "\t",
                    path = "/user/h_mifi/user/luyajun/data/label_6_30_reject_model/label_all_score.csv")     
   #+end_src
注意在 spark_write_csv 函数中，path 是一个文件夹名称，而非文件本身名称，而且这个文件夹不能提前在 hdfs 中新建！
   #+begin_src R ::results output graphics :file fig_1.png :exports both
     df_hj_feature %>% 
         sdf_repartition(1) %>%
         spark_write_csv(path = sprintf("%s/hujin_data_validate_data_1_30_20191101_20200223",hdfspath))     
   #+end_src
** get_file_from_hdfs/push_file_to_hdfs

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  hdfs_data_path <- "/user/h_mifi/user/luyajun/data/data/model/cluster"
  get_file_from_hdfs(sprintf("%s/train_cluster_data.csv", hdfs_data_path), modelpath)
  "/user/h_mifi/user/luyajun/data/bairong")
  #注意push_file_to_hdfs 必须这样的形式！！
  push_file_to_hdfs(sprintf("%s/model_data.csv", modelpath), "/user/h_mifi/user/luyajun/model/pboc/data/data/model_data.csv")
  ###获取hdfs数据并转换为本地数据
hdfs 被误删数据到下面这个路径去寻找!!
  /user/h_mifi/.Trash/Current/user/h_mifi/user/luyajun

  
  ###TODO:回头试试！！！
  mf_load_remote_to_local_cluster(hdfs_path, local_path,
                                  num_partitions = 50)
#+END_SRC
*** 读取一个文件夹下多个 csv 文件

    #+begin_src R ::results output graphics :file fig_1.png :exports both
      raw_data = bind_rows(lapply(
          list.files(path = sprintf("%s/train_data_hj_zc_um_tx_br_09m_12m", modelpath), pattern = "*.csv"), 
          function(x){fread(file = sprintf("%s/train_data_hj_zc_um_tx_br_09m_12m/%s", modelpath, x) , integer64 = "character", data.table = F)}))      
    #+end_src

* 3 数据处理
** 宽表处理
*** 常用宽表查询地址
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  mf_dm_data_library()
  mf_dm_data_library() %>% pull(hdfs_path) %>% str_match("fact")
#+END_SRC

这部分因为工作原因，所以特别添加。
*** 读取 jason 数据
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  hujin <- spark_read_parquet(sc, name = "hujin", path = "/user/h_mifi/user/jiyue/output_anti_fraud_blacklist_query_log", memory = F) %>% filter(date >= 20190801 & date <= 20190924 & source == 44)
  head(hujin %>% select(response),2) #快速看下jason数据结构
#+END_SRC

jason 的数据形式很像 Python 中的字典型数据。
![jason_data](img/jason_data.PNG)

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  ###利用get_json_object命令完成变量提取-------------------------------
  hujin_parser <- hujin %>%
      mutate(
          xiaomi_id = get_json_object(response, "$.entity.xiaomiId"),
          create_time = get_json_object(response, "$.entity.createTime"),
          update_time = get_json_object(response, "$.entity.updateTime"),
          data = get_json_object(response, "$.entity.data")
      )
#+END_SRC

*** 利用 sparklyr 对 spark 中的 dataframe 复制行

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  df_tbl %>% 
      mutate(arr = explode(array(1, 1, 1))) %>%  #复制3行
      select(-arr)
                                        #or同样操作
  library(rlang)
  df_tbl %>%  
      mutate(arr = !!rlang::parse_quo(
                                paste("explode(array(", paste(rep(1, 3), collapse = ","), "))")
                            )) %>% select(-arr)
  
                                        #参考链接 https://stackoverflow.com/questions/44530564/r-how-to-replicate-rows-in-a-spark-dataframe-using-sparklyr

#+END_SRC

*** 本地数据框转成 hdfs
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  ###这个应该很快--------------------------------------------
  to_sdf(df, sc, repartition = NULL, ncores = 12, part_size = 512)
#+END_SRC

*** 本地数据转化成 h2o frame

据说这个函数比 as_h2o_frame 快很多
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  my_as_h2o_frame(df, use_parquet = F)
#+END_SRC

*** sdf_solidate
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  ##saves an sdf to a parquet on hdfs and then read it back as a new sdf. This is useful to avoid spark OOM in situations where the spark workflow is too long.
  my_sdf_solidate(sdf)
#+END_SRC

*** hdfs.load
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  hdfs.load(path)#Arguments,path:an hdfs path to a .rda file
#+END_SRC

** 数据类型转换
list to matrix:注意在 list to matrix 过程中，字符型变量也会转换为数字型
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  list1=data.frame(x1=c(1,2,3,3,2,1),x2=letters[1:6])
  list2mat <- function(data){
    output <- matrix(unlist(data), ncol = dim(data)[2])
    return(output)
  }
  list2mat(list1)
  data.matrix(list1)
#+END_SRC

***  数据切分
可以利用 purrr 包进行数据切分。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  ins
  typeof(mtcars$gear)
  mtcars %>%
    split(.$cyl)
#+END_SRC

***  重塑数据(reshape data)

melt:这个函数可以将 data.frame 数据拉直
tibble:构建一个数据框
gather：可以将多列原始数据进行合并，按照一定组名，这样可以更好 ggplot2
spread：将一列数据分割成多列，多用于 char 型数据
unite:是 spread 的逆操作，可以将多个序列连接起来

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
ceshi <- tibble(a = 1:3, b = 4:6) # 构建一个数据框
ceshi
melt(ceshi) # 将数据框拉直
melt(smiths)
dcast(smiths, time + subject ~ .)
stocks <- tibble(
  time = as.Date("2009-01-01") + 0:9,
  X = rnorm(10, 0, 1),
  Y = rnorm(10, 0, 2),
  Z = rnorm(10, 0, 4)
)
##这里变量的值是一个维度，把值全部拉直
head(stocks)
s <- gather(stocks, "stock", "price", -time) # 这里 stock 涉及了组，也就是 key，price 是值,value
  head(s)

more example

## Section:如果数据长度一样
################################################
score <- data.frame(score1 = c(1, 2, 3), score2 = c(2, 3, 4))
melt(score, measured = c("score1", "score2"))
gather(score, "score", "value") # 这样就能实现分组
score <- list(score1 = c(1, 2, 3), score2 = c(2, 3, 4, 5))
score <- data.frame(score1 = c(1, 2, 3, NA), score2 = c(2, 3, 4, 5))
###列的合并--------------------------
# 合并列
## unite()直接使用列名即可，unite_()需要在列名两边使用引号
iris %>% head
#构造了一个新的变量 unite_sepal，根据 sepal.length，Sepal.Width 两个变量进行合并
demo <- iris %>%
  unite(unite_sepal, Sepal.Length, Sepal.Width, sep="_", remove=TRUE) %>%
  unite_("unite_petal", c("Petal.Length", "Petal.Width"), sep="_", remove=TRUE)
#separate 是 unite 的逆操作
demo %>%
  separate(unite_sepal, c("Sepal.Length", "Sepal.Width"), sep="_") %>%
  separate_("unite_petal", c("Petal.Length", "Petal.Width"), sep="_")
## Section:如果数据长度不相同
################################################
library(rowr)
score <- cbind.fill(score1 = c(1, 2, 3), score2 = c(2, 3, 4, 5), fill = NA)
colnames(score) <- c("score1", "score2")
a <- gather(score, "score", "value") # 这样就能实现分组
a %<>% as.tibble()
str(a)
head(a)
ggplot(a, aes(x = score, y = value, colour = score)) + geom_point(aes(score, value))
stroms <- tibble(date=c("2019,01,01"))
tidyr::separate(stroms,date,c("y","m","d"))

s %>%
  separate(price, c("stock", "price"))
gather()
separate()
df <- data.frame(x = c(NA, "a.b", "a.d", "b.c"))
head(df)
df %>% separate(x, c("A", "B")) # 将字符分隔开了

df <- data.frame(x = c("a:1", "a:2", "c:4", "d", NA))
df %>%
  separate(x, c("key", "value"), ":") %>%
  str()
df %>%
  separate(x, c("key", "value"), ":", convert = TRUE) %>%
  str()

df <- expand_grid(x = c("a", NA), y = c("b", NA))
df

df %>% unite("z", x:y, remove = FALSE)

# Implicit missings ---------------------------------------------------------
df <- tibble(
  year    = c(2010, 2010, 2010, 2010, 2012, 2012, 2012),
  qtr     = c(   1,    2,    3,    4,    1,    2,    3),
  return = rnorm(7)
)
df %>% expand(year, qtr)
df %>% expand(year = 2010:2012, qtr) #加了一年的数据
df %>% expand(year = full_seq(year, 1), qtr)
df %>% complete(year = full_seq(year, 1), qtr) #相当于对原有数据做了扩充
full_seq(c(2010,2010,2011),1) #相当于去重了
# You can also choose to fill in missing values
df <- tibble(
  group = c(1:2, 1),
  item_id = c(1:2, 2),
  item_name = c("a", "b", "b"),
  value1 = 1:3,
  value2 = 4:6
)
df
df %>% nesting(item_id)
df %>% complete(group, nesting(item_id, item_name))
df %>% complete(group, nesting(item_id, item_name), fill = list(value1 = 0))
###啥叫 nest?--------------------------
df <- tibble(x = c(1, 1, 1, 2, 2, 3), y = 1:6, z = 6:1)
df
# Note that we get one row of output for each unique combination of
# non-nested variables
#这个操作是把两个变量数据连接成 list 类型，把 x 作了去重处理，留下了 y 和 z 的信息
(df %>% nest(data = c(y, z)))$data
# chop does something similar, but retains individual columns
(df %>% chop(c(y, z)))$z
# use tidyselect syntax and helpers, just like in dplyr::select()
# one_of("")是可以替换 select 的功能
(df %>% nest(data = one_of("y", "z")))$data
iris %>% select(Species) %>% unique()
(iris %>% nest(data = -Species))$data #可以将数据按照一个类别进行分组
iris %>%
  nest(petal = starts_with("Petal"), sepal = starts_with("Sepal"))
iris %>%
  nest(width = contains("Width"), length = contains("Length"))
# Nesting a grouped data frame nests all variables apart from the group vars
fish_encounters %>%
  group_by(fish) %>%
  nest()
# Nesting is often useful for creating per group models
mtcars %>%
  group_by(cyl) %>%
  nest() %>%
  mutate(models = lapply(data, function(df) lm(mpg ~ wt, data = df)))
# unnest() is primarily designed to work with lists of data frames
df <- tibble(
  x = 1:3,
  y = list(
    NULL,
    tibble(a = 1, b = 2),
    tibble(a = 1:3, b = 3:1)
  )
)
df
df %>% unnest(y)
df %>% unnest(y, keep_empty = TRUE)
# You can unnest multiple columns simultaneously
df <- tibble(
  a = list(c("a", "b"), "c"),
  b = list(1:2, 3),
  c = c(11, 22)
)
df %>% unnest(c(a, b))
# Compare with unnesting one column at a time, which generates
                                        # the Cartesian product
df %>% unnest(a) %>% unnest(b)
df %>% unnest(a)

#+END_SRC

***  非标准计算

流程：read-eval-print 是读入文本，然后进行解析，然后求值，最后打印，这个就是我们日常看到的命令行操作。

- 语法解析：substitute(), parse(), deparse()
- 表达式构造：quote()
- 表达式求值：eval(), source()
- 表达式：expression()

**** Base 包 
***** parse 
parse 主要负责把字符解析为 R 语言表达式。表达式是可以被求值的代码。
在 R 中解析有三种不同的变种：

- the read-eval-print loop
- parsing of text files
- parsing of character strings   

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
parse(text = "1+2")
parse(text = "1+2") %>% class
#+END_SRC

***** deparse
和 parse 相反，deparse 是把 R 表达式逆解析为字符。

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
deparse(1+1=2)
#+END_SRC

***** quote
quote 则是用于捕捉未计算的表达式。

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
quote(1+2)
quote(1+2) %>% typeof
                                        #  "language"
#+END_SRC

***** eval
quote 是捕捉表达式，不进行计算（求值），将由 eval 来完成对表达式进行计算（求值）。

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
eval(quote(1+2))
#+END_SRC

一般是用 parse 从字符串（或者是硬盘上的文件）解析成一个 expression 对象，是表达式列表，不是一个表达式。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
eval(parse(text = "1+2"))
#+END_SRC

表达式的操作和计算
在 eval 遇到未定义的变量时首先是全局环境，如果有指定环境，则进入指定环境找，还会根据需要找到子环境的父环境中去。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  q <- quote(1+2)
  q
  as.list(q)
                                        #下面可以操作这个表达式，变成1-2
  q[[1]]
  q[[1]] <- `-`
  q
  eval(q)
                                        #下面操作可以变成1*2
  q[[1]] <- quote(`*`)

  eval(quote(1+a)) #如果被计算对象没有找到，那么计算就会出错
  a <- 2
  eval(quote(1+a))
                                        #即使变量是存在的，但是如果变量换了新环境，直接计算也是错误的
  new <- new.env()
  new$b <- 2
  eval(quote(1+b))
                                        # Error in eval(quote(1 + b)) : object 'b' not found
  eval(quote(1+b),envir = new)
                                        #父环境与子环境
  son <- new.env(parent = new)
  son$c <- 3
  eval(quote(1+b+c)) #Error in eval(quote(1 + b + c)) : object 'b' not found
  eval(quote(1+b+c),envir = new) #Error in 1 + b + c : non-numeric argument to binary operator
  eval(quote(1+b+c),envir = son)

#+END_SRC

more example

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  rm(list = ls())
  a1 <- quote(mean(mtcars$wt))
  a1 #mean(mtcars$wt)
  a2 <- expression(mean(mtcars$wt))
  a2 #expression(mean(mtcars$wt))
  a3 <- parse(text = "mean(mtcars$wt)")
  a3 #expression(mean(mtcars$wt))
  all.equal(a1,a2)
                                        #[1] "Modes of target, current: call, expression"
  #[2] "target, current do not match when deparsed"
  all.equal(a1,a3)
  all.equal(a2,a3)# [1] "Attributes: < target is NULL, current is list >"
                                        #[2] "current is not list-like"
a3[1]
  a3[[1]]
  all.equal(a1,a3[[1]])
                                        #对表达式进行求值
  eval(a1)
  eval(a2)
  eval(a3)
  deparse(a1) #"mean(mtcars$wt)"
  deparse(a2)
  deparse(a3)
#+END_SRC

先看一个例子：
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  library(magrittr)
  df <- tibble(x = 1:3, y = 3:1)
  filter(df, x == 1)
  my_var <- x                                        #> Error in eval(expr, envir, enclos): object 'x' not found
  filter(df, my_var == 1)
                                        #> Error: object 'my_var' not found
#+END_SRC

明明 my_var 是 x，但是 filter 就是不起作用。再举一个例子：

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  greet <- function(name) {
    "How do you do, name?"
  }
  greet("Hadley") #这个 name 变量不起作用
#+END_SRC

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  mutate_y <- function(df) {
    mutate(df, y = a + x)
  }
  df1 <- tibble(x = 1:3)
  a <- 10
  mutate_y(df1)
#+END_SRC

近期在做聚信力多头规则替换时，发现此方法可以解决 fro 循环问题，真的十分方便。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  sdf_first_provider_mean_score <- eval(parse(text=paste0("list(", paste0("sdf_data_provider %>% select(time, first_provider_name,second_provider_name,score) %>%filter(time==",date,") %>% mutate(score=as.numeric(score)) %>% group_by(first_provider_name) %>% summarise(mean_score_",str_sub(date,5,8),"=mean(score,na.rm = TRUE)%>% round(3))",collapse = ','),paste0(")"))))

  ## 可以配合seq进行使用可以处理vector类型数据，以达到for循环的效果
  first_provider_mean_score_left_join <- eval(parse(text=paste0(paste0("sdf_first_provider_mean_score[[1]]"), paste0(" %>% left_join(sdf_first_provider_mean_score[[",seq(2,length(date)),"]],by = 'first_provider_name')") %>% paste(collapse = "")))) %>% my_sdf_collect()
#+END_SRC
一般情况下，上述查询语句的等价于下面查询语句，可以看出真的很长。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
# first_provider_score_mean <- data.frame(
#   sdf_data_provider %>% select(time, first_provider_name,second_provider_name,score) %>%
#   filter(time=="20191203") %>%
#   mutate(score=as.numeric(score)) %>%
#   group_by(first_provider_name) %>%
#   summarise(mean_score_12_03=mean(score,na.rm = TRUE)%>% round(3)),
#   sdf_data_provider %>% select(time, first_provider_name,second_provider_name,score) %>%
#   filter(time=="20191204") %>%
#   mutate(score=as.numeric(score)) %>%
#   group_by(first_provider_name) %>%
#   summarise(mean_score_12_04=mean(score,na.rm = TRUE)%>% round(3)),
#   sdf_data_provider %>% select(time, first_provider_name,second_provider_name,score) %>%
#   filter(time=="20191205") %>%
#   mutate(score=as.numeric(score)) %>%
#   group_by(first_provider_name) %>%
#   summarise(mean_score_12_05=mean(score,na.rm = TRUE)%>% round(3)),
#   sdf_data_provider %>% select(time, first_provider_name,second_provider_name,score) %>%
#   filter(time=="20191206") %>%
#   mutate(score=as.numeric(score)) %>%
#   group_by(first_provider_name) %>%
#   summarise(mean_score_12_06=mean(score,na.rm = TRUE)%>% round(3)),
#   sdf_data_provider %>% select(time, first_provider_name,second_provider_name,score) %>%
#   filter(time=="20191207") %>%
#   mutate(score=as.numeric(score)) %>%
#   group_by(first_provider_name) %>%
#   summarise(mean_score_12_07=mean(score,na.rm = TRUE)%>% round(3))) %>% select(first_provider_name,mean_score_12_03,mean_score_12_04,mean_score_12_05,mean_score_12_06,mean_score_12_07)
#+END_SRC
**** tidyeval
***** quo
主要是为了方便传递表达式，更好地写函数。
比如，有一个场景：给一个数据集 df,对指定变量 a 进行分组，然后对指定变量 b 进行求均值。如果这个场景只是出现一次，那么写几行命令实现一下需求就跳过去了。如果在分析中多次遇到这一场景，那么这个时候最好的办法就是写一个 group_mean 函数，在需要的时候就可以直接调用，简洁，易读，减少代码的复制粘贴。

Quosure- an expression that has been saved with on environment.a quosure can be evalued an expression that with on environment. 

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  a <- 1
  b <- 2
q <- quo(a+b)
  q
  qs <- quos(a,b)
  rlang::parse_expr(a)
  group_mean <- function(data,group_var,mean_var,varnames){
      data %>%
          group_by(!!group_var) %>%
          summarise(!!varnames :=mean(!!mean_var))
  }

  group_mean(data=mtcars,
             group_var=quo(cyl),
             mean_var=quo(mpg),
             varnames="mpg")

#+END_SRC

!!是表示 *立即对表达式求值，* 与 quo 搭配使用。使用 rlang 非标准计算涉及到＝时需要写成:=。在调用 group_mean 时还需要写 quo,这个看起来比较麻烦，不够简洁。可以利用 enquo 重新定义这个函数。

The bang-bang operator \(!!\) forces a single object. One common case for \(!!\) is to substitute an
environment-variable (created with \(<-)\) with a data-variable (inside a data frame).也就是说!!varnames 会提醒 R 替换数据变量，变成环境变量。

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  second_provider_mean_score_date <- function(date,varnames){
  data_provider %>% select(time, first_provider_name,second_provider_name,score) %>% 
  filter(time==date) %>% 
  mutate(score=as.numeric(score)) %>% 
  group_by(second_provider_name) %>% 
  summarise(!!varnames:=mean(score,na.rm = TRUE))
}
slist <- list()
for(i in 1:5){
slist[[i]]<- second_provider_mean_score_date(date[i],paste0("mean_score_",date[i]))  
}
slist[[1]] %>% 
  left_join(
  slist[[2]],by = "second_provider_name"
)%>% left_join(
  slist[[3]],by = "second_provider_name"
)%>% left_join(
  slist[[4]],by = "second_provider_name"
)%>% left_join(
  slist[[5]],by = "second_provider_name"
  ) %>% as.data.frame() %>% group_by(mean_score_20191205)%>% arrange(desc(mean_score_20191205))%>% kable(caption = "2019年12月3日至7日second_provider各渠道人群score均值变化情况")
#+END_SRC
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
group_mean <- function(data,group_var,mean_var,varnames){
group_var_e <- enquo(group_var)
mean_var_e <- enquo(mean_var)
  data %>%
      group_by(!!group_var_e) %>%

          summarise(!!varnames :=mean(!!mean_var_e))
  }
  group_mean(data=mtcars,
             group_var=cyl,
             mean_var=mpg,
             varnames="mpg")
#+END_SRC
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
library(dplyr)
var=sym("height")
var %>% typeof()
#var <- parse(text = "height")
starwars %>%
    summarise(avg = mean(!!var,na.rm = TRUE))
#+END_SRC
The big-bang operator !!! forces-splice a list of objects.

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
vars <- syms(c("height", "mass"))

# Force-splicing is equivalent to supplying the elements separately
starwars %>% select(!!!vars)
starwars %>% select(height, mass)
#+END_SRC

***** parse_expr()
rlang::parse_expr() convert a string to an expression.
parse_exprs 是 parse_expr 的加强版，可以处理多个字符串。在 eval_tidy 函数之外，还有轻量级的 eval,就是 eval_bare.
两个函数差别不大，eval_bare 不能接收数据，eval_tidy 可以接收数据。

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
 #ggplot::results output graphics,plot::results graphics 
 library(rlang)
 library(dplyr)
  e <- parse_expr("a+b")
  parse_expr("mean(mtcars$wt)") %>% eval_tidy()
  parse_exprs("mean(mtcars$wt); mean(mtcars$am)") %>% eval_tidy()
  parse_expr("mean(mtcars$wt)") %>% eval_bare() #如果不涉即新的数据，就可以使用eval_bare,如果需要用到数据，那么就需要用eval_tidy 进行求值
  parse_expr("mean(wt)") %>% eval_tidy(data=mtcars)
 parse_expr("mean(wt)") %>% eval_bare() #Error in mean(wt) : 找不到对象'wt'
 #+END_SRC

***** exec

To call a function with arguments stored in a list (if the function doesn't support dynamic dots). Splice the list of arguments with !!!.

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
 args <- list(x=c(1:10,100,NA),na.rm = TRUE)
 args
  exec("mean",!!!args)
  fs <- list(a = function()"a",b = function()"b")
fs
  lapply(fs,exec)
                                        # Compare to do.call it will not automatically inline expressions
                                        # into the evaluated call.
  x <- 10
  args <- exprs(x1 = x+1,x2 = x*2)
  exec(list,!!!args)
  do.call(list,args) #可以看出do.call 直接可以给出变量数值
  f <- disp~cyl
  exec("lm",f,data = mtcars)
#+END_SRC

***** f_rhs
f_rhs extracts the righthand side, f_lhs extracts the lefthand side, and f_env extracts the environment. All functions throw an error if f is not a formula.

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  f_rhs(~ 1 + 2 + 3)
                                        #> 1 + 2 + 3
  f_rhs(~ x)
  #> x
  f_rhs(~ "A")
                                        #> [1] "A"
  f_rhs(1 ~ 2)
                                        #> [1] 2

  f_lhs(~ y) 
  f_lhs(x ~ y)
  f_env(~ x)
#+END_SRC

***** expr_text()
expr_text() turns the expression into a single string, which might be multi-line.
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
fn <- function(x) expr_label(substitute(x))
fn(x:y)
                                        # Strings are encoded
expr_label("a\nb")

                                        # Names and expressions are quoted with ``
expr_label(quote(x))
                                        #> [1] "`x`"
expr_label(quote(a + b + c))


#+END_SRC

***** new_formula

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  new_formula(quote(a), quote(b))
  new_formula(NULL,quote(b))
#+END_SRC



***** call2

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
library(rlang)
  arg <- list(x=4,base=2)
  log(x=4,base = 2)
  call2("log",x=4,base=2)
#+END_SRC

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  quo(g1)
  quo(a+b+c)
  quo("a")
  my_summarise(df,quo(g1))
  my_summarise <- function(df, group_var) {
    df %>%
      group_by(!! group_var) %>%
      summarise(a = mean(a))
  }
  df <- tibble(
    g1 = c(1, 1, 2, 2, 2),
    g2 = c(1, 2, 1, 2, 1),
    a = sample(5),
    b = sample(5)
  )
  my_summarise(df,quo(g1))#这就可以了！！！

df %>% group_by(g1) %>% summarise(mean(a))
  my_summarise(df,g1)
#+END_SRC

parse 函数用于解析文件，解析字符串就是 parse 中用 text 参数表示。deparse 是相反的，是把 R 表达式逆解析为字符。
parse: covert a string to a saved expression.

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  parse(text = "1+2")
  parse(text = "1+2") %>% class()
  parse(text = "1+2") %>% typeof()
  deparse(expression(1 + 2))
#+END_SRC
quote 则是用于捕捉未计算的表达式。

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  quote(1 + 2)
  quote(1 + 2) %>% typeof()
  quote(1 + 2) %>% class()
#+END_SRC

- eval 来完成对表达式进行计算（求值）

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  eval(quote(1 + 2))
  eval(parse(text = "1+2"))
#+END_SRC

一般是用 parse 从字符串（或者是硬盘上的文件）解析成一个 expression 对象，是表达式列表，而后使用 eval()函数对表达式求解。

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  q <- quote(1 + 2)
  q <- as.list(q)
  q <- "-"
  q
  eval(parse(q))
  q
#+END_SRC

# 3 描述性统计
## 数据值预览
```{r}
data <- data.frame(score1 = rnorm(100), score2 = rnorm(100))
head(data)
str(data)
data %>% head(10) #显示前 10 行
data %>% tail(-1) #减去第一行
data %>% tail(10) #显示后 10 行
```
## 缺失值分析
在 sparklyr 中，常用 na.replace()函数对缺失值进行插补。
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
data <- data.frame(score1 = c(1, 2, 3), score2 = c(2, 3, 4))
inspect_na(data) #require inspect package
###删除缺失值
data1 <- data.frame(x=c(NA,1,2))
drop_na(data1) #删除 NA 值
data <- data.frame(x=c(NA,1,2),y=c(1,2,NA))
data %>% head
## x  y
## 1 NA  1
## 2  1  2
## 3  2 NA
###drop_na--------------------------
data %>% drop_na(x,y) #只保留全为非空的数值行
data %>% drop_na(x) #删除 x 为 NA 的行
###缺失值填补--------------------------
##Currently either "down" (the default), "up", "downup" (i.e. first down and then up) or "updown" (first up and then down)
data %>% fill(x,.direction = c("updown")) #根据最靠近下面的数值来填充插补
data %>% replace_na()
?replace_na
data <- tibble(x=c(1,2,NA),y=c("a",NA,"b"))
###缺失值填充--------------------------
replace_na(data,replace = list(x=1,y="down"))
## A tibble: 3 x 2
## x y
## 1 a
## 2 down
## 1 b
df <- tibble(
  group = c(1:2, 1),
  item_id = c(1:2, 2),
  item_name = c("a", "b", "b"),
  value1 = 1:3,
  value2 = 4:6
)
###more examples--------------------------
num_mean <- mean(data$num, na.rm = TRUE)
type_mode <- as.character(data$type[which.max(table(data$type))])
data <- replace_na(data = data, replace = list(num = num_mean, 
                                                 + type = type_mode))
#+END_SRC

** 单变量分析
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  summary(data)                                        # return min,1st quantile,median,mean,3rd quantile, max
  library(moments)
  skewness(data) #偏度
  kurtosis(data) #峰度
  ##summary statisics
  mystats <- function(x,na.omit=FALSE){
      if(na.omit)
          x=x[!is.na(x)]
      m=mean(x)
      n=length(x)
      s=sd(x)
      skew=sum((x-m)^3/s^3)/n
      kurt=sum((x-m)^4/s^4)/n-3
      return(c(n=n,mean=m,stdev=s,skew=skew,kurtosis=kurt))
  }
  mystats(data.matrix(data))
  sapply(data, mystats) #return statstics
  library(Hmisc)
  describe(data) #可以知道缺失值
  library(pastecs)
  stat.desc(data,basic=T,desc = T,norm = T,p=0.95) #可以知道 NA 个数
  missmap(data, main = "Missing values vs observed")
  sapply(data, function(x) length(unique(x))) #
  sapply(data,function(x) sum(is.na(x))) #缺失值个数
#+END_SRC

** 多变量分析
*** 二维列联表
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  ##可以生成 SAS 形式的结果
  library(gmodels)
  CrossTable(data$score1,data$score2) #生成 CrossTable
  ##dplyr 形式
  case_when(mtcars$carb <= 2 ~ "low",
            mtcars$carb > 2 ~ "high") %>% table
  ###compelete-------------------------- 
  ###这个函数可以快速插入几个特征,其他特征插入自然均为 0
  df <- tibble(
      group = c(1:2, 1),
      item_id = c(1:2, 2),
      item_name = c("a", "b", "b"),
      value1 = 1:3,
      value2 = 4:6
  )
  df
  df %>% complete(group, nesting(item_id, item_name)) %>% dim
  expand(mtcars, vs, cyl)#相当于 select 功能
  mtcars %>% colnames()
                                        # Only combinations of vs and cyl that appear in the data
  expand(mtcars,nesting(vs,cyl))
#+END_SRC
*** 三维列联表 
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  xtabs(~score1,data = data)
  ftable(xtabs(~score1,data = data))
#+END_SRC

*** 卡方独立性检验
chisq.test()函数可以对二维表的行变量和列变量进行卡方独立性检验。
探讨的是样本的行变量与列变量是相互独立的概率。如果 P 值很小，那么就会拒绝原假设，原假设是两个样本之间相互独立。

***  二变量关系
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  library(car)
  states=as.data.frame(state.x77[,c("Murder","Population","Illiteracy")])
  scatterplotMatrix(states,spread=FALSE,lty.smooth=2)
#+END_SRC

* 4 字符型数据
** 常见函数
   #+begin_src R :results output graphics :file fig_1.png :exports both 
nchar("a") #char size
     
   #+end_src
** 字符大小写
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  x <- "Mixed cAsE 124"
  tolower(x) # 字符全部小写
  toupper(x) # 字符全部大写
#+END_SRC

** 字符串取子集
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  substr("abcdef", 2, 4)
  substring("abcdef", 2,6)
  substring("abcdef", 1:6)
  substring("abcdef", 1:6, 1:6)
  str_sub("abcdef", 2, 4) #和 substr 一样的效果
  str_sub("abcdef", -3, -1) #附属表示从后往前数
  x="Sbcdef"
  str_sub(x, 1, 1) <- str_to_lower(str_sub(x, 1, 1))#可以用 str_sub()函数的赋值形式来修改字符串
  x <- c("123456789", "abcdefghijklmnopq")
  substr(x, c(2, 4), c(4, 5, 8))
  substring(x, c(2, 4), c(4, 5, 8))
#+END_SRC

*** 返回字符数
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  nchar("你好吗？")
  str_length("你好吗？") #这两个函数相同
  length("你好吗？") # 字符串的长度为 1
#+END_SRC

*** 正则表达式匹配
比如：字符 a 是否包括在字符 b 中
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  x <- c("apple", "banana", "pear")
  str_view(x, "an")
  grep("an",x,?an) # 返回 false，true
  grep("[pe]",x) #只要有 p/e 字符都返回 true
  a <- c("as", "abcd", "bcd", "1_bcd")
  b <- c("bcd")
  c <- c("ads")
  grepl(b, a) # 返回 false，true
  grep(b, a) # 在 x 中搜索某种模式。若 fixed=FALSE，则 pattern 为一个正则表达式，返回的是元素的位置
  grep(b, a, ?bcd) # 搜索以 bcd 结尾的字符串
  grep("A", c("b", "A", "c")) # 前一个参数是子集，后一个参数是全集
#+END_SRC

给出一个更为复杂的例子
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  x <- c("a_X01", "b_X02", "c_X01")
  y <- c("a", "b")
  target <- gsub("_X[0-9]+", "", x) # 匹配 x 和 y
  intersect(y, target) # 得出和 y 相匹配的字符
#+END_SRC

涉及到具体位置的匹配可以用 regexpr、gregexpr 和 regexec 三个函数进行匹配：
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  text <- c("Hellow, Adam!", "Hi, Adam!", "How are you, Adam.")
  regexpr("Adam", text) #精确返回
  gregexpr("Adam", text)#和 regexpr 一样，它 return 的是 list 型
  regexec("Adam", text)
#+END_SRC

- 锚点

锚点在正则匹配中的作用就是快速定位字母位置。使用方法是：

^从字符串开头进行匹配；$从字符串末尾进行匹配。除此之外，还有其他模式的匹配选项，包括：

\d 可以匹配任意数字；\s 可以匹配任意空白字符（如空格、制表符和换行符）；[abc]可以匹配 a、b 或 c；[^abc]可以匹配除 a、b、c 外的任意字符。想创建包含\d 或\s 的正则表达式，需要在字符串中对\进行转义，因此需要输入"\\d"或"\\s".除此之外，字符选项可以创建多个可选的模式，例如，abc|d..f 可以匹配 abc 或 deaf.

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  x <- c("apple", "banana", "pear")
  str_view(x, "^a")
  str_view(x,"r$")
  str_view(x,"a$")
  y <- c("summarize","summary","rowsum")
  str_view(y,"\bsum\b")
  y <- c("summarize","summary","dsums","rowsum")
  str_view(y,"\bsum\b")
  str_view(c("grey","gray"),"gr(e|a)y")
#+END_SRC

正则表达式还有一项功能能够重复匹配字符多次
?：0次或 1 次；+：1次或多次；*：0次或多次；{n}：匹配 n 次；{n,}：匹配 n 次或更多次；{,m}：最多匹配 m 次；{n,m}：匹配 n 到 m 次。

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  x <- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"
  str_view(x,"CC?")
  str_view(x,"CC+")
  str_view(x,"C[LX]+")
  str_view(x,"C{2}")
  str_view(x,"C{2,}")
  str_view(x,"C{2,3}")
#+END_SRC

默认的匹配方式是"贪婪的"：正则表达式会匹配尽量长的字符串，通过在正则表达式后面添加一个?，可以将匹配方式更改为“懒惰的”，即匹配尽量短的字符串。
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  str_view(x,"C{2,3}?") #只匹配到 2 个 CC
  str_view(x,"C[LX]+?") #只匹配到 CL
  str_view(x,"^.*$")
  str_view(x,"\\{.+\\}")
  y <- "1888 is the longest year in R\\\\.w\\\\oman numerals: MDCCCLXXXVIII"
  str_view(y,"\\{.+\\}")
  str_view(y,"\\\\{2}")
#+END_SRC

*** 分组与回溯引用
括号还可以定义“分组”，可以通过回溯引用（如\1,\2）来引用这些分组。

*** 字符串替换
sub:在 x 中搜索 pattern，并以文本 replacement 将其替换。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
txt <- c("The", "licenses", "for", "most", "software", "are",
         "designed", "to", "take", "away", "your", "freedom",
         "to", "share", "and", "change", "it.",
         "", "By", "contrast,", "the", "GNU", "General", "Public", "License",
         "is", "intended", "to", "guarantee", "your", "freedom", "to",
         "share", "and", "change", "free", "software", "--",
         "to", "make", "sure", "the", "software", "is",
         "free", "for", "all", "its", "users")
sub("\\s", ".", "Hello There") #将中间的空格替换成.
(ot <- sub(pattern = "[b-e]",replacement = ".", txt)) #txt中
sub(pattern = "b|e", replacement = ".", txt) #只做一次替换
gsub(pattern = "b|e", replacement = ".", txt) #把满足条件的匹配全做替换
#+END_SRC

可以利用 chartr 替换特定的字符模式
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  x <- "Mixed cAsE 124"
  chartr("iXs", "why", x) # 只要x中含有"iXs"，那么就更换为"why".
  chartr("a-cX", "D-Fw", x)
#+END_SRC

*** 字符串排序
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  x <- c("apple", "eggplant", "banana")
  str_sort(x, locale = "en") # 按照英语字母的顺序排序
#+END_SRC

*** 字符串拆分
在 split 处分割字符向量 x 中的元素。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  strsplit("abc", "") # 将字段分裂成"a" "b" "c"
  strsplit("a_b","_") #可以将“a_b”分拆成 “a”和“b”
#+END_SRC

*** 字符串连接
主要有三种函数可以解决这个问题：paste、str_c、sprintf、glue 四个函数。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  paste("x", 1:3, sep = "")
  paste("x-", 1:3,"-y", sep = "")
  paste("x-", c(1,NA),"-y", sep = "")
  name <- "Hadley"
  time_of_day <- "morning"
  birthday <- FALSE
  paste("Good ", time_of_day, " ", name,if (birthday) " and HAPPY BIRTHDAY",".")
  paste("Good ", time_of_day, " ", name,if (birthday) " and HAPPY BIRTHDAY",".",sep = "")
  str_c("x",1:3)
  str_c("x",1:3,sep = "")
  str_c("x-", c(1,NA),"-y", sep = "") #return "x-1-y" NA,这点和paste结果不同
  str_c("Good ", time_of_day, " ", name,if (birthday) " and HAPPY BIRTHDAY",".") #和paste相比，str_c函数默认sep=""
  str_c(c("x", "y", "z"), sep = ", ") #return "x" "y" "z"
  str_c("x", "y", "z", sep = ", ") #如果想用sep实现相同的结果，只需要把向量c()去掉
  str_c(c("x", "y", "z"), collapse = ", ") #return "x, y, z",collapse可以将字符向量合并为字符串
  typeof(sprintf("x%d", 1:16))
  d <- 1:16
  glue::glue("x{d}")
#+END_SRC

more example
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  library(glue)
  name <- "Fred"
  age <- 50
  anniversary <- as.Date("1991-10-12")
  glue(
      "My name is {name},",
      " my age next year is {age + 1},",
      ' my anniversary is {format(anniversary, "%A, %B %d, %Y")}.'
  )
#+END_SRC

glue_data() 可以和 magrittr 的管道函数一起用 %>% .
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
mtcars %>% head
  head(mtcars) %>% glue_data("{rownames(.)} has {hp} hp")
  ## Mazda RX4 has 110 hp
  ## Mazda RX4 Wag has 110 hp
  ## Datsun 710 has 93 hp
  ## Hornet 4 Drive has 110 hp
  ## Hornet Sportabout has 175 hp
  ## Valiant has 105 hp
#+END_SRC

*** 字符串重编码

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  x <- rep(1:3, 3)
  recode(x, "c(1,2)='A'; 	else='B'")
#+END_SRC

*** 字符串转为命令

试想一个应用场景就是，在作 glm 拟合时，如果变量数很多，而且只需要提取部分变量作回归，那么需要把入模的变量提取出来进行建模。这时，利用 paste 将变量连接起来就变得很重要了。

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  x <- 1:10
  a <- "print(x)"
  class(a)
  eval(parse(text = a))
                                        # more example
  traindata = final_onehot_train_samples %>% select(feat_model) %>%
      bind_cols(train_test$train %>% select(label,cluster)) %>% mutate(cluster=as.factor(cluster))
  formula = eval(parse(text = paste0("label ~ 1 +", paste(vars_cv_selected %>% head(-1),collapse = " + "),"+ (1|cluster) ")))
  glmm_fit <- glmer(formula, data=traindata,nAGQ = 9,family = binomial)
#+END_SRC

*** 如何向一个向量追加元素？
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  x <- 1:5
  (foo <- c(x[1], 0, x[2:5]))
  append(x, 0, after = 1) # 在第一个元素之后添加0
  append(x, 0, after = 2)
#+END_SRC

*** 返回两个数据框不相同的位置
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  a <- c(1, 2)
  b <- c(1, 1)
  which(a != b)
  a <- data.frame(num = 1:3, lib = letters[1:3])
  b <- data.frame(num = c(1, 2, 0), lib = letters[1:3])
  which(a != b) # 只返回一个行值
  which(a != b, arr.ind = TRUE) # 不仅返回行值，还返回列值，arr.ind参数是array indices之意，返回数据框的行列位置
#+END_SRC

*** 删掉重复行
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
x <- c(9:20, 1:5, 3:7, 0:8)
x
unique(x)
(xu <- x[!duplicated(x)])
#+END_SRC

*** 如何对数列（array）进行维度变换?
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  x <- array(1:24, 2:4)
  x
  xt <- aperm(x, c(2, 1, 3))
  dim(x) # (2,3,4)
  dim(xt) # (3,2,4)
#+END_SRC

*** 如何对矩阵按行（列）作计算？
使用函数 apply()进行计算。
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
vec <- 1:20
mat <- matrix(vec, ncol = 4)
cumsum(vec)
mat
apply(mat, 2, cumsum)
apply(mat, 1, cumsum)
#+END_SRC

*** 注释大段的 R 脚本
可以用这种形式注释掉大段的程序，第一次见到。
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
if (FALSE) {
  x <- 1
}
inser
#+END_SRC

*** 如何对数据框（data.frame）的某列作数学变换？
transform 作用：为原数据框添加新的列，可以改变原变量列的值，也可以赋值 NULL 删除列变量
用法：transform(‘data’, ...)，data 就是要修改的数据，'...'代表要进行的修改，相当于 dlyr 包中的 mutate 函数。
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
transform(airquality, Ozone = -Ozone)
transform(airquality, new = -Ozone, Temp = (Temp - 32) / 1.8)
#+END_SRC

with 函数的返回值是原语句的返回值。within 跟 with 功能相同，但返回值不同，within 会返回所有修改生效后的原始数据结构（列表、数据框等），但是需要注意书写方式哦。坑真多~
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  mydata <- data.frame(x1 = c(2, 2, 6, 4), x2 = c(3, 4, 2, 8))
  (mydata <- with(mydata, {
      sumx <- x1 + x2
      meanx <- (x1 + x2) / 2
  }))
  (mydata <- with(mydata, {
      list(sumx = x1 + x2, meanx = (x1 + x2) / 2)
  })) # 这样书写就可以输出所有变量值
                                        # 只返回 meanx 值，sumx 值不返回
  (mydata <- within(mydata, sumx = x1 + x2, meanx = (x1 + x2) / 2))
  (mydata <- within(mydata, {
      sumx <- x1 + x2
      meanx <- (x1 + x2) / 2
  })) # 每个新修改的代码都需要换行
  (mydata <- within(mydata, {
      sumx <- x1 + x2
      meanx <- (x1 + x2) / 2
  }))
#+END_SRC

by(data, INDICES, FUN, ..., simplify = TRUE):把 data 这个 data frame 按照 INDICES 的 factor 拆分成若干块小的 data frames，在每块小的 data frame 上运行函数 FUN。

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  by(warpbreaks[, 1:2], warpbreaks[, "tension"], summary)
  by(
      warpbreaks, warpbreaks[, "tension"],
      function(x) lm(breaks ~ wool, data = x)
  )
#+END_SRC

### 求解两组平行向量的极值？
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  x <- 1:10
  y <- rev(x)
  pmax(x, y)
  pmin(x, y)
#+END_SRC

*** 如何对不规则数组进行统计分析？
可以用 tapply(x,f,g)进行分析，x为向量，f为因子列，g为操作函数，相对数据框进行类似操作可以用 by 函数。
example:
| value | class | sum |
|     1 |     1 | 1+4 |
|     2 |     2 |  2  |
|     3 |     3 |  3  |
|     4 |     1 |  NA |
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  n <- 4
  fac <- factor(rep(1:3, len = n), levels = 1:5)
  fac
  table(fac)
  tapply(1:n, fac, sum)
  tapply(1:n, fac, sum)
  tapply(1:n, fac, mean)
  a <- c(24, 25, 36, 37)
  b <- c("q", "w", "q", "w")
  tapply(a, b, mean)
  tapply(a, b, sum)
  attach(warpbreaks) # 这个 attach 函数的功能就是将数据集释放出来
  tapply(breaks, list(wool, tension), mean) # 还能做列联表
  aggregate(breaks, list(wool, tension), mean) # 相当于对 tapply 结果做了转置
#+END_SRC

*** 判断数据框的列是否为数字
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  x <- data.frame(x = c(1, 2, 3), y = c("a", "b", "c"))
  sapply(x, is.numeric) # 返回数据是否为数字
  ## 返回内存中所有对象的占用大小
  sapply(ls(), function(x) round(object.size(get(x)) / 1024 / 1024))
#+END_SRC

*** 如何将数据标准化？
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  x <- c(rnorm(100), 2 * rnorm(30))
  m <- scale(x, scale = F) # 只 centering
  n <- scale(x, center = F) # 只 scaling
  l <- scale(x) ## 默认的是不仅做 centering，还做了 scaling
#+END_SRC

*** 如何做交叉列联表？（table）
table，xtab，ftable
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  xtabs(cbind(ncases, ncontrols) ~ ., data = esoph)
  ftable(xtabs(cbind(ncases, ncontrols) ~ ., data = esoph))
#+END_SRC

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
                                        # 以后但凡有$，比较多的操作，都可以用 with 来写，很方便的
  x <- with(airquality, table(cut(Temp, quantile(Temp)), Month))
  with(airquality, table(cut(Temp, quantile(Temp))))
  with(airquality, cut(Temp, quantile(Temp)))
  head(airquality)
  head(x)
  prop.table(x, 1) # x 是求解出了频数，prop.table 求解出了概率
#+END_SRC

一个经典的例子：
一个 data.frame 中对所有变量进行 table,然后计算其 pct.
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  mtcars %>% 
      lapply(table) %>% 
      lapply(as.data.frame) %>% 
      Map(cbind,var = names(mtcars),.) %>% 
      rbind_all() %>% 
      group_by(var) %>% 
      mutate(pct = Freq / sum(Freq))
#####
  mtcars %>% 
      map(table) %>% 
      map(as.data.frame) %>% 
      map2(.,names(.),cbind) %>% 
      bind_rows() %>% 
      set_names("Var1","Freq","var") %>% 
      group_by(var) %>% 
      mutate(pct=Freq/sum(Freq))
#+END_SRC

** 4 list 型数据
列表（list）是 R 的数据类型中最为复杂的一种。一般来说，列表就是一些对象（或成分，component）的有序集合。列表允许你整合若干（可能无关的）对象到单个对象名下。
*** data.frame
data.frame()来创建数据框，它以带命名的向量作为输入

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 

 df <- data.frame(
      x=1:3,
      y=c("a","b","c"),
      #stringsAsFactors = T
  )

  df %>% str() 
  df %>% typeof()
 df %>% class() 
#+END_SRC

需要注意的是 data.frame() 的默认行为是把字符转换为因子，可以 stringsAsFactors=FALSE 避免这个行为。


***  do.call
do.call(what, args, quote = FALSE, envir = parent.frame())
what 要不是操作函数，要不是 function 的 string 形式,args 是 list 对象。
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
                                        # do.call
 a <- do.call(rbind, list(data.frame(a = 1:2, b = 2:3), data.frame(b = 1:2, a = 2:3))) # rind 无法直接对 list 类型进行 rbind
  a %>% typeof
  t1 <- do.call(kmeans, list(x = iris[, 1:4], centers = 3))
  rbindlist(list(data.frame(a = 1:2, b = 2:3), data.frame(b = 1:2, a = 2:3)))
  ## 需要注意 rbindlist 函数不能自动识别变量名
                                        # more example
  tmp <- expand.grid(letters[1:2], 1:3, c("+", "-")) # list
  tmp
  do.call(paste, c(tmp, sep = ""))
  do.call(paste, list(as.name("A"), as.name("B")), quote = TRUE)
  ##
  A <- 2
  f <- function(x) print(x^2)
  env <- new.env()
  assign("A", 10, envir = env)
  assign("f", f, envir = env)
  f <- function(x) print(x)
  f(A) # 2
  do.call("f", list(A)) # 2
  do.call("f", list(A), envir = env) # 4
  do.call(f, list(A), envir = env) # 2
  do.call("f", list(quote(A)), envir = env) # 100
  do.call(f, list(quote(A)), envir = env) # 10
  do.call("f", list(as.name("A")), envir = env) # 100
#+END_SRC

*** c()

c() 可以将几个向量合并成一个。如果原子向量和列表同时存在，那么在合并之前，c() 会将原子向量强制转换成列表。
当你试图合并不同类型的数据时，将向最灵活的类型进行强制转换。以灵活程度排序，从小到大依次为： *逻辑、整数、双精度浮点数和字符。*

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
c("a",1) %>% str #可以将数字型转化为char型

  x <- c(F,F,T) 
  as.numeric(x)
  sum(x) #竟然计算逻辑型！！
  mean(x)
#+END_SRC

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  1 ==  "1" #[1] TRUE,竟然可以返回TRUE
  -1<F #[1] TRUE 
  "one"<2
#+END_SRC


#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  x <- list(list(1,2),c(3,4)) 
  x %>% typeof()
  y <- c(list(1,2),c(3,4)) 
  y %>% typeof() #看到这是list型
#+END_SRC

*** reduce

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  lst <- list(0)
  
#+END_SRC

** 5 因子型数据
函数 factor()以一个整数向量的形式存储类别值，整数的取值范围是[1... k]（其中 k 是名义型变量中唯一值的个数）。
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
#ggplot::results output graphics,plot::results graphics 
status <- c("poor", "improved", "excellent", "poor")
factor(status, ordered = TRUE) # 设定为有序因子
factor(status, ordered = TRUE,levels = c("poor","improved","excellent"))
factor(status) # 设定为名义变量
data <- data.frame(x = c("male", "female", "male"))
#+END_SRC

factors 应该常常和 rev 函数配合使用。
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  rev(factor(letters))
  factor(letters,levels = rev(letters))
#+END_SRC

** 6 日期型数据
计算日期间隔

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.pn
  difftime()
  today <- Sys.Date()
  dob <- as.Date("1988-06-07")
  difftime(today, dob, units = "days")
#+END_SRC

** 7 TODO: BOOLEN 数据
***  布尔代数
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  rep_len(F, 10)
  a <- c("1", "2", "4", "4", "6", "5")
  b <- c("2", "5")
  intersect(a, b)
  union(a, b) # 相当于将所有不重复元素连接起来
  setdiff(a, b) # 只显示不重复的元素
  setdiff(union(a, b), intersect(a, b))
#+END_SRC

*** 比较两个对象是否相等
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  x1=data.frame(x=c(1,2,3,4),y=c(1,2,4,3))
  x2=data.frame(x=c(1,2,3,4),y=c(1,2,3,4))
  all.equal(x1,x2)
  identical(x1,x2) #可以检查两个对象是否完全一致
  x3 <- data.frame(x=c(1,2,3,4),y=c(1,2,3,4))
  identical(x2,x3)
#+END_SRC

*** 取偶数位置值
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  x <- c("1","2","3","4")
  x[c(FALSE,TRUE)]
                                        # [1] "Component \"y\": Mean relative difference: 0.2857143"
#+END_SRC

** JSON 数据

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  ### 从 hive 数据表的 jason 对象提取 data--------------------------------
  hujin_parser <- hujin %>%
      mutate(
          xiaomi_id = get_json_object(response, "$.entity.xiaomiId"),
          create_time = get_json_object(response, "$.entity.createTime"),
          update_time = get_json_object(response, "$.entity.updateTime"),
          data = get_json_object(response, "$.entity.data")
      )
#+END_SRC

* 5 模型
**  求解没有常数项的线性回归模型
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  result <- lm(y ~ 0 + x1, data = data)
#+END_SRC
***  如何使用正交多项式回归？
考虑回归方程：

\[
y_{i}=\beta_{0}+\beta_{1} x_{i}+\beta_{2} x_{i}^{2}+\ldots+\beta_{k} x_{i}^{k}, i=1,2, \ldots, n
\]

当多项式的次数$k$比较大时，$x, x^{2}, \ldots, x^{k}$会出现线性相关问题。故需要使用正交多项式回归来克服这个缺点。在 R 中，使用 poly()函数：

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  (z <- poly(1:10, 2))
  str(z)
  library(ISLR)
  library(ggplot2)
  attach(Auto)
  library(tidyverse)
  library(magrittr)
  fm2raw <- lm(mpg ~ poly(horsepower, 2, raw = TRUE), Auto)
  fm2raw <- lm(mpg ~ poly(horsepower, 2), Auto)
  Auto %<>% mutate(pred = predict(fm2raw, newdata = Auto))
  ggplot(Auto, aes(x = horsepower, y = mpg)) + geom_line(aes(y = pred)) + geom_point() + geom_smooth()
  cor(poly(horsepower, 2)) # 加了 raw=TRUE，这两列数据就是强相关
#+END_SRC

*** 如何进行典型相关分析？

典型相关分析是用于研究两组随机变量之间法相关性的一种统计方法。它的基本原理是：为了从总体上把握两组指标之间的相关关系，分别在两组变量中提取有代表性的两个综合变量 U1 和 V1（分别为两个变量组中各变量的线性组合），利用这两个综合变量之间的相关关系来反映两组指标之间的整体相关性。
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
pop <- LifeCycleSavings [, 2:3]
oec <- LifeCycleSavings [, -(2:3)]
cancor(pop, oec)
#+END_SRC

***  R 的 SPSS 版本
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  library(Rcmdr)
#+END_SRC

* 6 作图
** ggplot2
*** 散点图
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  #单个变量
  ggplot(starwars) +
      geom_point(aes(x = height, y = mass))
# 群组
  ggplot(data = mpg)+
      geom_point(mapping = aes(x = displ,y = hwy,color = class))

  ggplot(data = mpg)+
      geom_point(mapping = aes(x = displ,y = hwy,alpha = class)) #alpha控制透明度

  ggplot(data = mpg)+
      geom_point(mapping = aes(x = displ,y = hwy,shape = class)) #shape 控制上屏的形状

  ggplot(data = mpg)+
      geom_point(mapping = aes(x = displ,y = hwy,shape = "blue")) #可以控制所有点的颜色
#+END_SRC

### 直方图
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
library(ggplot2)
library(lattice)
###ggplot2 版本.--------------------------
dat <- data.frame(
  cond = factor(rep(c("A", "B"), each = 200)),
  rating = c(rnorm(200), rnorm(200, mean = .8))
)
ggplot(dat, aes(x = rating)) + geom_histogram(binwidth = .5) # rating 作为横轴

ggplot(dat, aes(x = rating)) +
  geom_histogram(
    binwidth = .5,
    colour = "black", # 边框颜色
    fill = "white" # 填充颜色
  )
## 密度图
ggplot(dat, aes(x = rating)) + geom_density() # 添加密度曲线
## 密度图+直方图
ggplot(dat, aes(x = rating)) +
  geom_histogram(aes(y = ..density..), # 这一步很重要,使用 density 代替 y 轴
    binwidth = .5,
    colour = "black", fill = "white"
  ) +
  geom_density(alpha = .2, fill = "#FF6666") # 重叠部分采用透明设置
## 添加一条均值线(红色部分)
ggplot(dat, aes(x = rating)) +
  geom_histogram(binwidth = .5, colour = "black", fill = "white") +
  geom_vline(aes(xintercept = mean(rating, na.rm = T)), # Ignore NA values for mean
    color = "red", linetype = "dashed", size = 1
  )
## 多组数据的直方图和密度图
###.cond 作为各组的分类,以颜色填充作为区别,position 的处理很重要,决定数据存在重叠是的处理方式 "identity" 不做处理,但是设置了透明--------------------------
ggplot(dat, aes(x = rating, fill = cond)) +
  geom_histogram(binwidth = .5, alpha = .5, position = "identity")
# Interleaved histograms
ggplot(dat, aes(x = rating, fill = cond)) +
  geom_histogram(binwidth = .5, position = "dodge") # dodge 表示重叠部分进行偏离
# 密度图
ggplot(dat, aes(x = rating, colour = cond)) + geom_density()
# 半透明的填充
ggplot(dat, aes(x = rating, fill = cond)) + geom_density(alpha = .3)

#
ggplot(dat, aes(x = rating)) + geom_histogram(binwidth = .5, colour = "black", fill = "white") +
  facet_grid(cond ~ .) ## 分面


# lattice 版本
histogram(~ height | voice.part,
  data = singer, main = "Distribution of Heights by Voice Pitch",
  xlab = "Height (inches)"
)
head(singer)

  library(ggplot2)
  ggplot(iris, aes(x=Sepal.Length, y=Sepal.Width)) +
      geom_point() +
      facet_grid( . ~ Species )
#+END_SRC

***  密度图
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
attach(mtcars)
# data("mtcars")
gear <- factor(gear,
  levels = c(3, 4, 5),
  labels = c("3 gears", "4 gears", "5 gears")
)
cyl <- factor(cyl,
  levels = c(4, 6, 8),
  labels = c("4 cylinders", "6 cylinders", "8 cylinders")
)

# 开始画图

densityplot(~mpg,
  main = "Density Plot",
  xlab = "Miles per Gallon"
)

head(mtcars)
densityplot(~ mpg | cyl,
  layout = c(1, 3), main = "Density Plot by Number of Cylinders",
  xlab = "Miles per Gallon"
)

gear <- factor(gear,
  levels = c(3, 4, 5),
  labels = c("3 gears", "4 gears", "5 gears")
)
cyl <- factor(cyl,
  levels = c(4, 6, 8),
  labels = c("4 cylinders", "6 cylinders", "8 cylinders")
)

densityplot(~mpg,
  main = "Density Plot",
  xlab = "Miles per Gallon"
)

mtcars$cyl <- cyl.f

densityplot(~ mpg | cyl,
  main = "Density Plot by Number of Cylinders",
  xlab = "Miles per Gallon"
)

bwplot(cyl ~ mpg | gear,
  main = "Box Plots by Cylinders and Gears",
  xlab = "Miles per Gallon", ylab = "Cylinders"
)


xyplot(decrease ~ treatment, OrchardSprays,
  groups = rowpos,
  type = "a",
  auto.key =
    list(space = "right", points = FALSE, lines = TRUE)
)

cloud(mpg ~ wt * qsec | cyl,
  main = "3D Scatter Plots by Cylinders"
)

dotplot(cyl ~ mpg | gear,
  main = "Dot Plots by Number of Gears and Cylinders",
  xlab = "Miles Per Gallon"
)

plom(mtcars[c(1, 3, 4, 5, 6)],
  main = "Scatter Plot Matrix for mtcars Data"
)

detach(mtcars)

dotplot(cyl ~ mpg | gear,
  main = "Dot Plots by Number of Gears and Cylinders",
  xlab = "Miles Per Gallon"
)

library(lattice)
panel.smoother <- function(x, y) {
  panel.xyplot(x, y) # show points
  panel.loess(x, y) # show smoothed line
}
attach(mtcars)
hp <- cut(hp, 3) # divide horse power into three bands
xyplot(mpg ~ wt | hp,
  scales = list(cex = .8, col = "red"),
  panel = panel.smoother,
  xlab = "Weight", ylab = "Miles per Gallon",
  main = "MGP vs Weight by Horse Power"
)
#+END_SRC

***  线图
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  unemp_lux_data %>%
      ggplot(aes(x = year, y = unemployment_rate_in_percent, group = 1)) +
      geom_line()
#+END_SRC

***  拟合线图
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  fm2raw <- lm(mpg ~ poly(horsepower, 2), Auto) # 先拟合
  Auto %<>% mutate(pred = predict(fm2raw, newdata = Auto)) # 将模型预测结果加入原始数据集中
  ggplot(Auto, aes(x = horsepower, y = mpg)) + geom_line(aes(y = pred)) + geom_point() + geom_smooth()
#+END_SRC

dt <- mtcars[1:5, 1:6]
*** 密度图
** patchwork
利用 patchwork 包可以实现图像的排列组合展示。
   #+begin_src R ::results output graphics :file fig_1.png :exports both
     library(patchwork)
     library(ggplot2)
     library(dplyr)
     p = diamonds %>% 
         ggplot(aes(carat, price,color=clarity))+geom_point()
     p2 = diamonds %>% 
         ggplot(aes(clarity, price, fill=cut))+geom_boxplot(position="dodge")
     p|p2     
   #+end_src

* 表格、results 输出
在 R 中关于表格输出的包有很多，huxtable 是其中之一。

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
library("huxtable")
car_ht <- as_hux(mtcars)
car_ht <- huxtable::add_rownames(car_ht, colname = "Car")
car_ht <- car_ht                                          %>%
    slice(1:10)                                         %>% 
    select(Car, mpg, cyl, hp)                           %>% 
    arrange(hp)                                         %>% 
    filter(cyl > 4)                                     %>% 
    rename(MPG = mpg, Cylinders = cyl, Horsepower = hp) %>% 
    mutate(kml = MPG/2.82)                              %>% 
    huxtable::add_colnames()                            
theme_plain(car_ht)
# kableExtra
library(knitr)
library(kableExtra)
kable(dt)
dt %>%
    kable() %>%
    kable_styling()

xtable::xtable(mtcars[1:4, 1:4], caption = "Hello xtable") %>%
    xtable2kable() %>%
    column_spec(1, color = "red")
#+END_SRC
** reprex
这个包对粘贴 R 程序的结果有好处。
#+begin_src R ::results output graphics :file fig_1.png :exports both
  reprex({
      y <- 1:4; mean(y)}, style = TRUE
      )
#+end_src

上述代码的结果就是

#+begin_src R ::results output graphics :file fig_1.png :exports both
  y <- 1:4
  mean(y)
                                        #> [1] 2.5  
#+end_src

* parallel 并行运算
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  library(doParallel)
  cl <- makeCluster(2)
  registerDoParallel(cl)
  foreach(i = 1:3) %dopar% sqrt(i)
x <- iris[which(iris[,5] != "setosa"),c(1,5)]
  trials <- 10000
  stime <- system.time({
      r <- foreach(icount(trials),.combine = cbind) %do% {
          ind <- sample(100,100,replace = TRUE)
          result1 <- glm(x[ind,2]~x[ind,1],family = binomial(logit))
          coefficients(result1)
      }
  }
  )[3]
#+END_SRC

***  如何加速 R 的运行速度？
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  library(parallel)
  doit <- function(x) x^2 + 2 * x
  system.time(res = lapply(1:5000000, doit))
  rm(res)
  gc()
  cl <- makeCluster(getOption("cl.cores", 3))
  system.time(res = parLapply(cl, 1:5000000, doit))
  stopCluster(cl)
#+END_SRC
* 7 Packages
** 7.0 Base 包
*** c 
Combine Values into a Vector or List.
#+begin_src R ::results output graphics :file fig_1.png :exports both
  c(1, 7:9)
                                        #> [1] 1 7 8 9
  c(1:5, 10.5, "next")
                                        #> [1] "1"    "2"    "3"    "4"    "5"    "10.5" "next"
  ll <- list(A = 1, c = "C")
  ## do *not* use
  c(ll, d = 1:3)
                                        #> $A
                                        #> [1] 1
                                        #> 
                                        #> $c
                                        #> [1] "C"
                                        #> 
                                        #> $d1
                                        #> [1] 1
                                        #> 
                                        #> $d2
                                        #> [1] 2
                                        #> 
                                        #> $d3
                                        #> [1] 3
  c(list(A = c(B = 1)), recursive = TRUE)
                                        #> A.B 
                                        #>   1
  c(list(A = c(B = 1, C = 2), B = c(E = 7)), recursive = TRUE)
                                        #> A.B A.C B.E 
                                        #>   1   2   7
#+end_src
*** date

    #+begin_src R ::results output graphics :file fig_1.png :exports both
      (today <- Sys.Date())
                                        #> [1] "2020-03-04"
      format(today, "%d %b %Y") # with month as a word
                                        #> [1] "04 3月 2020"
      (tenweeks <- seq(today, length.out = 10, by = "1 week"))
                                        #>  [1] "2020-03-04" "2020-03-11" "2020-03-18" "2020-03-25" "2020-04-01"
                                        #>  [6] "2020-04-08" "2020-04-15" "2020-04-22" "2020-04-29" "2020-05-06"  
    #+end_src
*** cat

Concatenate and Print.Outputs the objects, concatenating the representations. cat performs much less conversion than print.主要用于打印结果。

#+begin_src R ::results output graphics :file fig_1.png :exports both
  iter <- stats::rpois(1, lambda = 10)
  ## print an informative message
  cat("iteration = ", iter <- iter + 1, "\n")
                                        #> iteration =  9
#+end_src
*** warning
Generates a warning message that corresponds to its argument(s) and (optionally) the expression or function from which it was called.
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      if(length(list.files(sprintf("%s/",modelpath),pattern = "onehot_encode.RData"))>0)
          warning("The model path has onehot_encode.RData file,Please check, don't converge it!!") else{
                                                                                                       cat("The model path has not onehot_encode.RData file :)")
                                                                                                   }        
    #+end_src
*** stop
stop stops execution of the current expression and executes an error action.
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      iter <- 12
      try(if (iter > 10) stop("too many iterations"))
                                        #> Error in try(if (iter > 10) stop("too many iterations")) : 
                                        #>   too many iterations 
    #+end_src
*** message
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      testit <- function() {
          message("testing package startup messages")
          packageStartupMessage("initializing ...", appendLF = FALSE)
          Sys.sleep(1)
          packageStartupMessage(" done")
      }
      testit()
                                        #> testing package startup messages
                                        #> initializing ... done      
    #+end_src
*** toString
A character vector of length 1 is returned.
其实，这个函数相当于 str_c(x, collapse = ", ").

    #+begin_src R ::results output graphics :file fig_1.png :exports both
      x <- c("a", "b", "aaaaaaaaaaa")
      toString(x)
                                        #> [1] "a, b, aaaaaaaaaaa"
      str_c(x, collapse = ", ")
                                        #> Error in str_c(x, collapse = ", "): 没有"str_c"这个函数
      toString(x, width = 8)
                                        #> [1] "a, b...."
    #+end_src
*** tryCatch
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      tryCatch(1, finally = print("Hello"))
                                        #> [1] "Hello"
                                        #> [1] 1
      e <- simpleError("test error")
      stop(e)
                                        #> Error: test error
      tryCatch(stop(e), finally = print("Hello"))
                                        #> Error: test error
                                        #> [1] "Hello"      
    #+end_src

*** rbind

    #+begin_src R ::results output graphics :file fig_1.png :exports both
      dd <- 10
      rbind(1:4, c = 2, "a++" = 10, dd, deparse.level = 0) # middle 2 rownames
                                        #>     [,1] [,2] [,3] [,4]
                                        #>        1    2    3    4 
                                        #> c      2    2    2    2
                                        #> a++   10   10   10   10
                                        #>       10   10   10   10
      rbind(1:4, c = 2, "a++" = 10, dd, deparse.level = 1) # 3 rownames (default)
                                        #>     [,1] [,2] [,3] [,4]
                                        #>        1    2    3    4
                                        #> c      2    2    2    2
                                        #> a++   10   10   10   10
                                        #> dd    10   10   10   10
      rbind(1:4, c = 2, "a++" = 10, dd, deparse.level = 2) # 4 rownames
                                        #>     [,1] [,2] [,3] [,4]
                                        #> 1:4    1    2    3    4
                                        #> c      2    2    2    2
                                        #> a++   10   10   10   10
                                        #> dd    10   10   10   10      
    #+end_src
*** rawconversion
Convert to or from Raw Vectors.Conversion and manipulation of objects of type "raw".
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      x <- "A test string"
      (y <- charToRaw(x))
                                        #>  [1] 41 20 74 65 73 74 20 73 74 72 69 6e 67
      y %>% str()
                                        #> Error in y %>% str(): 没有"%>%"这个函数
      rawToChar(y)
                                        #> [1] "A test string"
      rawToBits(y)
                                        #>   [1] 01 00 00 00 00 00 01 00 00 00 00 00 00 01 00 00 00 00 01 00 01 01 01
                                        #>  [24] 00 01 00 01 00 00 01 01 00 01 01 00 00 01 01 01 00 00 00 01 00 01 01
                                        #>  [47] 01 00 00 00 00 00 00 01 00 00 01 01 00 00 01 01 01 00 00 00 01 00 01
                                        #>  [70] 01 01 00 00 01 00 00 01 01 01 00 01 00 00 01 00 01 01 00 00 01 01 01
                                        #>  [93] 00 01 01 00 01 01 01 00 00 01 01 00  
    #+end_src
*** all.names
Find All Names in an Expression.
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      all.names(expression(sin(x + y)))
                                        #> [1] "sin" "+"   "x"   "y"
      all.names(quote(sin(x + y))) # or a call
                                        #> [1] "sin" "+"   "x"   "y"
      all.vars(expression(sin(x + y)))
                                        #> [1] "x" "y"  
    #+end_src
*** apply

apply(X, MARGIN, FUN)
Here:
-x: 一个数组或者矩阵
-MARGIN: 两种数值 1 或者 2 决定对哪一个维度进行函数计算
-MARGIN=1`: 操作基于行
-MARGIN=2`: 操作基于列
-MARGIN=c(1,2)`: 对行和列都进行操作
-FUN: 使用哪种操作，内置的函数有 mean（平均值）、medium（中位数）、sum（求和）、min（最小值）、max（最大值），当然还包括广大的用户自定义函数.

#+begin_src R ::results output graphics :file fig_1.png :exports both
  > m1 <- matrix(C<-(1:10),nrow=5, ncol=6)
  > m1
  [,1] [,2] [,3] [,4] [,5] [,6]
  [1,]    1    6    1    6    1    6
  [2,]    2    7    2    7    2    7
  [3,]    3    8    3    8    3    8
  [4,]    4    9    4    9    4    9
  [5,]    5   10    5   10    5   10
  > a_m1 <- apply(m1, 2, sum)
  > a_m1
  [1] 15 40 15 40 15 40  
#+end_src

*** aperm
对数列的维度进行重塑。
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      (x <- array(1:24, 2:4))
                                        #> , , 1
                                        #> 
                                        #>      [,1] [,2] [,3]
                                        #> [1,]    1    3    5
                                        #> [2,]    2    4    6
                                        #> 
                                        #> , , 2
                                        #> 
                                        #>      [,1] [,2] [,3]
                                        #> [1,]    7    9   11
                                        #> [2,]    8   10   12
                                        #> 
                                        #> , , 3
                                        #> 
                                        #>      [,1] [,2] [,3]
                                        #> [1,]   13   15   17
                                        #> [2,]   14   16   18
                                        #> 
                                        #> , , 4
                                        #> 
                                        #>      [,1] [,2] [,3]
                                        #> [1,]   19   21   23
                                        #> [2,]   20   22   24
      (xt <- aperm(x, c(2, 1, 3)))
                                        #> , , 1
                                        #> 
                                        #>      [,1] [,2]
                                        #> [1,]    1    2
                                        #> [2,]    3    4
                                        #> [3,]    5    6
                                        #> 
                                        #> , , 2
                                        #> 
                                        #>      [,1] [,2]
                                        #> [1,]    7    8
                                        #> [2,]    9   10
                                        #> [3,]   11   12
                                        #> 
                                        #> , , 3
                                        #> 
                                        #>      [,1] [,2]
                                        #> [1,]   13   14
                                        #> [2,]   15   16
                                        #> [3,]   17   18
                                        #> 
                                        #> , , 4
                                        #> 
                                        #>      [,1] [,2]
                                        #> [1,]   19   20
                                        #> [2,]   21   22
                                        #> [3,]   23   24      
    #+end_src

*** any
Are Some Values True?Given a set of logical vectors, is at least one of the values true?

#+begin_src R ::results output graphics :file fig_1.png :exports both
  range(x <- sort(round(stats::rnorm(10) - 1.2, 1)))
                                        #> [1] -2.8 -0.3
  if (any(x < 0)) cat("x contains negative values\n")
                                        #> x contains negative values
#+end_src

*** all
Given a set of logical vectors, are all of the values true?
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      range(x <- sort(round(stats::rnorm(10) - 1.2, 1)))
                                        #> [1] -2.9  1.5
      if (all(x < 0)) {
          cat("all x values are negative\n")
      } else {
          cat("all x values are poisitive\n")
      }
                                        #> all x values are poisitive      
    #+end_src

*** anyNA

    #+begin_src R ::results output graphics :file fig_1.png :exports both
      is.na(c(1, NA)) # > FALSE  TRUE
                                        #> [1] FALSE  TRUE
      is.na(paste(c(1, NA))) # > FALSE FALSE
                                        #> [1] FALSE FALSE
      c(TRUE, FALSE) & NA
                                        #> [1]    NA FALSE
      c(TRUE, FALSE) | NA
                                        #> [1] TRUE   NA
      (xx <- c(0:4))
                                        #> [1] 0 1 2 3 4
      is.na(xx) <- c(2, 4)
      xx # > 0 NA  2 NA  4
                                        #> [1]  0 NA  2 NA  4
      anyNA(xx) # TRUE
                                        #> [1] TRUE 
    #+end_src

*** expression
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      length(ex1 <- expression(1 + 0:9)) # 1
                                        #> [1] 1
      ex1
                                        #> expression(1 + 0:9)
      eval(ex1)
                                        #>  [1]  1  2  3  4  5  6  7  8  9 10  
    #+end_src

*** call
Function Calls.Create or test for objects of mode "call" (or "(", see Details).

call(name, ...)
is.call(x)
as.call(x)

Arguments

name a non-empty character string naming the function to be called.

...	
arguments to be part of the call.

x	
an arbitrary R object.

    #+begin_src R ::results output graphics :file fig_1.png :exports both
      cl <- call("round", 10.5)
      is.call(cl) # TRUE
                                        #> [1] TRUE
      cl %>% eval()
                                        #> Error in cl %>% eval(): 没有"%>%"这个函数
      class(cl) # "call"
                                        #> [1] "call"
      typeof(cl) # "language"
                                        #> [1] "language"
      is.call(cl) && is.language(cl) # always TRUE for "call"s
                                        #> [1] TRUE  
    #+end_src


*** 科学计算符号
 +:Addition
 –：Subtraction
 *:Multiplication
 /:Division
 ^:Exponent
 %%:Modulus (Remainder from division)
 %/%:Integer Division

 #+begin_src R :results output graphics :file fig_1.png :exports both 
   16 %/% 5
   ## 3
 #+end_src


 常用函数：
 - cat：连接...中的对象，并将其输出到屏幕上或文件中（如果声明了一个的话）。
 cat()函数的优势在于可以用来捕捉函数功能的错误，除了 cat()函数外，warning()可以生成一条错误提示信息，用 message()生成一条诊断信息，或用 stop()停止当前表达式的执行并提示错误。
 #+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
   #ggplot::results output graphics,plot::results graphics 
   firstname <- c("Jane")
   cat("Hello", firstname, "\n")
 #+END_SRC
*** reduce

reduce() takes a vector of length n and produces a vector of length 1 by calling a function with a pair of values at a time: reduce(1:4, f) is equivalent to f(f(f(1, 2), 3), 4).
如果寻找多个向量的共同值，就可以用 reduce.
#+begin_src R :results output graphics :file fig_1.png :exports both 
  library(tidyverse)
  l <- map(1:4,~sample(1:10,15,replace = T))
  str(l)
  reduce(l,intersect)
#+end_src
*** reduce2
可以支持多个输入。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- list(c(0, 1), c(2, 3), c(4, 5))
      y <- list(c(6, 7), c(8, 9))
      reduce2(x, y, paste)      
    #+end_src
*** get
Return the Value of a Named Object
#+begin_src R :results output graphics :file fig_1.png :exports both 
  x <- 1:5
  get("x")  
#+end_src
*** assign
Assign a Value to a Name.Assign a value to a name in an environment.
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      a <- 1:4
      assign("a[1]", 2)
      a
                                        #> [1] 1 2 3 4
      get("a[1]")
                                        #> [1] 2
      a[1] == 2 # FALSE
                                        #> [1] FALSE
      get("a[1]") == 2 # TRUE
                                        #> [1] TRUE      
    #+end_src

*** attr
Object Attributes.
#+begin_src R ::results output graphics :file fig_1.png :exports both
  x <- 1:10
  attr(x, "dim") <- c(2, 5)
  x
                                        #>      [,1] [,2] [,3] [,4] [,5]
                                        #> [1,]    1    3    5    7    9
                                        #> [2,]    2    4    6    8   10
#+end_src
*** body
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      f <- function(x) x^5
      body(f) <- quote(5^x)
      ## or equivalently  body(f) <- expression(5^x)
      f(3) # = 125
                                        #> [1] 125
      body(f)
                                        #> 5^x  
    #+end_src

*** strrep
Repeat the character strings in a character vector a given number of times (i.e., concatenate the respective numbers of copies of the strings).
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      strrep("ABC", 2)
                                        #> [1] "ABCABC"
      strrep(c("A", "B", "C"), 1 : 3)
                                        #> [1] "A"   "BB"  "CCC"      
    #+end_src
*** utils
**** adist
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       ## Cf. https://en.wikipedia.org/wiki/Levenshtein_distance
       (adist("kitten", "sitting"))
                                        #>      [,1]
                                        #> [1,]    3
       (adist("lasy", "1 lazy 2"))
                                        #>      [,1]
                                        #> [1,]    5       
     #+end_src
**** apropos 
apropos() returns a character vector giving the names of objects in the search
list matching (as a regular expression) what.find() returns where objects of a
given name can be found.

apropos 函数能够匹配在内存中的对象。
     #+begin_src R :results output graphics :file fig_1.png :exports both 
      ## Not run: apropos("lm")
apropos("GLM")                      # several
#> [1] "glm"           "glm.control"   "glm.fit"       "predict.glm"  
#> [5] "residuals.glm" "summary.glm"
apropos("GLM", ignore.case = FALSE) # not one
#> character(0)
apropos("lq")
#> [1] "evalq"       "evalqOnLoad"
# need a DOUBLE backslash '\\' (in case you don't see it anymore)
apropos("\\[")
#>  [1] "["                    "[.AsIs"               "[.data.frame"        
#>  [4] "[.Date"               "[.difftime"           "[.Dlist"             
#>  [7] "[.DLLInfoList"        "[.factor"             "[.hexmode"           
#> [10] "[.listof"             "[.noquote"            "[.numeric_version"   
#> [13] "[.octmode"            "[.POSIXct"            "[.POSIXlt"           
#> [16] "[.simple.list"        "[.table"              "[.warnings"          
#> [19] "[["                   "[[.data.frame"        "[[.Date"             
#> [22] "[[.factor"            "[[.numeric_version"   "[[.POSIXct"          
#> [25] "[[.POSIXlt"           "[[<-"                 "[[<-.data.frame"     
#> [28] "[[<-.factor"          "[[<-.numeric_version" "[[<-.POSIXlt"        
#> [31] "[<-"                  "[<-.data.frame"       "[<-.Date"            
#> [34] "[<-.factor"           "[<-.numeric_version"  "[<-.POSIXct"         
#> [37] "[<-.POSIXlt"
# everything % not diff-able
length(apropos("."))
#> [1] 3647
# the 1-letter things
apropos("^.$")
#>  [1] "-" ":" "!" "?" "(" "[" "{" "@" "*" "/" "&" "^" "+" "<" "=" ">" "|"
#> [18] "~" "$" "c" "C" "D" "F" "I" "n" "q" "t" "T"
# the 1-2-letter things
apropos("^..?$")
#>  [1] "-"  ":"  "::" "!"  "!=" "?"  ".C" "("  "["  "[[" "{"  "@"  "*"  "/" 
#> [15] "&"  "&&" "%%" "^"  "+"  "<"  "<-" "<=" "="  "==" ">"  ">=" "|"  "||"
#> [29] "~"  "$"  "ar" "as" "by" "c"  "C"  "cm" "D"  "de" "df" "do" "dt" "el"
#> [43] "F"  "gc" "gl" "I"  "id" "if" "Im" "is" "lm" "ls" "n"  "pf" "pi" "pt"
#> [57] "q"  "qf" "qr" "qt" "Re" "rf" "rm" "rt" "sd" "t"  "T"  "ts" "vi" 
     #+end_src
**** person
这个函数可以生成一个人名信息。
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       (p1 <- person("Karl", "Pearson", email = "pearson@stats.heaven"))
                                        #> [1] "Karl Pearson <pearson@stats.heaven>"       
     #+end_src
**** roman
Simple manipulation of (a small set of) integer numbers as roman numerals.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       (y <- as.roman(1 : 5))
                                        #> [1] I   II  III IV  V
       (y <- as.roman(format(Sys.Date(), "%Y")))
                                        #> [1] MMXX
     #+end_src
**** askYesNo
askYesNo provides a standard way to ask the user a yes/no question. It provides a way for front-ends to substitute their own dialogs.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       askYesNo("Do you want to use askYesNo?")  
     #+end_src
**** bibentry
这个函数主要用来生成 bib 文献。
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       rref <- bibentry(
           bibtype = "Manual",
           title = "R: A Language and Environment for Statistical Computing",
           author = person("R Core Team"),
           organization = "R Foundation for Statistical Computing",
           address = "Vienna, Austria",
           year = 2014,
           url = "https://www.R-project.org/")
       ## Different printing styles
       print(rref)
                                        #> R Core Team (2014). _R: A Language and Environment for Statistical
                                        #> Computing_. R Foundation for Statistical Computing, Vienna,
                                        #> Austria. <URL: https://www.R-project.org/>.       
     #+end_src
**** browseEnv
浏览环境中的对象。
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       browseEnv()       
     #+end_src
**** browseURL
Load URL into an HTML Browser.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       browseURL("https://www.r-project.org")         
     #+end_src
**** browseVignettes
List Vignettes in an HTML Browser.学习起来很方便的。
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       browseVignettes(all = FALSE)       
     #+end_src
**** bug.report
Send a Bug Report.Invokes an editor or email program to write a bug report or opens a web page for bug submission. Some standard information on the current version and configuration of R are included automatically.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       bug.report(subject = "",  address,
                  file = "R.bug.report", package = NULL, lib.loc = NULL,
                  ...)
     #+end_src
**** capture.output
Send Output to a Character String or File.Evaluates its arguments with the output being returned as a character string or sent to a file. Related to sink in the same way that with is related to attach.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       glmout <- capture.output(summary(glm(case ~ spontaneous+induced,
                                            data = infert, family = binomial())))
                                        #> Error in is.data.frame(data): object 'infert' not found
       glmout[1:5]
                                        #> Error in eval(expr, envir, enclos): object 'glmout' not found
       capture.output(1+1, 2+2)
                                        #> [1] "[1] 2" "[1] 4"
       capture.output({1+1; 2+2})
                                        #> [1] "[1] 4"       
     #+end_src
**** changedFiles 
fileSnapshot takes a snapshot of a selection of files, recording summary information about each.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       # Create some files in a temporary directory
       dir <- tempfile()
       dir.create(dir)
       writeBin(1L, file.path(dir, "file1"))
       writeBin(2L, file.path(dir, "file2"))
       dir.create(file.path(dir, "dir"))

                                        # Take a snapshot
       snapshot <- fileSnapshot(dir, timestamp = tempfile("timestamp"), md5sum=TRUE)

                                        # Change one of the files.
       writeBin(3L:4L, file.path(dir, "file2"))

                                        # Display the detected changes.  We may or may not see mtime change...
       changedFiles(snapshot)
                                        #> File changes:
                                        #>       size mtime Newer md5sum
                                        #> file2 TRUE  TRUE  TRUE   TRUE
       changedFiles(snapshot)$changes
                                        #>        size isdir  mode mtime Newer md5sum
                                        #> dir   FALSE FALSE FALSE FALSE FALSE     NA
                                        #> file1 FALSE FALSE FALSE FALSE FALSE  FALSE
                                        #> file2  TRUE FALSE FALSE  TRUE  TRUE   TRUE       
     #+end_src
**** citation
如何在文献中引用 R 包？
     #+begin_src R :results output graphics :file fig_1.png :exports both 
## the basic R reference
citation()
#> 
#> To cite R in publications use:
#> 
#>   R Core Team (2019). R: A language and environment for
#>   statistical computing. R Foundation for Statistical Computing,
#>   Vienna, Austria. URL https://www.R-project.org/.
#> 
#> A BibTeX entry for LaTeX users is
#> 
#>   @Manual{,
#>     title = {R: A Language and Environment for Statistical Computing},
#>     author = {{R Core Team}},
#>     organization = {R Foundation for Statistical Computing},
#>     address = {Vienna, Austria},
#>     year = {2019},
#>     url = {https://www.R-project.org/},
#>   }
#> 
#> We have invested a lot of time and effort in creating R, please
#> cite it when using it for data analysis. See also
#> 'citation("pkgname")' for citing R packages.

## references for a package -- might not have these installed
if(nchar(system.file(package = "lattice"))) citation("lattice")
#> 
#> To cite the lattice package in publications use:
#> 
#>   Sarkar, Deepayan (2008) Lattice: Multivariate Data Visualization
#>   with R. Springer, New York. ISBN 978-0-387-75968-5
#> 
#> A BibTeX entry for LaTeX users is
#> 
#>   @Book{,
#>     title = {Lattice: Multivariate Data Visualization with R},
#>     author = {Deepayan Sarkar},
#>     publisher = {Springer},
#>     address = {New York},
#>     year = {2008},
#>     note = {ISBN 978-0-387-75968-5},
#>     url = {http://lmdvr.r-forge.r-project.org},
#>   }
if(nchar(system.file(package = "foreign"))) citation("foreign")
#> 
#> To cite package 'foreign' in publications use:
#> 
#>   R Core Team (2018). foreign: Read Data Stored by 'Minitab', 'S',
#>   'SAS', 'SPSS', 'Stata', 'Systat', 'Weka', 'dBase', .... R
#>   package version 0.8-71.
#>   https://CRAN.R-project.org/package=foreign
#> 
#> A BibTeX entry for LaTeX users is
#> 
#>   @Manual{,
#>     title = {foreign: Read Data Stored by 'Minitab', 'S', 'SAS', 'SPSS', 'Stata',
#> 'Systat', 'Weka', 'dBase', ...},
#>     author = {{R Core Team}},
#>     year = {2018},
#>     note = {R package version 0.8-71},
#>     url = {https://CRAN.R-project.org/package=foreign},
#>   }

## extract the bibtex entry from the return value
x <- citation()
toBibtex(x)
#> @Manual{,
#>   title = {R: A Language and Environment for Statistical Computing},
#>   author = {{R Core Team}},
#>   organization = {R Foundation for Statistical Computing},
#>   address = {Vienna, Austria},
#>   year = {2019},
#>   url = {https://www.R-project.org/},
#> }


## A citation with more than one bibentry:
cm <- tryCatch(citation("mgcv"),
               error = function(e) {
                 warning("Recommended package 'mgcv' is not installed properly")
                 stop(e$message) })
cm # short entries (2-3 lines each)       
     #+end_src
**** cite
Cite a Bibliography Entry.Cite a bibentry object in text. The cite() function uses the cite() function from the default bibstyle if present, or citeNatbib() if not. citeNatbib() uses a style similar to that used by the LaTeX package natbib.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
  ## R reference
rref <- bibentry(
   bibtype = "Manual",
   title = "R: A Language and Environment for Statistical Computing",
   author = person("R Core Team"),
   organization = "R Foundation for Statistical Computing",
   address = "Vienna, Austria",
   year = 2013,
   url = "https://www.R-project.org/",
   key = "R")

## References for boot package and associated book
bref <- c(
   bibentry(
     bibtype = "Manual",
     title = "boot: Bootstrap R (S-PLUS) Functions",
     author = c(
       person("Angelo", "Canty", role = "aut",
         comment = "S original"),
       person(c("Brian", "D."), "Ripley", role = c("aut", "trl", "cre"),
         comment = "R port, author of parallel support",
         email = "ripley@stats.ox.ac.uk")
     ),
     year = "2012",
     note = "R package version 1.3-4",
     url = "https://CRAN.R-project.org/package=boot",
     key = "boot-package"
   ),

   bibentry(
     bibtype = "Book",
     title = "Bootstrap Methods and Their Applications",
     author = as.person("Anthony C. Davison [aut], David V. Hinkley [aut]"),
     year = "1997",
     publisher = "Cambridge University Press",
     address = "Cambridge",
     isbn = "0-521-57391-2",
     url = "http://statwww.epfl.ch/davison/BMA/",
     key = "boot-book"
   )
)

## Combine and cite
refs <- c(rref, bref)
cite("R, boot-package", refs)
#> [1] "(R Core Team 2013; Canty and Ripley 2012)"     
     #+end_src
**** clipboard
Transfer text between a character vector and the Windows clipboard in MS Windows (only).
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       getClipboardFormats(numeric = FALSE)
       readClipboard(format = 1, raw = FALSE)
       writeClipboard(str, format = 1)       
     #+end_src
**** txtProgressBar
Text progress bar in the R console.

#+begin_src R :results output graphics :file fig_1.png :exports both 
  testit <- function(x = sort(runif(20)), ...)
  {
      pb <- txtProgressBar(...)
      for(i in c(0, x, 1)) {Sys.sleep(0.5); setTxtProgressBar(pb, i)}
      Sys.sleep(1)
      close(pb)
  }
  testit(style = 3)
  ## |=================================================| 100%
#+end_src
**** combn
Generate all combinations of the elements of x taken m at a time. 
If x is a positive integer, returns all combinations of the elements of seq(x) taken m at a time. If argument FUN is not NULL, applies a function given by the argument to each point. If simplify is FALSE, returns a list; otherwise returns an array, typically a matrix. ... are passed unchanged to the FUN function, if specified.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       combn(letters[1:4], 2)
                                        #>      [,1] [,2] [,3] [,4] [,5] [,6]
                                        #> [1,] "a"  "a"  "a"  "b"  "b"  "c" 
                                        #> [2,] "b"  "c"  "d"  "c"  "d"  "d"  
     #+end_src
**** compareVersion
Compare two package version numbers to see which is later.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       compareVersion("1.0", "1.0-1")
                                        #> [1] -1
       compareVersion("7.2-0","7.1-12")
                                        #> [1] 1       
     #+end_src
**** compile 
Compile Files for Use with R on Unix-alikes.Compile given source files so that they can subsequently be collected into a shared object using R CMD SHLIB or an executable program using R CMD LINK. Not available on Windows.

     #+begin_src R :results output graphics :file fig_1.png :exports both 
       R CMD COMPILE [options] srcfiles       
     #+end_src
**** data
Loads specified data sets, or list the available data sets.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       require(utils)
       data()                         # list all available data sets
       try(data(package = "rpart") )  # list the data sets in the rpart package
       data(USArrests, "VADeaths")    # load the data sets 'USArrests' and 'VADeaths'
       ## Not run: ## Alternatively
       ds <- c("USArrests", "VADeaths"); data(list = ds)
       ## End(Not run)
       help(USArrests)                # give information on data set 'USArrests'
     #+end_src
**** demo
demo is a user-friendly interface to running some demonstration R scripts. demo() gives the list of available topics.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       demo() # for attached packages

       ## All available demos:
       demo(package = .packages(all.available = TRUE))


       ## Display a demo, pausing between pages
       demo(lm.glm, package = "stats", ask = TRUE)

       ## Display it without pausing
       demo(lm.glm, package = "stats", ask = FALSE)


       ## Not run: 
       ch <- "scoping"
       demo(ch, character = TRUE)

       ## End(Not run)

       ## Find the location of a demo
       system.file("demo", "lm.glm.R", package = "stats")
     #+end_src
**** file.edit
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       ## Not run: 
                                        # open two R scripts for editing
       file.edit("script1.R", "script2.R")       
     #+end_src
**** select.list
Select item(s) from a character vector.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       select.list(sort(.packages(all.available = TRUE)))
     #+end_src
**** stack/unstack
stack(打包函数) 和 tidyr 包中的 gather 函数类似，而 unstack 函数和 separate 函数类
似。
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       require(stats)
       require(datasets)
                                        #> Loading required package: datasets
       formula(PlantGrowth)         # check the default formula
                                        #> weight ~ group
       pg <- unstack(PlantGrowth)   # unstack according to this formula
       pg %>% head()
                                        #>   ctrl trt1 trt2
                                        #> 1 4.17 4.81 6.31
                                        #> 2 5.58 4.17 5.12
                                        #> 3 5.18 4.41 5.54
                                        #> 4 6.11 3.59 5.50
                                        #> 5 4.50 5.87 5.37
                                        #> 6 4.61 3.83 5.29
       stack(pg) %>% head()
                                        #>   values  ind
                                        #> 1   4.17 ctrl
                                        #> 2   5.58 ctrl
                                        #> 3   5.18 ctrl
                                        #> 4   6.11 ctrl
                                        #> 5   4.50 ctrl
                                        #> 6   4.61 ctrl  
     #+end_src
**** fix
Fix an Object.fix invokes edit on x and then assigns the new (edited) version of x in the user's workspace.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       fix(my.fun)
       my.fun %>%
           fix
     #+end_src
*** data.matrix 
可以将 data.frame 转化为 matrix,注意 matrix 中字符串也要转化为数字型。
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      DF <- data.frame(
          a = 1:3, b = letters[10:12],
          c = seq(as.Date("2004-01-01"), by = "week", len = 3),
          stringsAsFactors = TRUE
      )
      DF
                                        #>   a b          c
                                        #> 1 1 j 2004-01-01
                                        #> 2 2 k 2004-01-08
                                        #> 3 3 l 2004-01-15
      data.matrix(DF[1:2])
                                        #>      a b
                                        #> [1,] 1 1
                                        #> [2,] 2 2
                                        #> [3,] 3 3
      data.matrix(DF)
                                        #>      a b     c
                                        #> [1,] 1 1 12418
                                        #> [2,] 2 2 12425
                                        #> [3,] 3 3 12432      
    #+end_src

*** get
Search by name for an object (get) or zero or more objects (mget).

get(x, pos = -1, envir = as.environment(pos), mode = "any",
    inherits = TRUE)

mget(x, envir = as.environment(-1), mode = "any", ifnotfound,
     inherits = FALSE)

dynGet(x, ifnotfound = , minframe = 1L, inherits = FALSE)
Arguments
x	
For get, an object name (given as a character string).
For mget, a character vector of object names.

pos, envir	
where to look for the object (see ‘Details’); if omitted search as if the name of the object appeared unquoted in an expression.

mode	
the mode or type of object sought: see the ‘Details’ section.

inherits	
should the enclosing frames of the environment be searched?

ifnotfound	
For mget, a list of values to be used if the item is not found: it will be coerced to a list if necessary.
For dynGet any R object, e.g., a call to stop().

minframe	integer specifying the minimal frame number to look into.

    #+begin_src R ::results output graphics :file fig_1.png :exports both
      x <- 1
      typeof(ls())
                                        #> [1] "character"
      typeof(get("x"))
                                        #> [1] "double"
    #+end_src

get 函数取数确实好用
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      data(mtcars)
      get("mtcars")[["mpg"]]
                                        #>  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2
                                        #> [15] 10.4 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4
                                        #> [29] 15.8 19.7 15.0 21.4      
    #+end_src
*** cut
Convert Numeric to Factor.cut divides the range of x into intervals and codes the values in x according to which interval they fall. The leftmost interval corresponds to level one, the next leftmost to level two and so on.

#+begin_src R ::results output graphics :file fig_1.png :exports both
  Z <- stats::rnorm(10000)
  table(cut(Z, breaks = -6:6))
                                        #> 
                                        #> (-6,-5] (-5,-4] (-4,-3] (-3,-2] (-2,-1]  (-1,0]   (0,1]   (1,2]   (2,3] 
                                        #>       0       0       9     198    1357    3495    3421    1284     224 
                                        #>   (3,4]   (4,5]   (5,6] 
                                        #>      12       0       0
#+end_src




*** stop

    #+begin_src R :results output graphics :file fig_1.png :exports both 
      my_sqrt <- function(x){
          if (x<0) {
              stop("x must be positive!")
          }else{
              sqrt(x)
          }
      }

      my_sqrt(-1)

      my_sqrt <- function(x){
          if (x<0) {
              rlang::abort(message = "x must be positive!",
                           .subclass = "my_sqrt_error",
                           x=x)
          }else{
              sqrt(x)
          }
      }
      my_sqrt(-1)      
    #+end_src

*** data.class
Determine the class of an arbitrary R object.
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      x <- LETTERS
      x
                                        #>  [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q"
                                        #> [18] "R" "S" "T" "U" "V" "W" "X" "Y" "Z"
      data.class(factor(x))
                                        #> [1] "factor"
      data.class(matrix(x, ncol = 13))
                                        #> [1] "matrix"      
    #+end_src



*** substitute
substitute returns the parse tree for the (unevaluated) expression expr, substituting any variables bound in env.
这个 substitute 其实就是 rlang 包里的 expr,顾名思义其实就是 expression,其 typeof 是 language.
这个操作经常和 eval 放在一起使用。
下面的例子说明%>% 不是万能的！！
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      substitute(b <- 1) %>% eval()
      b
                                        #> Error in eval(expr, envir, enclos): 找不到对象'b'
      eval(substitute(b <- 1))
      b
                                        #> [1] 1

      expr(e <- 1) %>% eval_tidy()
                                        #> [1] 1
      e
                                        #> Error in eval(expr, envir, enclos): 找不到对象'e'
      eval(expr(e <- 1))
      e
                                        #> [1] 1
    #+end_src
*** deparse
Turn unevaluated expressions into character strings.
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      args(lm) %>% typeof()
                                        #> [1] "closure"
      deparse(args(lm))
                                        #> [1] "function (formula, data, subset, weights, na.action, method = \"qr\", " 
                                        #> [2] "    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, "
                                        #> [3] "    contrasts = NULL, offset, ...) "                                    
                                        #> [4] "NULL"      
    #+end_src

** 7.1 dplyr
这个包主要包括 5 个核心函数，分别是:
*** filter
filter:按值筛选观测（相当于 sql 中的 select），filter 选择行，而 select 选择列，
也就是特征。参数中 .preserve=T 表示保持当前的分组结果，所以这个参数一般和
group_trim 和 group_keys() 配合使用，一般默认的是 false,具体例子可以考虑下面的例
子。

filter(data,var=所限定的条件)

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  library(nycflights13)
  library(tidyverse)
  filter(flights, month == 1, day == 1) # 将一月一号的航班挑出来
  filter(flights, month == 1 & day == 1) # &是“与”
  filter(flights, month == 11 | month == 12) #|是“或”
  filter(flights, month == 11 | 12) # 这里程序会先判断 11|12 的值为 TRUE，也就是 1，所以程序其实为 filter(flights, month == 1)
  filter(flights, month %in% c(11, 12)) # 这个结果等价于 filter(flights, month == 11 | month == 12)
##加上.preserve 的好处在于可以保留group_keys.
iris %>%
      group_by(Species) %>%
    filter(Species == "setosa", .preserve = TRUE) %>%
    group_keys()

  ## Species   
##   <fct>     
## 1 setosa    
## 2 versicolor
## 3 virginica 
  
  iris %>%
      group_by(Species) %>%
      filter(Species == "setosa") %>%
      group_keys()
  ## Species
  ## <fct>  
  ##      1 setosa 
#+END_SRC

**** filter_all
 配合 all_vars 和 any_vars 一起用。
 #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
   filter_all(mtcars, all_vars(. > 1))
   filter_all(mtcars, any_vars(. > 1))
 #+END_SRC

 #+begin_src R ::results output graphics :file fig_1.png :exports both
   enframe(1:10) %>%
       add_row(name = -4, value = 6) %>%
       filter_all(all_vars(. > 5))
                                        #> # A tibble: 5 x 2
                                        #>    name value
                                        #>   <dbl> <dbl>
                                        #> 1     6     6
                                        #> 2     7     7
                                        #> 3     8     8
                                        #> 4     9     9
                                        #> 5    10    10

   enframe(1:10) %>%
       add_row(name = -4, value = 6) %>%
       filter_all(any_vars(. > 5))
                                        #> # A tibble: 6 x 2
                                        #>    name value
                                        #>   <dbl> <dbl>
                                        #> 1     6     6
                                        #> 2     7     7
                                        #> 3     8     8
                                        #> 4     9     9
                                        #> 5    10    10
                                        #> 6    -4     6   
 #+end_src

这么看起来，any_vars 要求更高！
 
**** filter_at
对确定的变量进行筛选。

 #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
 filter_at(mtcars, vars(starts_with("d")), any_vars((. %% 2) == 0))
 #+END_SRC

**** filter_if

 #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
 filter_if(mtcars, ~ all(floor(.) == .), all_vars(. != 0))
 #+END_SRC
 
*** first/last/nth
可以对 vector 
Usage
nth(x, n, order_by = NULL, default = default_missing(x))

first(x, order_by = NULL, default = default_missing(x))

last(x, order_by = NULL, default = default_missing(x))
Arguments
x	A vector.

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  x <- 1:10
  y <- 10:1
  x %>% first()
  x %>% nth(5)
  y %>% last()
  nth(x, 5)
#+END_SRC

*** arrange
arrange(data, var1, var2, ……) #优先按照 var1 升序排列，其次是 var2,接着....
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  library(tidyverse)
  library(nycflights13)
  arrange(flights, year, month, day) # 按照 year,month,day 升序排列
  arrange(flights, desc(arr_delay)) # 将 arr_delay 字段按照降序排列
  flights %>% group_by(month) %>% summarise(arrtime = mean(dep_delay, na.rm = TRUE)) %>% arrange(desc(arrtime))
#+END_SRC

知识点盲区：

之前一直以为 group_by() 和 arrange 一起使用是指这样，

#+begin_src R ::results output graphics :file fig_1.png :exports both
  mtcars %>%
      head() %>%
      group_by(cyl) %>%
      arrange(mpg)
#+end_src
长成这样的，没想到其实是这样的。
#+begin_src R ::results output graphics :file fig_1.png :exports both
  mtcars %>%
      head() %>%
      group_by(cyl) %>%
      arrange(cyl, mpg)
                                        #> # A tibble: 6 x 11
                                        #> # Groups:   cyl [3]
                                        #>     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
                                        #>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
                                        #> 1  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1
                                        #> 2  18.1     6   225   105  2.76  3.46  20.2     1     0     3     1
                                        #> 3  21       6   160   110  3.9   2.62  16.5     0     1     4     4
                                        #> 4  21       6   160   110  3.9   2.88  17.0     0     1     4     4
                                        #> 5  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1
                                        #> 6  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2  
#+end_src

需要注意！

*** select

> select(data,var1,var2,...) #从 data 中选择 var1 和 var2 等变量

select 还有一种变型，select(c("character")) 能够处理 character strings.select 命令结合其他子命令可以对数据进行多种选择，包括：

- starts_with(): Starts with a prefix.
- ends_with(): Ends with a suffix.
- contains(): Contains a literal string.
- matches(): Matches a regular expression.
- num_range(): Matches a numerical range like x01, x02, x03.这里有个有趣的地方就是，参数 width =2 or width=1,结果不同。
- one_of(): Matches variable names in a character vector. one_of 函数特点是可以匹配到名称为准确的变量，而 select 不行。
- everything(): Matches all variables. 调换变量名称非常有用处。
- last_col(): Select last variable, possibly with an offset.

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  select(flights, time_hour, air_time, everything()) # 将 time_hour,air_time 两个变量提前
#+END_SRC

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
###some example--------------------------------------------
iris %>% select(starts_with("Petal"))
iris %>% select(ends_with("Width"))
iris %>% select(contains("etal")) %>% head(2)
iris %>% select(matches(".t.")) %>% head(2) #含有 t
flights %>%
    select(matches("^(dep|arr)_"))
iris %>% select(everything()) %>% head(2) #选择所有变量
iris %>% select(last_col()) %>% head(2) #选择所有变量
iris %>% select(last_col(offset = 1)) %>% head(2) #选择倒数第 2 列变量
iris %>% select(one_of(c("Petal.Length", "Petal.Width"))) %>% head(2) #Matches variable names in a character vector.
iris %>% mutate(X01=1,X02=2) %>% select(num_range("X0",1:2))

data3 <- flights
colnames(data3) <- sprintf("x%02d", 1:19)
select(data3, num_range("x", 8:11, width = 2)) 
# A tibble: 336,776 x 4
## x08   x09 x10     x11
## <int> <dbl> <chr> <int>
##                        1   819    11 UA     1545
## 2   830    20 UA     1714
select(data3, num_range("x", 8:11, width = 1))
                       ##                  A tibble: 336,776 x 2
## x10     x11
## <chr> <int>
##            1 UA     1545
#+END_SRC

**** select_all(),select_at(),select_if()
  
select_all(.tbl, .funs = list(), ...)
select_at(.tbl, .vars, .funs = list(), ...)

select_at(mtcars,vars(-contains("ar"),starts_with("c")),toupper) 这句有些意思，首先删除变量名中有 "ar" 的变量，然后保留有 "c" 的变量名称,如果一个变量名叫“car”，那么这个变量会被保留下来。这点需要注意。

综合 select_all,select_if,select_all 三个变量函数来看，都是中.vars 名称上作文章。

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  # Supply a renaming function:
  select_all(mtcars, "toupper")
  select_all(mtcars)
  mtcars %>% select_all(toupper) #对所有变量字母命名全部改为大写
  select_at(mtcars, vars(-everything())) #删除所有变量
  select_at(mtcars, vars(-contains("ar"), starts_with("c")), toupper) #选择删除的变量，然后作相应的处理
  # Selection drops unselected variables:
  is_whole <- function(x) all(floor(x) == x)
  select_if(mtcars, is_whole, toupper) #可以挑选满足条件的特征
  select_if(mtcars, is_whole) #只保留满足条件的变量
#+END_SRC

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
library(tidyverse)
library(nycflights13)
select(flights, year, month, day) # 从 flights 数据集中选择出 year,month,day 三个变量
select(flights, year:day) # 选择出“year”和“day”之间的所有列
select(flights, -(year:day)) # 选择出不在“year”和"day"之间的所有列

flights %>%
  select(ends_with("delay"))
flights %>%
  select(contains("dep"))
flights %>%
  select(matches("dep"))
flights %>%
  select(matches("^(dep|arr)_"))

data2 <- flights
colnames(data2) <- sprintf("x%d", 1:19) # 字符
select(data2, num_range("x", 8:11))
select(data2, num_range("x", c(9, 11)))

data3 <- flights
colnames(data3) <- sprintf("x%02d", 1:19)
select(data3, num_range("x", 8:11, width = 2))

vars <- c("year", "month", "day")
select(flights, !!vars)
group_by_at(flights, vars(year:day)) # 在 dplyr 中，变体后缀_at()在他们的第二个参数中支持 select 语义。你只需要用 vars（）包裹这个选择.
#+END_SRC

*** pull
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  mtcars %>% pull(-1) #可以取最后一列的数值
  mtcars %>% pull(1) #可以取第一列的数值
  mtcars %>% pull(cyl) #可以取cyl 变量的数值
#+END_SRC
*** group_by

这里有个参数比较重要，.drop=FALSE，就是将 group 内没有的观测显示出来，而默认的是
不显示。可以用 group_by_drop_default() 显示是否将没有的观测扔掉。

You can group by expressions: this is just short-hand for a mutate/rename
followed by a simple group_by mtcars %>% group_by(vsam = vs + am)

Use add = TRUE to instead append

by_cyl %>%
       group_by(vs, am, add = TRUE) %>%
       group_vars()

下面这个例子可以更好地说明这个问题。

#+begin_src R :results output graphics :file fig_1.png :exports both 
mtcars %>% 
  group_by(cyl) %>% 
  group_by(hp) %>% 
  head()
#> # A tibble: 6 x 11
#> # Groups:   hp [4]
#>     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
#>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
#> 1  21       6   160   110  3.9   2.62  16.5     0     1     4     4
#> 2  21       6   160   110  3.9   2.88  17.0     0     1     4     4
#> 3  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1
#> 4  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1
#> 5  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2
#> 6  18.1     6   225   105  2.76  3.46  20.2     1     0     3     1
  
  mtcars %>% 
  group_by(cyl) %>% 
  group_by(hp,add = T) %>% 
  head()
#> # A tibble: 6 x 11
#> # Groups:   cyl, hp [4]
#>     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
#>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
#> 1  21       6   160   110  3.9   2.62  16.5     0     1     4     4
#> 2  21       6   160   110  3.9   2.88  17.0     0     1     4     4
#> 3  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1
#> 4  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1
#> 5  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2
#> 6  18.1     6   225   105  2.76  3.46  20.2     1     0     3     1  
#+end_src

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  daily <- flights %>% group_by(year, month, day)
head()
  data= data.frame(date=c("20190102","20190102","20190102","20190103","20190104","20190105"),value=c(1,2,1,2,3,4))
  data=data %>% mutate(date=as.character(date))
  data %>% group_by(date) %>% arrange(desc(value)) %>% filter(row_number() == 1)
  typeof(data$date)
  mtcars %>%
      group_by(vsam = vs+am) %>%
      tally
  by_cyl <- mtcars %>%
      group_by(cyl)
  by_cyl %>%
      group_by(vs,am) %>%
      group_vars()
#+END_SRC

group_by 函数里面有一个参数 .drop, 如果是 .drop=FALSE 那么意味着可以显示没有的观
测水平的变量，否则就不显示了，具体例子如下。

  #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
    iris$Species = factor(iris$Species, levels=c(levels(iris$Species), "empty_level"))
                                          # Species is a factor and empty groups are included in the output
    iris %>% group_by(Species, .drop=FALSE) %>% tally
                                          #>   Species         n
                                          #> 1 setosa         50
                                          #> 2 versicolor     50
                                          #> 3 virginica      50
                                          #> 4 empty_level     0

                                          # Add character column
    iris$group2 = c(rep(c("A","B"), 50), rep(c("B","C"), each=25))
                                          # Empty groups involving combinations of Species and group2 are not included in output
    iris %>% group_by(Species, group2, .drop=FALSE) %>% tally %>% group_by_drop_default()
  #+END_SRC

**** group_by_all,group_by_at,group_by_if

group_by_all,group_by_if,group_by_at 这 3 个函数等价于 group()+mutate(),比如 iris %>% group_by_all(is.factor) = iris %>% group_by(everything) %>% mutate(everything()=is.factor()).
group_by_if(is.factor,as.character) 等价于 iris %>% group_by() %>% mutate(as.char(is.factor)) 
 
  #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  # Group a data frame by all variables:
  group_by_all(mtcars)
  # Group by variables selected with a predicate:
  group_by_if(iris, is.factor) #factor
  # Group by variables selected by name:
  group_by_at(mtcars, vars(vs, am))
  # Like group_by(), the scoped variants have optional mutate
  # semantics. This provide a shortcut for group_by() + mutate():
  d <- tibble(x=c(1,1,2,2), y=c(1,2,1,2))
  group_by_all(d, as.factor)
  group_by_if(iris, is.factor, as.character)
  data <- data.frame(id=c(1,1,3,2,3),abx=c(1,2,1,2,3))
  data %>% 
      group_by_at(vars(-contains("b"))) %>% 
      tally()
  #+END_SRC

dplyr will have a specialized group_by function group_by_at to deal with multiple grouping variables. It would be much easier to use the new member of the _at family:
group_by_at 命令可以接受 character 型变量。

  #+begin_src R ::results output graphics :file fig_1.png :exports both
    cols <- c("am", "gear")
    mtcars %>%
        group_by_at(.vars = cols) %>%
        summarise(mean_cyl = mean(cyl))
                                        #> # A tibble: 4 x 3
                                        #> # Groups:   am [2]
                                        #>      am  gear mean_cyl
                                        #>   <dbl> <dbl>    <dbl>
                                        #> 1     0     3     7.47
                                        #> 2     0     4     5   
                                        #> 3     1     4     4.5 
                                        #> 4     1     5     6    
  #+end_src

  #+begin_src R :results output graphics :file fig_1.png :exports both 
    group_by_at(mtcars, vars(vs, am))
                                        #> # A tibble: 32 x 11
                                        #> # Groups:   vs, am [4]
                                        #>      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
                                        #>  * <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
                                        #>  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
                                        #>  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
                                        #>  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
                                        #>  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
                                        #>  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
                                        #>  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
                                        #>  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
                                        #>  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
                                        #>  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
                                        #> 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4 
  #+end_src

**** group_cols,group_rows
该函数可以显示成组的变量名字 

  #+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
    #ggplot::results output graphics,plot::results graphics 
    gdf <- iris %>% group_by(Species) %>% select(group_cols())
gdf
  #+END_SRC

group_rows() just returns the list of indices.

这个 group_rows 很像 group_data,不同的是 group_data 可以生成一个带有 group 变量的 tibble.

  #+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
    #ggplot::results output graphics,plot::results graphics 
    xiaomi_id <- c("1","2","3","1")
    credit_time <- c("20190101","20190201","20190401","20190101")
    x1 <- seq(1:4)
    df1 <- tibble(xiaomi_id,credit_time,x1)
                                        #df1 %>% mutate(dplyr::row_number(xiaomi_id
    df1 %>% 
        group_by(xiaomi_id) %>% 
        group_rows()
                                        #> [[1]]
                                        #> [1] 1 4
                                        #> 
                                        #> [[2]]
                                        #> [1] 2
                                        #> 
                                        #> [[3]]
                                        #> [1] 3
  #+END_SRC

**** group_data()
group_data() return a tibble with one row per group. 

  #+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
    #ggplot::results output graphics,plot::results graphics 
    df <- tibble(x = c(1,1,2,2))
                                          # one row
    group_data(df)
  #+END_SRC

**** group_split

  group_split() works like base::split() but it uses the grouping structure from
  group_by() and therefore is subject to the data mask.

  这个函数和 split() 类似，和 split 一致的是，同样生成的是 list 型，但是不同的是
  group_split 生成的是纯粹的 list 型数据。

  #+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
    #ggplot::results output graphics,plot::results graphics 
  ir <- iris %>%
    group_by(Species)
  group_split(ir)

    iris %>% split(.$Species) %>%
       head 
  #+END_SRC

**** group_keys

group_keys() returns a tibble with one row per group, and one column per grouping variable.

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
#ggplot::results output graphics,plot::results graphics 
    ir <- iris %>%
        group_by(Species)
    group_keys(ir)
#+END_SRC

**** group_trim
去除固定水平的数据，往往和 filter 相结合使用，这个函数就像一个剪刀一样。
Drop unused levels of all factors that are used as grouping variables, then recalculates the grouping structure.

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
#ggplot::results output graphics,plot::results graphics 
is <- iris %>%
      group_by(Species) %>%
      filter(Species == "setosa", .preserve = TRUE) %>%
      group_trim()
is %>% group_keys()
#+END_SRC

**** group_map()
group_map() returns a list of results from calling .f on each group.
运行之后就会觉得 group_map 很像 lapply.
这个函数对于处理分组数据的操作很方便！
  #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
    mtcars %>%
        group_by(cyl) %>%
        group_map(~ head(.x, 2L))
    iris %>%
        group_by(Species) %>%
        group_map(~ quantile(.x$Petal.Length, probs = c(0.25, 0.5, 0.75)))
  #+END_SRC

  #+begin_src R ::results output graphics :file fig_1.png :exports both
    enframe(1:3) %>% 
        add_column(group=c("1","2","3")) %>% 
        add_row(name=1,value=3,group="2") %>% 
        group_by(name) %>% 
        dplyr::arrange(name,value) %>% 
        group_map(~sort(.$group,decreasing = T))    
  #+end_src

**** group_modify()

group_modify 和 group_map 函数非常相似，所不同的是，group_modify 生成的是一个 tibble 类型的数据，而 group_map 生成的是 list 型数据。group_modify() returns a grouped tibble. In that case .f must return a data frame.

  #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
    mtcars %>%
        group_by(cyl) %>%
        group_modify(~ head(.x, 2L))
                                          #可以对比下
    mtcars %>%
        group_by(cyl) %>%
        head(2)
  #+END_SRC

**** group_nest
将数据进行压缩。
  #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
    iris %>%
        group_by(Species) %>%
        group_nest()
    ##                                     # A tibble: 3 x 2
    ## Species    data             
    ## <fct>      <list>           
    ##                 1 setosa     <tibble [50 x 4]>
    ##                       2 versicolor <tibble [50 x 4]>
    ##                             3 virginica  <tibble [50 x 4]>
  #+END_SRC

**** group_size/n_groups
n_group returns 组数，group_size 返回的是每组有多少样本量。
     #+begin_src R ::results output graphics :file fig_1.png :exports both
       data <- data.frame(id=c(1,2,3,1),x=c(2,3,4,5))
       data %>% 
           group_by(id) %>% 
           n_groups()

       data %>% 
           group_by(id) %>% 
           group_size()  
     #+end_src
**** ungroup

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  dim(daily)
  dim(daily %>%
      ungroup())

  daily %>%
      ungroup() %>% # 不再按日期分组
      summarize(flights = n()) # 所有航班
#+END_SRC
**** group_indices 
返回记录所在组 id
     #+begin_src R ::results output graphics :file fig_1.png :exports both
       mtcars %>% 
           group_indices(cyl)
       mtcars %>% head()       
     #+end_src
**** groups/group_vars 
返回的是分组变量的名称。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  df <- tibble(x = 1, y = 2) %>% group_by(x,y)
  df
    groups(df) #list型
  ## [[1]]
  ## x

  ## [[2]]
  ## y
group_vars(df)
  ## [1] "x" "y"  
#+END_SRC

*** rename
对变量重新命名

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  rename(flights, tail_num = tailnum) # 将变量 tailnum 命名为 tail_num
  vars <- c(var1 = "cyl", var2 ="am")
  select(mtcars, !!vars)
  rename(mtcars, !!vars) #还可以这么玩～
#+END_SRC

当然少不了三件套：rename_if/rename_at/rename_all.

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
# But renaming retains them:
is_whole <- function(x) all(floor(x) == x)
rename_if(mtcars, is_whole, toupper)
rename_at(mtcars, vars(-(1:3)), toupper)
rename_all(mtcars, toupper)
#+END_SRC

需要注意的是 rename_at 和 select_at 都能对变量进行作 toupper,但是 select_at 能够对变量进行筛选。
类似的函数还有 recode 等。
*** mutate
mutate:使用现有变量的函数创建新变量,新变量总是放在最后
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  flights_sml <- select(
      flights,
      year:day,
      ends_with("delay"),
      distance,
      air_time
  )
  mutate(flights_sml,
         gain = arr_delay - dep_delay,
         speed = distance / air_time * 60
         )
#+END_SRC
**** mutate_all()
利用 mutate_all 可以实现对所有变量进行科学计算。
     #+begin_src R ::results output graphics :file fig_1.png :exports both
       mtcars %>% 
           group_by(cyl) %>% 
           mutate_all(`*`,100) %>% 
           head()       
     #+end_src
**** mutate_if()

 #+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
   #ggplot::results output graphics,plot::results graphics 
                                         # mutate_if() is particularly useful for transforming variables from
                                         # one type to another
   iris_new=iris %>% mutate_if(is.factor, as.character)
   str(iris)
   str(iris_new) #可以发现原来 Species 变量为因子型，经过 mutate_if 后变成了 char 型
                                         # If you want to apply multiple transformations, pass a list of
                                         # functions. When there are multiple functions, they create new
                                         # variables instead of modifying the variables in place:
   iris %>% mutate_if(is.numeric, list(~log(.))) #对所有 numeric 型的变量取对数
 #+END_SRC
**** mutate_at()

mutate_at 真是谁用谁知道哈～ mutate_at 针对固定的列作变换真是谁用谁知道。
一个细节就是对列作函数变换时需要~str_split(.,"_X"),是点不需要加上其他操作。

  对特定的列作特定的函数映射。
  #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
    scale2 <- function(x, na.rm = FALSE) (x - mean(x, na.rm = na.rm)) / sd(x, na.rm)
    starwars %>% mutate_at(c("height", "mass"), scale2)
    starwars$
  #+END_SRC

  #+begin_src R ::results output graphics :file fig_1.png :exports both
    df1 %>% 
        mutate_at(1,~str_sub(.,1,str_length(.)-4)) %>% 
        add_column(var_bin=df1$var) %>% 
        mutate(num=var_bin) %>% 
        mutate_at("num",~str_split(.,"_X") %>% map_chr(2)) %>% 
        dplyr::group_by(var) %>% 
        arrange(var,desc(value)) %>% 
        mutate(num2=num) %>%
        mutate_at("num2",~sort(.,decreasing = T)) %>% 
        mutate(num3=num) %>% 
        mutate_at("num3",~sort(.,decreasing = F)) %>% head()

    df1 %>% 
        mutate_at(1,~str_sub(.,1,str_length(.)-4)) %>% 
        add_column(var_bin=df1$var) %>% 
        mutate(num=var_bin) %>% 
        mutate_at("num",~str_split(.,"_X") %>% map_chr(2)) %>% 
        dplyr::group_by(var) %>% 
        arrange(var,desc(value)) %>% 
        mutate(num2=num) %>%
        mutate_at("num2",~sort(.,decreasing = T)) %>% 
        mutate(num3=num) %>% 
        mutate_at("num3",~sort(.,decreasing = F)) %>% 
        dplyr::summarise(equal_ratio=(mean(num==num2|num==num3)))
                                        # A tibble: 6 x 6
                                        # Groups:   var [2]
    ## var                                value var_bin                            num   num2  num3 
    ## <chr>                              <dbl> <chr>                              <chr> <chr> <chr>
                                                                                                 ## 1 als_d15_cell_nbank_cf_allnum    0.0477   als_d15_cell_nbank_cf_allnum_X03   03    05    01   
    ## 2 als_d15_cell_nbank_cf_allnum   -0.000132 als_d15_cell_nbank_cf_allnum_X01   01    04    02   
    ## 3 als_d15_cell_nbank_cf_allnum   -0.00798  als_d15_cell_nbank_cf_allnum_X02   02    03    03   
    ## 4 als_d15_cell_nbank_cf_allnum   -0.0270   als_d15_cell_nbank_cf_allnum_X04   04    02    04   
    ## 5 als_d15_cell_nbank_cf_allnum   -0.128    als_d15_cell_nbank_cf_allnum_X05   05    01    05   
    ## 6 als_d15_cell_nbank_else_allnum  0.296    als_d15_cell_nbank_else_allnum_X05 05    05    03   
  #+end_src
*** transmute
如果只想保留新变量，可以使用 transmute() 函数：

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  transmute(flights,
            gain = arr_delay - dep_delay,
            hours = air_time / 60,
            gain_per_hour = gain / hours
            )
#+END_SRC

transmute_all(.tbl, .funs, ...)

transmute_if(.tbl, .predicate, .funs, ...)

transmute_at(.tbl, .vars, .funs, ..., .cols = NULL)

同样三件套。

*** add_column()/add_row()
这个函数和 mutate 一样，可以实现迅速添加列的目的
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  # add_column ---------------------------------
  df <- tibble(x = 1:3, y = 3:1)
  add_column(df, z = -1:1, w = 0)
  add_row(df, x = 4, y = 0)
                                        # You can specify where to add the new rows
  add_row(df, x = 4, y = 0, .before = 2)
                                        # You can supply vectors, to add multiple rows (this isn't
                                        # recommended because it's a bit hard to read)
  add_row(df, x = 4:5, y = 0:-1)
                                        # Absent variables get missing values
  add_row(df, x = 4)
#+END_SRC

*** bind_rows\bind_cols

这个函数有些奇怪，在处理 list 型数据时，需要注意。

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  ll <- list(
      a = c(A = 1, B = 2),
      b = c(A = 3, B = 4)
  )
  ll
  bind_rows(ll)
  bind_rows(!!!ll)
                                        ## # A tibble: 2 x 2  
##       A     B
##   <dbl> <dbl>
## 1     1     2
## 2     3     4
  df1 <- data.frame(id=c(1,2,3),x=c(3,4,5))
  df2 <- data.frame(id=c(1,2),x=c(6,7))
  bind_rows(df1,df2)
  bind_rows(df1,df2, .id = "id") # 会产生一个新的变量名叫 id  
                                        # You can circumvent that behaviour with explicit splicing:
#+END_SRC

要想获得和原数据一致的格式，还是要用 bind_rows(!!!ll) 命令。

同理的函数 bind_cols()

*** summarise

summarise:将多个值总结为一个摘要统计量。需要注意这个函数在 plyr 里面也有，如果不注意会得到错误的值。

n():目前每个分组观测值得数量

n_distinct(x):x 中不重复值的数量，与 length(unique())作用相同。

first(x),last(x),nth(x):作用与 x[1],x[length(x)],x[n]相似。

经常和 group_by()一起使用，

#+begin_src R ::results output graphics :file fig_1.png :exports both
 flights %>%
  group_by(month) %>%
  summarise(
    first(dep_time),
    last(arr_delay),
    nth(arr_time, 5, order_by = year),
    n(),
    n_distinct(year)
  )
#> # A tibble: 12 x 6
#>    month `first(dep_time~ `last(arr_delay~ `nth(arr_time, ~ `n()`
#>    <int>            <int>            <dbl>            <int> <int>
#>  1     1              517               NA              812 27004
#>  2     2              456               NA              859 24951
#>  3     3                4               NA              746 28834
#>  4     4              454               NA              914 28330
#>  5     5                9               NA              831 28796
#>  6     6                2               NA              925 28243
#>  7     7                1               NA              300 29425
#>  8     8               12               NA              420 29327
#>  9     9                9               NA              906 27574
#> 10    10              447               NA              917 28889
#> 11    11                5               NA              831 27268
#> 12    12               13               NA              845 28135 
#+end_src


**** summarise_each()

 #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
   summarize(flights, delay = mean(dep_delay, na.rm = TRUE)) # 将 delay 变量定义为 dep_delay 均值
 #+END_SRC

 #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
 da <- data.frame(id=c("1","1","2"),label=c(1,0,1))
 da %>% group_by(id) %>% mutate(label=max(label))
 da %>% group_by(id) %>% summarize(label = max(label))
 #+END_SRC

 #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
 by_day <- group_by(flights, year, month, day)
 summarize(by_day, delay = mean(dep_delay, na.rm = TRUE))
     flights %>%
       group_by(dest) %>%
       summarise(
           planes = n_distinct(tailnum),
           flights = n(),
           f = sum(flights),
           fistv = first(tailnum),
           lastv = last(tailnum),
           iqr = IQR(dep_time, na.rm = TRUE),
           nthv = nth(tailnum, 12) # tailnum[12]
       )
   summarise_each(y, mean) # 求解数据每一列的均值
   mtcars %>% tally() # tally()相当于 summaries，count
   mtcars %>%
       group_by(cyl) %>%
       tally()
   mtcars %>% add_tally()
 #+END_SRC

 summarise 可以结合！！很方便。

 #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
 mass <- 100 
   starwars %>% summarise(avg = mean(mass/!!mass,na.rm = T))
 #+END_SRC

 还可以结合 any()/all() 来做一些操作：再补充！

 Given a set of logical vectors, is at least one of the values true?
 #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
 range(x <- sort(round(stats::rnorm(10) - 1.2, 1)))
 if(any(x < 0)) cat("x contains negative values\n")
 #+END_SRC

**** summarise_at

  #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
    df1=data.frame(id=c(1,2,2,3,3),x=c(2,6,5,6,9))
    df1 %>% 
        summarise_at(vars(x),list(n=~n(),mean=mean,median=median))
                                          #等价于
    df1 %>% 
        summarise_at(vars(x),list(~n(),~mean(.),~median(.)))
  #+END_SRC

**** summarise_all

     #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
       # 平均值，字符平均值返回 NA
       summarise_all(flights, mean) #返回所有变量的,其实这也是发现有缺失值的好方法
       summarise_all(flights, sd,na.rm = TRUE) #返回所有变量的
     #+END_SRC

   - 其他窗口函数

   cumall，cumany,cummean

   #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
   # `cummean()` returns a numeric/integer vector of the same length
   # as the input vector.
   x <- c(1, 3, 5, 2, 2)
   cummean(x)
   #> [1] 1.00 2.00 3.00 2.75 2.60
   cumsum(x) / seq_along(x)
   #> [1] 1.00 2.00 3.00 2.75 2.60

   # `cumall()` and `cumany()` return logicals
   cumall(x < 5)
   #> [1]  TRUE  TRUE FALSE FALSE FALSE
   cumany(x == 3)
   #> [1] FALSE  TRUE  TRUE  TRUE  TRUE

   # `cumall()` vs. `cumany()`
   df <- data.frame(
     date = as.Date("2020-01-01") + 0:6,
     balance = c(100, 50, 25, -25, -50, 30, 120)
   )
   # all rows after first overdraft
   df %>% filter(cumany(balance < 0))
   #>         date balance
   #> 1 2020-01-04     -25
   #> 2 2020-01-05     -50
   #> 3 2020-01-06      30
   #> 4 2020-01-07     120
   # all rows until first overdraft
   df %>% filter(cumall(!(balance < 0)))
   #+END_SRC

*** sample_n
使用 sample()和 sample_frac()获得一定数量的随机样本，使用 sample_n()可以选择固定的行数，sample_frac()可选择占总行数固定比例的行数。使用 replace=TRUE 时为有放回的取样（即有可能重复取样）。如果需要，可以用 weight 参数来对取样的数据进行权重设置。

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  sample_n(flights, 10)
  flights %>% sample_n(10) #随机抽样
  sample_frac(flights, 0.01) #按照一定的抽样比例来抽
  slice(flights, 10:15) # 筛选出固定行位置
  top_n(flights, 5, wt = dep_time) # 按照 dep_time 升序排序
  flights %>% top_n(-2)
  flights %>% top_frac(.5)
#+END_SRC

ToDo:
是不是 filter(row_number()==1) 等价于 top_n(1)?

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
df1 %>% 
  group_by(id) %>% 
  arrange(desc(x)) %>% 
  filter(row_number()==1)

df1 %>% 
  group_by(id) %>% 
  arrange(desc(x)) %>%
  top_n(1)
#+END_SRC

#+begin_src R ::results output graphics :file fig_1.png :exports both
  mtcars %>%
      group_by(cyl) %>%
      arrange(desc(carb)) %>%
      select(cyl, carb) %>%
      filter(row_number() == 1)
                                        #> # A tibble: 3 x 2
                                        #> # Groups:   cyl [3]
                                        #>     cyl  carb
                                        #>   <dbl> <dbl>
                                        #> 1     8     8
                                        #> 2     6     6
                                        #> 3     4     2

  mtcars %>%
      group_by(cyl) %>%
      arrange(desc(carb)) %>%
      select(cyl, carb) %>%
      top_n(1)
                                        #> Selecting by carb
                                        #> # A tibble: 8 x 2
                                        #> # Groups:   cyl [3]
                                        #>     cyl  carb
                                        #>   <dbl> <dbl>
                                        #> 1     8     8
                                        #> 2     6     6
                                        #> 3     4     2
                                        #> 4     4     2
                                        #> 5     4     2
                                        #> 6     4     2
                                        #> 7     4     2
                                        #> 8     4     2  
#+end_src

从上述这个例子可以看出，top_n(2) 会输出所有值为 rank=2 的数值，但是 filter(row_number() == 1) 只会输出一条记录。

*** tally
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  # tally() is short-hand for summarise(n())
  mtcars %>% tally()
                                        #>    n
                                        #> 1 32
#+END_SRC

*** add_tally
从下面的例子可以看出，新生成了一列数据 n.
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  # add_tally() is short-hand for mutate(n())
  mtcars %>%
      add_tally() %>%
      head() %>%
      select(mpg, cyl, n)
                                        #> # A tibble: 6 x 3
                                        #>     mpg   cyl     n
                                        #>   <dbl> <dbl> <int>
                                        #> 1  21       6    32
                                        #> 2  21       6    32
                                        #> 3  22.8     4    32
                                        #> 4  21.4     6    32
                                        #> 5  18.7     8    32
                                        #> 6  18.1     6    32
#+END_SRC

*** count
如果一个表有主键，比如说，xiaomi_id,credit_time,最好验证下，看看是否真正唯一标识
每个观测。
#+begin_src R :results output graphics :file fig_1.png :exports both 
  xiaomi_id <- c("1","2","3","1")
  credit_time <- c("20190101","20190201","20190401","20190101")
  x1 <- seq(1:4)
  df1 <- tibble(xiaomi_id,credit_time,x1)
  df1 %>% count(xiaomi_id,credit_time) %>% 
      filter(n>1)
                                        #> # A tibble: 1 x 3
                                        #>   xiaomi_id credit_time     n
                                        #>   <chr>     <chr>       <int>
                                        #> 1 1         20190101        2  
#+end_src

count() is a short-hand for group_by() + tally().
count(sort=T/F,name="",wt=),注意 count 函数可以结合 weight 权重函数进行计算。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  # count() is a short-hand for group_by() + tally()
  mtcars %>% count(cyl,sort = TRUE,name = "n_cyl") #甚至你可以重新命名
#+END_SRC
*** distinct
找出数据表中不同的数据项
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  df <- tibble(x = rep(2:5, each = 2) / 2, y = rep(2:3, each = 4) / 2)
  df %>% distinct() 
  distinct_all(df)
  df %>% distinct(x)
  distinct_at(df, vars(x))
  distinct_if(df, is.numeric) #针对numeric 型数据去重
#+END_SRC

*** do()
You can use do() to perform arbitrary computation, returning either a data frame or arbitrary objects which will be stored in a list. This is particularly useful when working with models: you can fit models per group with do() and then flexibly extract components with either another do() or summarise().
这个函数可以灵活利用各种函数，棒！目标对象应该是 data.frame 型。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
by_cyl <- group_by(mtcars, cyl)
do(by_cyl, head(., 2))

models <- by_cyl %>% do(mod = lm(mpg ~ disp, data = .))
summarise(models, rsq = summary(mod)$r.squared)
models %>% do(data.frame(coef = coef(.$mod)))

models %>% do(data.frame(
  var = names(coef(.$mod)),
  coef(summary(.$mod)))
  )
#+END_SRC

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  by_cyl <- mtcars %>%
      group_by(cyl)
  do(by_cyl, head(., 2)) # 意思就是 head(by_cyl,2)

  models <- by_cyl %>% do(mod = lm(mpg ~ disp, data = .))
  models %>% do(data.frame(coef = coef(.$mod)))

  iris %>%
      group_by(Species) %>%
      do({
          mod <- lm(Sepal.Length ~ Sepal.Width, data = .)
          pred <- predict(mod, newdata = .["Sepal.Width"])
          data.frame(., pred)
      })
#+END_SRC
*** n_distinct()
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  df <- tibble(
      g1 = c(1, 1, 2, 2, 2),
      g2 = c(1, 2, 1, 2, 1),
      a = sample(5),
      b = sample(5)
  )
  ###.--------------------------
  ins
  df %>% n_distinct()
#+END_SRC

*** slice()
    slice 可于选择数据的行，相对于 select 选择列数据。

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  mtcars %>% slice(1:10)#选择前 10 行
  mtcars %>% slice(-1) #删除第一行
  mtcars %>% slice(-c(1:5)) #删除前 5 行
  ###下面方法等价
  slice(mtcars, n())
  mtcars %>% tail(1)
#+END_SRC

*** between()

This is a shortcut for x >= left & x <= right, implemented efficiently in C++ for local values, and translated to the appropriate SQL for remote tables.

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  data <- data.frame(id=c(1,2,3),x=c(3,4,5))
  data %>% 
      mutate(tag=ifelse(x %>% between(1,4),1,-1))
#+END_SRC

*** case_when()
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
 case_when(mtcars$carb <= 2 ~ "low",
             mtcars$carb > 2 ~ "high") %>% table
#+END_SRC

*** if_else()
Compared to the base ifelse(), this function is more strict. It checks that true and false are the same type. This strictness makes the output type more predictable, and makes it somewhat faster.说白了，if_else() 可以保持原数据同样的数据类型。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  x <- c(-5:5, NA)
  if_else(x < 0, NA_integer_, x)
  if_else(x < 0, "negative", "positive", "missing") #和 ifelse 相比，if_else 可以自动对缺失值进行填充
  ifelse(x < 0, "negative", "positive")
                                        # Unlike ifelse, if_else preserves types
  x <- factor(sample(letters[1:5], 10, replace = TRUE))
  ifelse(x %in% c("a", "b", "c"), x, factor(NA))
  if_else(x %in% c("a", "b", "c"), x, factor(NA))
#+END_SRC

*** na_if()

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  ###na_if()将变量中的未知类型替换成 NA--------------------------------------------
  na_if(1:5, 5:1)
  x <- c(1, -1, 0, 10)
  na_if(x, 0) #把 x 中的 0 值替换成 NA
  100/x
  100 / na_if(x, 0)
  y <- c("abc", "def", "", "ghi")
  na_if(y, "") #把"“替换成 NA

  test=starwars %>%
      select(name, eye_color) %>%
      mutate(eye_color = na_if(eye_color, "unknown")) #说白了就是把 eye_color 中"unknown"的那些人标记为 NA
  test %>% summarise(sum(is.na(eye_color))) #有 3 个 NA

  starwars %>%
      mutate_if(is.character, list(~na_if(., "unknown")))#将所有 char 型变量中所有 unknown 的字段都替换为 NA
#+END_SRC

*** recode()

This is a vectorised version of switch(): you can replace numeric values based on their position or their name, and character or factor values only by their name. This is an S3 generic: dplyr provides methods for numeric, character, and factors. For logical vectors, use if_else(). For more complicated criteria, use case_when().这个函数的命令是指将符合条件的字符进行替换，不符合条件的字符不变,主要针对的是数值型、字符型、因子型变量。

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
# For character values, recode values with named arguments only. Unmatched
# values are unchanged.
char_vec <- sample(c("a", "b", "c"), 10, replace = TRUE)
dplyr::recode(char_vec, a = "Apple")
dplyr::recode(char_vec, a = "Apple", b = "Banana")
dplyr::recode(char_vec, a = "Apple", b = "Banana", .default = NA_character_)
# Use a named character vector for unquote splicing with !!!
level_key <- c(a = "apple", b = "banana", c = "carrot")
dplyr::recode(char_vec, !!!level_key)
# For numeric values, named arguments can also be used
num_vec <- c(1:4, NA)
dplyr::recode(num_vec, `2` = 20L, `4` = 40L)
# Or if you don't name the arguments, recode() matches by position.
# (Only works for numeric vector)
dplyr::recode(num_vec, "a", "b", "c", "d")
dplyr::recode(c(1,5,3), "a", "b", "c", "d", .default = "nothing")
# Note that if the replacements are not compatible with .x,
# unmatched values are replaced by NA and a warning is issued.
dplyr::recode(num_vec, `2` = "b", `4` = "d")
# use .missing to replace missing values in .x
dplyr::recode(num_vec, "a", "b", "c", .default = "other", .missing = "missing")
#> [1] "a"       "b"       "c"       "other"   "missing"
#+END_SRC

*** recode_factor()

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  # Use recode_factor() to create factors with levels ordered as they
                                        # appear in the recode call. The levels in .default and .missing
                                        # come last.
  recode_factor(num_vec, `1` = "z", `2` = "y", `3` = "x")
                                        #> Warning: Unreplaced values treated as NA as .x is not compatible. Please specify replacements exhaustively or supply .default
                                        #> [1] z    y    x    <NA> <NA>
                                        #> Levels: z y x
  recode_factor(num_vec, `1` = "z", `2` = "y", `3` = "x",
                .default = "D")
  char_vec <- sample(c("a", "b", "c"), 10, replace = TRUE)
  char_vec
  level_key <- c(a = "apple", b = "banana", c = "carrot")
  recode_factor(char_vec, !!!level_key)
#+END_SRC

*** near()

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  #Compare two numeric vectors
  sqrt(2) ^ 2 == 2
                                        #> [1] FALSE
  near(sqrt(2) ^ 2, 2,tol = .Machine$double.eps^0.5)
#+END_SRC

*** rowwise()
这个函数可以方便对每行数据进行相同的操作，说白了就是对行进行分组计算。
rowwise() is used for the results of do() when you create list-variables. It is also useful to support arbitrary complex operations that need to be applied to each row.
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  df <- expand.grid(x = 1:3, y = 3:1)
  df %>% dim()
  df_done <- df %>% rowwise() %>% do(i = seq(.$x, .$y))
  df_done$i
#+END_SRC

#+begin_src R ::results output graphics :file fig_1.png :exports both
  iris %>%
      select(Sepal.Length, Petal.Length) %>%
      rowwise() %>%
      mutate(Max.Len = max(Sepal.Length, Petal.Length)) %>%
      head()
                                        #> Source: local data frame [6 x 3]
                                        #> Groups: <by row>
                                        #> 
                                        #> # A tibble: 6 x 3
                                        #>   Sepal.Length Petal.Length Max.Len
                                        #>          <dbl>        <dbl>   <dbl>
                                        #> 1          5.1          1.4     5.1
                                        #> 2          4.9          1.4     4.9
                                        #> 3          4.7          1.3     4.7
                                        #> 4          4.6          1.5     4.6
                                        #> 5          5            1.4     5  
                                        #> 6          5.4          1.7     5.4

  iris %>%
      select(Sepal.Length, Petal.Length) %>%
      mutate(Max.Len = max(Sepal.Length, Petal.Length)) %>%
      head()
                                        #>   Sepal.Length Petal.Length Max.Len
                                        #> 1          5.1          1.4     7.9
                                        #> 2          4.9          1.4     7.9
                                        #> 3          4.7          1.3     7.9
                                        #> 4          4.6          1.5     7.9
                                        #> 5          5.0          1.4     7.9
                                        #> 6          5.4          1.7     7.9 
#+end_src
从上面的例子可以看出，没有对所有行分组的话，只是返回一个全局值，如果加入 rowwise 则会按照每行进行计算。
*** all_equal()

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
#可以比对两个顺序完全不一致的数据框，数据框的类型还可以不一致
  scramble <- function(x) x[sample(nrow(x)), sample(ncol(x))]
                                        # By default, ordering of rows and columns ignored
  all_equal(mtcars, scramble(mtcars))
  all_equal(mtcars, scramble(mtcars), ignore_col_order = FALSE)
  all_equal(mtcars, scramble(mtcars), ignore_row_order = FALSE)
                                        # By default all_equal is sensitive to variable differences
  df1 <- data.frame(x = "a")
  df2 <- data.frame(x = factor("a"))
  all_equal(df1, df2)
                                        # But you can request dplyr convert similar types
  all_equal(df1, df2, convert = TRUE)
#+END_SRC

*** rownames_to_column/column_to_rownames

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  #将行名转移到 column
  a=rownames_to_column(iris, var = "C") #新建一个列名 C，用 id 填充
  column_to_rownames(a, var = "C") #用变量 C 填充行名
#+END_SRC
*** do
You can use do() to perform arbitrary computation, returning either a data frame or arbitrary objects which will be stored in a list.

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  by_cyl <- group_by(mtcars, cyl)
  do(by_cyl, head(., 2))
  models <- by_cyl %>% do(mod = lm(mpg ~ disp, data = .))
  models
#+END_SRC
*** tbl_df()

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  set.seed(100)
  ds <- data.frame(group=c(rep("a",100), rep("b",100), rep("c",100)), 
                   x=rnorm(n = 300, mean = 3, sd = 2), y=rnorm(n = 300, mean = 2, sd = 2))
  ds %>% tbl_df()

  ds %>% group_by(group) %>% do(.$x>3)

  ds %>%
      tbl_df %>%
      group_by(group) %>%
      do(.$x>3)
#+END_SRC

*** src_dbi()
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  con <- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  copy_to(con, mtcars)
  DBI::dbListTables(con)
                                        # To retrieve a single table from a source, use `tbl()`
  con %>% tbl("mtcars")
  con %>% tbl(sql("SELECT * FROM mtcars WHERE cyl == 8"))
#+END_SRC
*** coalesce()
这个函数可以用来填补缺失值，也可以用现成的向量作互补填值。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  x <- sample(c(1:5, NA, NA, NA))
  x
  #[1] NA NA  2  3  1 NA  5  4
  coalesce(x, 0L)  #
#[1] 0 0 2 3 1 0 5 4
  y <- c(1, 2, NA, NA, 5)
  z <- c(NA, NA, 3, 4, 5)
  coalesce(y, z)

                                        # Supply lists by splicing them into dots:
  vecs <- list(
      c(1, 2, NA, NA, 5),
      c(NA, NA, 3, 4, 5)
  )
  coalesce(!!!vecs) ##对list型数据需要注意加！！！
#+END_SRC

*** combine()
combine() acts like c() or unlist() but uses consistent dplyr coercion rules.对因子型数据的 combine 特别有用。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  f1 <- factor("a")
  f2 <- factor("b")
  c(f1, f2) %>% class()
  unlist(list(f1, f2)) %>% class()
  combine(f1, f2) %>% class() # char 型
  combine(list(f1, f2)) %>% class() # char 型
#+END_SRC
*** ranking()

- row_number(): equivalent to rank(ties.method = "first")

- min_rank(): equivalent to rank(ties.method = "min")

- dense_rank(): like min_rank(), but with no gaps between ranks

- percent_rank(): a number between 0 and 1 computed by rescaling min_rank to [0, 1]

- cume_dist(): a cumulative distribution function. Proportion of all values less than or equal to the current rank.

- ntile(): a rough rank, which breaks the input vector into n buckets.

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  x <- c(5, 1, 3, 2, 2, NA)
  row_number(x)
  min_rank(x)
  dense_rank(x)
  percent_rank(x)
  cume_dist(x)
  ntile(x, 2)  
#+END_SRC

row_number 一般可以用来对数据进行排序，所以可以用来产生唯一的标识。
#+begin_src R :results output graphics :file fig_1.png :exports both 
  xiaomi_id <- c("1","2","3","1")
  credit_time <- c("20190101","20190201","20190401","20190101")
  x1 <- seq(1:4)
  df1 <- tibble(xiaomi_id,credit_time,x1)
  df1 %>% mutate(dplyr::row_number(xiaomi_id))
                                        #> # A tibble: 4 x 4
                                        #>   xiaomi_id credit_time    x1 `dplyr::row_number(xiaomi_id)`
                                        #>   <chr>     <chr>       <int>                          <int>
                                        #> 1 1         20190101        1                              1
                                        #> 2 2         20190201        2                              3
                                        #> 3 3         20190401        3                              4
                                        #> 4 1         20190101        4                              2  
#+end_src

*** order_by()
This function makes it possible to control the ordering of window functions in R that don't have a specific ordering parameter.
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  order_by(10:1, cumsum(1:10))
  x <- 10:1
  y <- 1:10
  order_by(x, cumsum(y))

  df <- data.frame(year = 2000:2005, value = (0:5) ^ 2)
  scrambled <- df[sample(nrow(df)), ]

  wrong <- mutate(scrambled, running = cumsum(value))
  arrange(wrong, year)

  right <- mutate(scrambled, running = order_by(year, cumsum(value)))
  arrange(right, year)
#+END_SRC
*** join

- inner_join
连接方式包括内连接、外连接。内连接就是 inner_join,这种连接就是等值连接,内连接最重要的性质是，没有匹配的行不会包含在结果中。这意味着内连接一般不适合在 分析中使用，因为太容易丢失观测了。。

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
 inner_join(a, b, by = "x1") #Join data. Retain only rows in both sets.
  band_members %>% inner_join(band_instruments)

#+END_SRC

- 外连接

内连接保留同时存在于两个表中的观测，外连接则保留至少存在于一个表中的观测。外连 接有 3 种类型。

- 左连接 ：保留 x 中的所有观测。
left_join()

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  band_members %>% left_join(band_instruments)
#+END_SRC

- 右连接 ：保留 y 中的所有观测 

right_join()

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
band_members %>% right_join(band_instruments)
#+END_SRC

- 全连接 ：保留 x 和 y 中的所有观测。
full_join()

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  band_members %>% full_join(band_instruments)
#+END_SRC

- 筛选连接

- semi_join(x, y) ： 保留 x 表中与 y 表中的观测相匹配的所有观测。q:和内连接有何不同？
与 inner_join 不同的是， semi_join 只会保留 x 中的特征，而不会新加 y 中的特征。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  band_members %>% semi_join(band_instruments)
#+END_SRC

- anti_join(x, y) ： *丢弃 x 表中与 y 表中的观测相匹配的所有观测，或者说只保留与 y 中不同的观测。*

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  band_members %>% anti_join(band_instrument)
#+END_SRC

- nest_join()

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  band_members %>% nest_join(band_instruments)
#+END_SRC

*** lead-lag
产生一个滞后向量和向前的向量。

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  lead(1:10, 1)
  lead(1:10, 2)
#+END_SRC
这个函数的 order_by 参数还是挺有用的。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  df <- data.frame(year = 2000:2005, value = (0:5) ^ 2)
  scrambled <- df[sample(nrow(df)), ]
  scrambled %>% mutate(prev = lag(value, order_by = year)) #可以配合order_by 使用
#+END_SRC

*** set manipulation

intersect(x, y) 返回既在 x 表，又在 y 表中的观测。
union(x, y) 返回 x 表或 y 表中的唯一观测,其实就是并集的概念。还有一个是 *union_all(),类似于 bind_rows()*,dplyr 的 union_all 会对不存在的字段补空值，所以除非碰到相同字段左右类型不一样且无法隐式转换，否则 union_all 任何情况下都不会报错。.
setdiff(x, y) 返回在 x 表，但不在 y 表中的观测。
setequal(x,y):可以比较两个向量是否一致，顺序不一致也可以。
intersect(y, z) 
Rows that appear in both y and z.

union(y, z) 
Rows that appear in either or both y an

setdiff(y, z) 
Rows that appear in y but not z. 保留在 y 中的，但不在 z 中的。

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  y <- tibble(x1 = c("A", "B", "C"), x2 = c(1, 2, 3))
  z <- tibble(x1 = c("B", "C", "D"), x2 = c(2, 3, 4))
  union(y, z) 
union_all(y,z)
intersect(y,z)
setdiff(y,z) #保留下y中独有的值,去除重复的去除重复的
  a <- rep(1:3, 1:3)
  b <- 1:3
  setequal(a, b)  # TRUE
  identical(a, b)  # FALSE
  setequal(mtcars, mtcars[32:1, ])
#+END_SRC

** 7.2 dbplyr
*** sql_render
这个命令可以将 dplyr 包命令转换为 sql 语句。
#+begin_src R :results output graphics :file fig_1.png :exports both 
  con <- DBI::dbConnect(RSQLite::SQLite(), path = ":dbname:")
  copy_to(con, nycflights13::flights, "flights",
          temporary = FALSE, 
          indexes = list(
              c("year", "month", "day"), 
              "carrier", 
              "tailnum",
              "dest"
          )
          )
  flights_db <- tbl(con, "flights")
  flights_db %>% select(year:day, dep_delay, arr_delay) %>% 
      show_query()
                                        #> <SQL>
                                        #> SELECT `year`, `month`, `day`, `dep_delay`, `arr_delay`
                                        #> FROM `flights`  
#+end_src

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  library(DBI)
  library(dbplyr)
  test <- mtcars %>%
      summarise_all(mean) %>%
      show_query() # 注意在 spark 环境下可以用 show_query()显示 sql 语句
  mtcars %>% summarise(mean) # return na
  sql_render(test) #可以比较 dplyr 语法与它产生的 SQL：
#+END_SRC

*** translate_sql()
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  translate_sql(x == 1 && (y < 2 || z > 3))
#+END_SRC
** 7.3 purrr
这个函数主要应用于 list 型。
*** accumulate
accumulate 其实是 reduce 的一种改良版本。可以把 reduce 所得结果的整个过程输出。
accumulate() sequentially applies a 2-argument function to elements of a vector. 
类似于 cum 等累计函数，还可以选择方向进行计算。accumulate2():For accumulate2() .y is the second argument of the pair. It needs to be 1 element shorter than the vector to be accumulated (.x). If .init is set, .y needs to be one element shorted than the concatenation of the initial value and .x.

accumulate(.x, .f, ..., .init, .dir = c("forward", "backward"))
accumulate2(.x, .y, .f, ..., .init)

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
1:5 %>% accumulate(`+`)
1:5 %>% accumulate(`+`, .dir = "backward")
#+END_SRC

accumulate 不光能够处理数字，还能处理字符。
请注意下面函数的 argument.
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  accumulate(letters[1:5], paste, sep = ".")
  accumulate(letters[1:5], paste, sep = ".", .dir = "backward")
  letters[1:4] %>% accumulate2(c("-", ".", "-"), paste2)
#+END_SRC
*** working with list
**** array_branch
Coerce array to list,这个函数可以将 array 型数据转化为 list 型。
array_branch() and array_tree() enable arrays to be used with purrr's
functionals by turning them into lists.

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
#ggplot::results output graphics,plot::results graphics 
x <- array(1:2)
x
array_branch(x) %>% str()
## [[1]]
## [1] 1
## [[2]]
## [1] 2
#+END_SRC
**** array_tree
array_tree() creates an hierarchical list (a tree) that has as many levels as dimensions specified in margin.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       x <- array(1:12, c(2, 2, 3))
       x
       array_tree(x) %>% str()
     #+end_src

**** cross
Produce all combinations of list elements
#+begin_src R :results output graphics :file fig_1.png :exports both 
  data <- list(
      id = c("John", "Jane"),
      greeting = c("Hello.", "Bonjour."),
      sep = c("! ", "... ")
  )
  data %>%
      cross() %>%
      map(lift(paste))
#+end_src
**** cross_df
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      list(stores = 1:2, weeks = 1:3) %>% cross_df()
      # A tibble: 6 x 2
      ## stores weeks
      ## <int> <int>
      ## 1      1     1
      ## 2      2     1
      ## 3      1     2
      ## 4      2     2
      ## 5      1     3
      ## 6      2     3
    #+end_src
**** set_names
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      set_names(1:4, c("a", "b", "c", "d"))
    #+end_src

*** assign_in

assign_in() takes a data structure and a pluck location, assigns a value there, and returns the modified data structure。对于固定位置变量取值进行替换。

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  x <- list(list(bar = 1, foo = c(1,2)))
  x
  x %>%
      assign_in(list(1,"foo"),100)
#+END_SRC

*** modify_in
该函数功能和 assign_in 类似，但是允许取值和变量存在函数映射关系。 
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
#ggplot::results output graphics,plot::results graphics 
  x <- list(list(bar = 1, foo = 2))
  x %>% 
  modify_in(list(1, "foo"), ~ .x * 200)
  modify_in(x, list(1,"foo"),`+`,100)
#+END_SRC
*** pluck
从这个函数名字可以知道，叫摘下。
select an element by name or index,pluck(x,"b").这个函数类似于 select。pluck 还是挺方便的，对于不存在的元素还可以赋值 na。
还有一个函数为 chuck,跟 pluck 相比，它能返回错误信息，所以使用起来更为方便。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  # list of data structures:
  obj1 <- list("a", list(1, elt = "foobar"))
  obj2 <- list("b", list(2, elt = "foobaz"))
  x <- list(obj1, obj2)
  my_element <- function(x) x[[2]]$elt
  pluck(x, 1, my_element)
  pluck(x, 2, my_element)
  pluck(x, 2)
  x[[1]][[2]]$elt
  ###pluck 好用！
  test <- list(x=c(1,2),y=c(2,3))
  pluck(test,1)
  pluck(test,"x")[2]
                                        #还可以取多维数据
  ?pluck
  pluck(x, 10, .default = NA) ## By default, pluck() consistently returns `NULL` when an element
                                        # does not exist:
  my_element <- function(x) x[[2]]$elt
  idx <- list(1, my_element)
  pluck(x, !!!idx)
#+END_SRC

*** map
The map() functions use pluck() by default to retrieve multiple values from a list:
map 也可以和 pluck 一样，摘取 list 中的元素。但是和 pluck 不同的是，map 
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  1:10 %>%
      map(function(x) rnorm(2, x))
  
  obj1 <- list("a", list(1, elt = "foo"))
  obj2 <- list("b", list(2, elt = "bar"))
  x <- list(obj1, obj2)
  x
  map(x, 2)
  map(x, list(2, "elt"))
                                        # You can also supply a default:
  map(x, list(2, "elt", 10), .default = "superb default")

#+END_SRC

*** exec
Usage
exec(.fn, ..., .env = caller_env())
Arguments
.fn	
A function, or function name as a string.

...	
Arguments to function.

These dots support tidy-dots features.

.env	
Environment in which to evaluate the call. This will be most useful if f is a
string, or the function has side-effects.

注意 exec 的 function 是 string 型。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      args <- list(x = c(1:10, 100, NA), na.rm = TRUE)
      exec("mean", !!!args)
      exec("mean", !!!args, trim = 0.2)      
                                        # exec() is not designed to generate pretty function calls. This is
                                        # most easily seen if you call a function that captures the call:
      f <- disp ~ cyl
      exec("lm", f, data = mtcars)

    
#+end_src
*** every
Do every or some elements of a list satisfy a predicate?
#+begin_src R :results output graphics :file fig_1.png :exports both 
  y <- list(0:10, 5.5)
  y %>% every(is.numeric)
  ## [1] TRUE
  y %>% every(is.integer)
  ## [1] FALSE
#+end_src
*** some
类似于 is.character

    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- list(1:5,letters,list(10))
      x %>%
          some(is_character)
    #+end_src
*** keep
keep 的作用和 filter 类似。
keep() 和 discard() 函数可以分别保留输入中预测值为 TRUE 和 false 的元素。
keep() is similar to Filter(), but the argument order is more convenient. 
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  ?keep
  rep(10, 10) %>%
      map(sample, 5) %>% #map like apply
      keep(function(x) mean(x) > 6)

  x <- rerun(5, a = rbernoulli(1), b = sample(10))
  x
  x %>% keep("a") #filter(a==TRUE)
  x %>% discard("a") #filter(a==Flase)
#+END_SRC
*** reshape lists
**** flatten
这个函数可以方便处理 list 型数据，可以将 list 型数据转换为一个简单的向量。
These functions remove a level hierarchy from a list. They are similar to unlist(), but they only ever remove a single layer of hierarchy and they are type-stable, so you always know what the type of the output is.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- rerun(2,sample(4))
      x
      x %>% flatten()
      x %>% flatten_int()
      x %>% map(1L) %>% flatten_int()
      x %>% map_int(1L)      
    #+end_src
**** flatten_chr/flatten_dfr/flatten_int/flatten_lgl
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       x <- rerun(2, sample(4))
       x
       x %>% flatten()
       x %>% flatten_int()
       ## [1] 1 3 2 4 4 3 1 2
       x %>% flatten_chr()
       ## [1] "1" "3" "2" "4" "4" "3" "1" "2"
       x %>% flatten_dfc()
                                        # A tibble: 1 x 8
       ## V1    V2    V3    V4    V5    V6    V7    V8
       ## <int> <int> <int> <int> <int> <int> <int> <int>
                                                      ## 1     1     3     2     4     4     3     1     2
       x %>% flatten_lgl()       
     #+end_src
**** transpose
Transpose turns a list-of-lists "inside-out"; it turns a pair of lists into a
list of pairs, or a list of pairs into pair of lists. 
对于 list 型数据进行转置。 
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       list(x = 1:2, y = 3:4)
       ## $x
       ## [1] 1 2
       ## $y
       ## [1] 3 4
       x <- transpose(list(x = 1:2, y = 3:4))
       x
       ## [[1]]
       ## [1] 1 3
       ## [[2]]
       ## [1] 2 4
     #+end_src
*** append
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- as.list(1:3)

      x %>% append("a")
                                        #> [[1]]
         #> [1] 1
#> 
                                        #> [[2]]
                                        #> [1] 2
                                        #> 
                                        #> [[3]]
                                        #> [1] 3
                                        #> 
                                        #> [[4]]
                                        #> [1] "a"      
    #+end_src

*** prepend

    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- as.list(1:3)
      x %>% prepend("a")
      
                                        #> [[1]]
                                        #> [1] "a"
                                        #> 
                                        #> [[2]]
                                        #> [1] 1
                                        #> 
                                        #> [[3]]
                                        #> [1] 2
                                        #> 
                                        #> [[4]]
                                        #> [1] 3      
    #+end_src

*** has_element
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- list(1:10, 5, 9.9)
      x %>% has_element(1:10)
      ## [1] TRUE
    #+end_src
*** compact
compact 可以忽视 NULL 值。compact
#+begin_src R :results output graphics :file fig_1.png :exports both 
  x=list(a = "a", b = NULL, c = integer(0), d = NA, e = list()) %>%
      compact()
  x

  x=c(1,NA)
  x=matrix(c(1,2,NA,3),2,2)
  x>3
  class(x)
  x==NA
  x[!is.na(x)]
#+end_src
 
*** split
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      mtcars %>%
          split(.$cyl) %>%
          map(~lm(mpg~wt,data=.)) %>%
          map(summary) %>%
          map_dbl("r.squared") #return double vectors
    #+end_src

*** modify function behavior 
**** compose 
Compose multiple functions.

之间一直不理解这个函数（还是要多看 stackoverflow）哈～
说白了就是一个嵌套函数模型。

sin(cos(x)) #就等价于 compose(sin,cos)

#+begin_src R ::results output graphics :file fig_1.png :exports both
  f1 <- list(sin, cos, cos, sqrt)
  x <- seq(0, 1, length.out = 10) %>% round(3)
  x %>% head()
                                        #> [1] 0.000 0.111 0.222 0.333 0.444 0.556
  lift(compose)(f1)(x) %>% round(3)
                                        #>  [1] 0.514 0.553 0.588 0.620 0.649 0.676 0.699 0.721 0.740 0.756  
#+end_src

#+begin_src R :results output graphics :file fig_1.png :exports both 
  not_null <- compose(`!`, is.null)
  #等价于 !is.null(null)
  not_null(NULL) #!is.null
  ## [1] FALSE
  not_null(4)
  ## [1] TRUE
#+end_src
**** lift
change the type of input a function takes.这个函数可以将各种函数适配数据类型（完
美～）。
lift_ld(fun) transforms a function taking a list to a function taking dots.
我理解这个函数可以将 list 型数据导入到 function 中。

这个函数可以满足函数适配 vector 型和 list 型数据。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
#可以处理一个list 型的argument
x <- list(x = c(1:100,NA,1000),na.rm = T,trim = 0.9)
lift_dl(mean)(x)
                                        #等价于
mean %>%
    lift_dl() %>%
    invoke(x)

fun2 <- fun %>%
    lift_ld()
fun2(2,NA,4,na.rm = T)

    #+end_src
**** lift_vl

     #+begin_src R :results output graphics :file fig_1.png :exports both 
       x=list(1,3)
       lift_vl(mean)(x)
       ## [1] 2
     #+end_src
**** rerun
This is a convenient way of generating sample data. It works similarly to replicate(..., simplify = FALSE).
Usage
rerun(.n, ...)
Arguments
.n	
Number of times to run expressions
...	
Expressions to re-run.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       2 %>% rerun(rnorm(5))
       ## [[1]]
       ## [1] -0.1916 -1.5257  0.7233  0.2105  1.6455
       ## [[2]]
       ## [1]  0.37978 -0.48375  0.03287  0.67469  1.19097
     #+end_src
**** negate
Negate a predicate function.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       x <- rerun(3,a = rbernoulli(1), b = sample(10))
       x
       x %>% purrr::keep("a") %>% length()
       x %>% keep(negate("a")) %>% length()
                                        # Same as
       x %>% discard("y") %>% length()
     #+end_src
**** safely
safely 函数可以对显示函数输出结果进行判断。
safely() 函数一般输出两个变量 $result 和 $error.所以能够用来检查函数错误。

  #+begin_src R :results output graphics :file fig_1.png :exports both 
    safe_log <- safely(log)
    safe_log(10)
    safe_log("a")
    ## $result
    ## NULL
    ## $error
    ## <simpleError in .Primitive("log")(x, base): non-numeric argument to mathematical function>
 #+end_src

**** partial
Partial apply a function, filling in some arguments.Partial function application allows you to modify a function by pre-filling some of the arguments. It is particularly useful in conjunction with functionals and other function operators.

    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- 3
      func <- purrr::partial(rnorm, n = x, ... = , sd = 1)
      func(5)      
    #+end_src

**** quietly
Modify function to return list of results, output, messages, warnings.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       quietly_log <- quietly(log)
       quietly_log(10)
       quietly_log("a")       
     #+end_src
**** possibly
possibly() Modify function to return default value whenever an error occurs (instead of error).
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       quietly_log <- possibly(log)
       quietly_log(10)
       quietly_log("a")       
     #+end_src
*** invoke

invoke 正如其名，调用函数，作用和 do.call 类似，所不同的是 do.call 的输入必须是
list 型，而 invoke 没有这种限制。call lists of functions with lists of parameters.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
     invoke(mean,list(na.rm = T),x = 1:10) 
    #+end_src
需要注意的是 invoke 第一个参数不能设为 list 型，而 invoke_map 可疑。

*** invoke_map
相比于 map,pmap,还有一种更复杂的情况，不但传给函数的参数不同，甚至函数本身也是不
同的，就需要用 invoke_map。这个函数目前已经被 exec 函数所取代。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      list(mean,median) %>%
          invoke_map(list(n = 10))
      f <- c("runif", "rnorm", "rpois") 
      param <- list( list(min = -1, max = 1), list(sd = 5), list(lambda = 10) )
      invoke_map(f, param, n = 5)
    #+end_src

*** map

|                     | list   | atomic         | same type | nothing |
| one argument        | map()  | map_lgl(),...  | modify()  | walk()  |
| two arnuments       | map2() | map2_lgl(),... | modify2() | walk2() |
| one arguments+index | imap() | imap_lgl(),... | imodify() | iwalk() |
| N arguments         | pmap() | pmap_lgl(),... | -         | pwalk()  |

先来个甜点。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      mtcars %>% 
          split(.$cyl) %>% 
          map(~ lm(mpg~wt,data = .x)) %>% 
          map(coef) %>% 
          map_dbl(2)      
    #+end_src

apply a function to each element of a vector.

  这个函数对应于 base 包中的 apply,是一个 Map family，衍生的函数包括 map_lgl(),map_int(),map_dbl(),map_chr()等，作用于不同的数据类型。map_dfr()和 map_dfc()返回的是 data.frame.

  The map(.x, .f) functions transforms each element of the vector .x with the function .f, returning a vector defined by the suffix (_lgl, _chr() etc).
  从这个例子可以看出，～符号对应着 function. 
  #+begin_src R :results output graphics :file fig_1.png :exports both 
    triple <- function(x) x*3
    map(1:3,triple)
    
   1:10 %>%
    map(rnorm,n=10) %>%
    map_dbl(mean)
  # or use an anonymous function
  1:10 %>%
    map(function(x) rnorm(10,x))
                                          # or a formula
  1:10 %>%
    map(~ rnorm(10,.x))
                                          # Extract by name or position
                                          # .default specifies value for elements that are missing or NULL
  l1 <- list(list(a = 1L), list(a = NULL, b = 2L), list(b = 3L))
  l1
  set_names(c("foo", "bar")) %>% map_chr(paste0, ":suffix")

                                          # Extract by name or position
                                          # .default specifies value for elements that are missing or NULL
  l1 <- list(list(a = 1L), list(a = NULL, b = 2L), list(b = 3L))
  l1
  l1 %>% map("a", .default = "???") ##将缺失值或者 NULL 填充为???
  l1 %>% map_int("b",.default=NA)
                                          # Supply multiple values to index deeply into a list
  l2 <- list(
    list(num = 1:3,     letters[1:3]),
    list(num = 101:103, letters[4:6]),
    list()
  )
  l2 %>% head
  l2 %>% map(c(2, 2)) ##可以选择 c(2,2)元素
                                          # Use a list to build an extractor that mixes numeric indices and names,
                                          # and .default to provide a default value if the element does not exist
  l2 %>% map(list("num", 3)) ##可以选择确定元素

  l2 %>% map_dbl(list("num", 3), .default = NA)
  #+end_src

map 函数还可以充当 pluck 函数功能。

#+begin_src R :results output graphics :file fig_1.png :exports both 
  x <- list(
      list(-1, x = 1, y = c(2), z = "a"),
      list(-2, x = 4, y = c(5, 6), z = "b"),
      list(-3, x = 8, y = c(9, 10, 11))
  )

                                        # Select by name
  map_dbl(x, "x")
                                        #> [1] 1 4 8

                                        # Or by position
  map_dbl(x, 1)
                                        #> [1] -1 -2 -3

                                        # Or by both
  map_dbl(x, list("y", 1))
                                        #> [1] 2 5 9

                                        # You'll get an error if a component doesn't exist:
  map_chr(x, "z")
                                        #> Error: Result 3 must be a single string, not NULL of length 0

                                        # Unless you supply a .default value
  map_chr(x, "z", .default = NA)
                                        #> [1] "a" "b" NA fs  
#+end_src


**** map_lgl
map_lgl() always returns a logical vector
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       map_lgl(mtcars, is.double)      
     #+end_src

**** map_chr
map_chr() always returns a character vector
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       mtcars %>% 
           map_chr(typeof)       
     #+end_src

**** map_int 
map_int() always returns a integer vector
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       n_unique <- function(x) length(unique(x))
       mtcars %>% 
           map_int(n_unique)       
     #+end_src

**** map_dbl
map_dbl() always returns a double vector.
需要注意的是，map_dbl 只能接受一个输入。

     #+begin_src R :results output graphics :file fig_1.png :exports both 
       mtcars %>% 
           map_dbl(mean)

       pair <- function(x) c(x, x)
       map_dbl(1:2, pair)
                                        #> Error: Result 1 must be a single double, not an integer vector of length 2
       map(1:2, pair)
                                        #> [[1]]
                                        #> [1] 1 1
                                        #> 
                                        #> [[2]]
                                        #> [1] 2 2
     #+end_src

**** map_at
可以针对特定的变量进行函数操作。
     #+begin_src R ::results output graphics :file fig_1.png :exports both
survey08 <- data.frame(year = c(2008, 2008, 2007, 2006, 2008), employed = c(1, 2, 2, 1, 2))
survey09 <- data.frame(year = 2009, employed = c(1, 1, 1, 2, 1))
survey10 <- data.frame(year = 2010, employed = c(2, 1, 1, 1, 1))
# put dataframes into a list
df_list <- list(survey08, survey09, survey10)
names(df_list) <- c("survey08", "survey09", "survey10")
df_list %>%
  map(~ filter(.x, year %in% 2008:2009))
#> $survey08
#>   year employed
#> 1 2008        1
#> 2 2008        2
#> 3 2008        2
#> 
#> $survey09
#>   year employed
#> 1 2009        1
#> 2 2009        1
#> 3 2009        1
#> 4 2009        2
#> 5 2009        1
#> 
#> $survey10
#> [1] year     employed
#> <0 行> (或0-长度的row.names)

df_list %>%
  map_at(
    c("survey08", "survey09"),
    ~ filter(.x, year %in% 2008:2009)
  )
#> $survey08
#>   year employed
#> 1 2008        1
#> 2 2008        2
#> 3 2008        2
#> 
#> $survey09
#>   year employed
#> 1 2009        1
#> 2 2009        1
#> 3 2009        1
#> 4 2009        2
#> 5 2009        1
#> 
#> $survey10
#>   year employed
#> 1 2010        2
#> 2 2010        1
#> 3 2010        1
#> 4 2010        1
#> 5 2010        1       
     #+end_src

*** map_if

    #+begin_src R ::results output graphics :file fig_1.png :exports both
      df <- data.frame(
          stringsAsFactors = FALSE,
          id = c(1, 2, 3),
          age = c(18, 21, 16),
          name = c("jim", "bob", "alice"),
          income = c(100, 200, 300)
      )
      df <- map_df(df, as.character)
      df %>%
          map_at(c("id"), as.numeric) %>%
          glimpse()
                                        #> Error in glimpse(.): 没有"glimpse"这个函数

      df %>%
          map_if(names(.) %in% c("id"), as.numeric)
                                        #> $id
                                        #> [1] 1 2 3
                                        #> 
                                        #> $age
                                        #> [1] "18" "21" "16"
                                        #> 
                                        #> $name
                                        #> [1] "jim"   "bob"   "alice"
                                        #> 
                                        #> $income
                                        #> [1] "100" "200" "300"      
    #+end_src

*** as_mapper 
You can see what’s happening behind the scenes by calling as_mapper(). 可以通过
as_mapper 函数查看当前 function 形式。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
as_mapper(~length(unique(.x)))      
    #+end_src
*** map2

  Map over multiple inputs simultaneously.We need a new tool: a map2(), which is vectorised over two arguments. This means both .x and .y are varied in each call to .f.

  #+begin_src R :results output graphics :file fig_1.png :exports both 
    x <- list(1, 10, 100)
    y <- list(1, 2, 3)
    z <- list(5, 50, 500)
    map2(x, y, ~ .x + .y) #list 元素之间的相加
                                        #or
    map2(x,y,`+`) #这里的加号需要注意
    ##model,predict
                                        # Split into pieces, fit model to each piece, then predict
    by_cyl <- mtcars %>% split(.$cyl)
    mods <- by_cyl %>% map(~ lm(mpg ~ wt, data = .))
    map2(mods, by_cyl, predict)

    x <- c(foo = 1L, bar = 2L)
    y <- c(TRUE, FALSE)
    modify2(x, y, ~ if (.y) .x else 0L) %>% str()
                                        #>  Named int [1:2] 1 0
                                        #>  - attr(*, "names")= chr [1:2] "foo" "bar"
    map2(x, y, ~ if (.y) .x else 0) %>% str()
                                        #> List of 2
                                        #>  $ foo: int 1
                                        #>  $ bar: num 0
  #+end_src

在 base 包中，有类似的函数就是 Map.

#+begin_src R :results output graphics :file fig_1.png :exports both 
  x <- list(1, 10, 100)
  y <- list(1, 2, 3)
  Map(`+`,x,y) #这里的加号需要注意
#+end_src

而且 Map 函数相当于 map2 以及 mapply.
#+begin_src R :results output graphics :file fig_1.png :exports both 
  mapply(rep, 1:4, 4:1)
  mapply(rep, times = 1:4, MoreArgs = list(x = 42))
  map2(1:4,4:1,rep)
  map2(times = 1:4, MoreArgs = list(x = 42),rep)
  Map(rep,times = 1:4, MoreArgs = list(x = 42))

  mapply(function(x, y) seq_len(x) + y,
         c(a =  1, b = 2, c = 3),  # names from first
         c(A = 10, B = 0, C = -10))
  Map(function(x, y) seq_len(x) + y,
      c(a =  1, b = 2, c = 3),  # names from first
      c(A = 10, B = 0, C = -10))

  map2(c(a =  1, b = 2, c = 3),  # names from first
       c(A = 10, B = 0, C = -10),function(x, y) seq_len(x) + y)   
#+end_src
*** pmap

map 是对一列数据进行分析,map2 是对两列数据进行分析，那么 pmap 是对三列数据进行分
析。
  
#+begin_src R :results output graphics :file fig_1.png :exports both 
x <- list(1, 10, 100)
  y 1, 2, 3)
  z <- list(5, 50, 500)
  pmap(list(x, y, z), sum) #多个元素相加，需要 pmap 操作
  # Matching arguments by position
  pmap(list(x, y, z), function(a, b, c) a / (b + c))
                                          # Matching arguments by name
  l <- list(a = x, b = y, c = z)
  pmap(l, function(c, b, a) a / (b + c))
                                          # Vectorizing a function over multiple arguments
  df <- data.frame(
    x = c("apple", "banana", "cherry"),
    pattern = c("p", "n", "h"),
    replacement = c("x", "f", "q"),
    stringsAsFactors = FALSE
  )
  pmap(df, gsub)
  pmap_chr(df, gsub)

                                          # Use `...` to absorb unused components of input list .l
  df <- data.frame(
    x = 1:3 + 0.1,
    y = 3:1 - 0.1,
    z = letters[1:3]
  )
  plus <- function(x, y) x + y
  if (FALSE) {                                        # this won't work
    pmap(df, plus)
  }
                                          # but this will
  plus2 <- function(x, y, ...) x + y
  pmap_dbl(df, plus2)
  df
  # If you want to bind the results of your function rowwise, use map2_dfr() or pmap_dfr()
  ex_fun <- function(arg1, arg2){
    col <- arg1 + arg2
    x <- as.data.frame(col)
  }
  arg1 <- seq(1, 10, by = 3)
  arg2 <- seq(2, 11, by = 3)
  arg1+arg2
  df <- map2_dfr(arg1, arg2, ex_fun)
  df
                                          # If instead you want to bind by columns, use map2_dfc() or pmap_dfc()
  df2 <- map2_dfc(arg1, arg2, ex_fun)
  df2
  #+end_src
*** pwalk
如果调用函数的目的是利用其副作用，而不是返回值时，那么就应该使用游走函数，而不是映射函数。通常来说，使用这个函数的目的是在屏幕上提供输出或者将文件保存到磁盘——重要的是操作过程，而不是返回值。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      library(dplyr)
      library(purrr)
      library(tibble)
      library(datasets)
      set.seed(57)
      ds_mt <- 
          mtcars %>% 
          rownames_to_column("model") %>% 
          mutate(
              am = factor(am, labels = c("auto", "manual")), 
              vs = factor(vs, labels = c("V", "S"))
          ) %>% 
          select(model, mpg, wt, cyl, am, vs) %>% 
          sample_n(3)

      foo <- function(model, am, mpg){
          print(
              paste("The", model, "has a", am, "transmission and gets", mpg, "mpgs.")
          )
      }

      ds_mt %>% 
          select(model, am, mpg) %>% 
          pwalk(
              .l = .,
              .f = foo
          )      
    #+end_src

*** list_modify
可以对已有的 list 型数据进行修改，list_merge 可以。
list_modify() and list_merge() recursively combine two lists, matching elements either by name or position. If a sub-element is present in both lists list_modify() takes the value from y, and list_merge() concatenates the values together.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- list(x = 1:10, y = 4, z = list(a = 1, b = 2))
      list_modify(x,z = 5)
      x <- list(x = 1:10, y = 4, z = list(a = 1, b = 2))
      str(x)

                                        # Update values
      str(list_modify(x, a = 1))
                                        # Replace values
      str(list_modify(x, z = 5))
      str(list_modify(x, z = list(a = 1:5)))

                                        # Remove values
      str(list_modify(x, z = zap()))

                                        # Combine values
      str(list_merge(x, x = 11, z = list(a = 2:5, c = 3)))


                                        # All these functions support tidy dots features. Use !!! to splice
                                        # a list of arguments:
      l <- list(new = 1, y = zap(), z = 5)
      str(list_modify(x, !!!l))
    #+end_src
*** imap_ 
imap_xxx(x, ...), an indexed map, is short hand for map2(x, names(x), ...) if x has names, or map2(x, seq_along(x), ...) if it does not. This is useful if you need to compute on both the value and the position of an element.
这个函数是简化版本的 map2,等价于 map2(x,names(x),...) 或者是 seq_along(x).

    #+begin_src R :results output graphics :file fig_1.png :exports both 
      z=sample(10)
      z
      imap_chr(z, ~ paste0(.y, ": ", .x))
      iwalk(mtcars, ~ cat(.y, ": ", median(.x), "\n", sep = ""))
    #+end_src
*** lmap
lmap(), lmap_at() and lmap_if() are similar to map(), map_at() and map_if(), with the difference that they operate exclusively on functions that take and return a list (or data frame).
  #+begin_src R :results output graphics :file fig_1.png :exports both 
   # Let's write a function that returns a larger list or an empty list
   # depending on some condition. This function also uses the names
   # metadata available in the attributes of the list-element
      maybe_rep <- function(x) {
          n <- rpois(1, 2)
          out <- rep_len(x, n)
          if (length(out) > 0) {
              names(out) <- paste0(names(x), seq_len(n))
          }
          out
      }
      # The output size varies each time we map f()
      x <- list(a = 1:4, b = letters[5:7], c = 8:9, d = letters[10])
      x %>% lmap(maybe_rep)
      # We can apply f() on a selected subset of x
      x %>% lmap_at(c("a", "d"), maybe_rep)
      # Or only where a condition is satisfied
      x %>% lmap_if(is.character, maybe_rep)
   #+end_src
*** modify
Same type of output as input: modify().modify 函数好处是输出和输入类型一样的类型。Unlike map() and its variants which always return a fixed object type (list for map(), integer vector for map_int(), etc), the modify() family always returns the same type as the input object.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
   # Convert factors to characters
  iris %>%
    modify_if(is.factor, as.character) %>%
    str()

                                          # Specify which columns to map with a numeric vector of positions:
  mtcars %>% modify_at(c(1, 4, 5), as.character) %>% str()

  list(x = rbernoulli(100), y = 1:100) %>%
    transpose() %>%
    modify_if("x", ~ update_list(., y = ~ y * 100)) %>%
    transpose() %>%
    simplify_all()

                                          # Use modify2() to map over two vectors and preserve the type of
                                          # the first one:
  x <- c(foo = 1L, bar = 2L)
  y <- c(TRUE, FALSE)
  modify2(x, y, ~ if (.y) .x else 0L)
                                          # Modify at specified depth ---------------------------
  l1 <- list(
    obj1 = list(
      prop1 = list(param1 = 1:2, param2 = 3:4),
      prop2 = list(param1 = 5:6, param2 = 7:8)
    ),
    obj2 = list(
      prop1 = list(param1 = 9:10, param2 = 11:12),
      prop2 = list(param1 = 12:14, param2 = 15:17)
    )
  )
                                          # In the above list, "obj" is level 1, "prop" is level 2 and "param"
                                          # is level 3. To apply sum() on all params, we map it at depth 3:
  l1 %>% modify_depth(3, sum)
  l1 %>% modify_depth(3, `+`, 100L)
                                          # modify() lets us pluck the elements prop1/param2 in obj1 and obj2:
  l1 %>% modify(c("prop1", "param2")) %>% str()
  l1 %>% modify_depth(2, ~ pmap(., paste, sep = " / ")) %>% str()
    #+end_src

    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- c(foo = 1L, bar = 2L)
      y <- c(TRUE, FALSE)
      modify2(x, y, ~ if (.y) .x else 0L)      
    #+end_src
*** vec_depth
Compute the depth of a vector.The depth of a vector is basically how many levels that you can index into it.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- list(
          list(),
          list(list()),
          list(list(list(1)))
      )
      vec_depth(x)
      ## [1] 5
      x %>% map_int(vec_depth)      
      ## [1] 1 2 4
    #+end_src
*** reduce
Reduce a list to a single value by iteratively applying a binary function.
mapreduce?

Arguments
.x	
A list or atomic vector.

.f	
For reduce(), and accumulate(), a 2-argument function. The function will be passed the accumulated value as the first argument and the "next" value as the second argument.

For reduce2() and accumulate2(), a 3-argument function. The function will be passed the accumulated value as the first argument, the next value of .x as the second argument, and the next value of .y as the third argument.

The reduction terminates early if .f returns a value wrapped in a done().

...	
Additional arguments passed on to the mapped function.

.init	
If supplied, will be used as the first value to start the accumulation, rather than using .x[[1]]. This is useful if you want to ensure that reduce returns a correct value when .x is empty. If missing, and .x is empty, will throw an error.

.dir	
The direction of reduction as a string, one of "forward" (the default) or "backward". See the section about direction below.

.y	
For reduce2() and accumulate2(), an additional argument that is passed to .f. If init is not set, .y should be 1 element shorter than .x.

  #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
    x <- list(c(0,1))
    x %>% reduce(c)
    x %>% reduce_right(c)
    x %>% reduce("+") 
  lst <- list(0)
    for(i in (1:5))
    {
     lst[i] = list(matrix(rep(i,8),nrow = 2))
    }
  Reduce("+",lst) #将list 中的元素进行相加

  a <- c(12,23,3,8)
    Reduce("+",a)
                                          #等价于“"+"("+"("+"(12,25),3),8)”
    Reduce("-",a)
                                          #同样等价于下面算式"-"("-"("-"(12,25),3),8)

    Reduce("+",a,accumulate=T) ##可以知道累计的结果

  ??mapreduce
  #+END_SRC
*** detect
detect() 函数可以找出预测值为真的第一个元素， detect_index() 函数则可以返回这个元素的位置：
  #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
    x <- sample(10)
    x
    x %>% detect(~ . >5)
    x %>%
        detect_index(~ . >5)
    
    detect(x, "foo")
  #+END_SRC 
*** detect_index
detect_index() 函数则可以返回这个元素的位置：
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- sample(10)
      x
      x %>%
          detect_index(~ . >5)
    #+end_src
*** head_while/tail_while
作用和 detect 类似，head_while 和 tail_while 分别从向量开头和结尾找出预测值为真的
元素。

Find head/tail that all satisfies a predicate.

Usage
head_while(.x, .p, ...)

tail_while(.x, .p, ...)
Arguments
.x	
A list or atomic vector.

.p	
A single predicate function, a formula describing such a predicate function, or a logical vector of the same length as .x. Alternatively, if the elements of .x are themselves lists of objects, a string indicating the name of a logical element in the inner lists. Only those elements where .p evaluates to TRUE will be modified.

...	
Additional arguments passed on to the mapped function.

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  pos <- function(x) x>=0
  head_while(5:-5,pos)
  big <- function(x) x > 100
  head_while(0:10, big)
  tail_while(0:10, big)
#+END_SRC

*** rep_along
These functions take the idea of seq_along() and apply it to repeating values.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      rep_along(x, 1:2)
      rep_along(x, 1)

      rep_along(x, na_int)
      rep_along(x, na_chr)
                                        # rep_named() repeats a value along a names vectors
      rep_named(c("foo", "bar"), list(letters))  
    #+end_src
*** %||%
This infix function makes it easy to replace NULLs with a default value. It's inspired by the way that Ruby's or operation (||) works.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      1 %||% 2
      NULL %||% 2
    #+end_src
*** as_mapper
这个函数其实是一种函数代码，具体含义见下面样例。
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  as_mapper(c("a", "b", "c"))
                                        # Equivalent to function(x) x[["a"]][["b"]][["c"]]
  as_mapper(list(1, "a", 2))
                                        # Equivalent to function(x) x[[1]][["a"]][[2]]
  as_mapper(c("a", "b", "c"), .default = NA)

#+END_SRC
*** as_vector
Coerce a list to a vector.as_vector() collapses a list of vectors into one vector. It checks that the type of each vector is consistent with .type. 
当原始数据为 list 型时可以很方便将原始数据转化为 vector 型。
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  as.list(letters) %>% as_vector("character") %>% typeof()
#+END_SRC
*** attr_getter
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  get_rownames <- attr_getter("row.names")
  get_rownames(mtcars)

  obj1 <- structure("obj", obj_attr = "foo")
  obj2 <- structure("obj", obj_attr = "bar")
  x <- list(obj1, obj2)
  pluck(x, 1, attr_getter("obj_attr"))  # From first object
  pluck(x, 2, attr_getter("obj_attr")) 
#+END_SRC
*** join (TO) lists
**** append
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      append(list(1),list(2))      
    #+end_src
**** prepend

    #+begin_src R :results output graphics :file fig_1.png :exports both 
      prepend(list(1),list(2)) 
      ## [[1]]
      ## [1] 2
      ## [[2]]
      ## [1] 1
    #+end_src
**** splice
将多个对象添加到 list 型数据中，用 splice.

Combine objects into a list, storing S3 objects as sub-lists. splice(x, y, "foo")
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       splice(list(1,4,5),list(2,3),"foo")
       ## [[1]]
       ## [1] 1

       ## [[2]]
       ## [1] 5

       ## [[3]]
       ## [1] 2

       ## [[4]]
       ## [1] 3

       ## [[5]]
       ## [1] "foo"
     #+end_src

** furrr
这个包其实就是 purrr 的并行版本。
*** future_imap_chr
#+begin_src R :results output graphics :file fig_1.png :exports both 
  library(furrr)
  plan(multiprocess)
  future_imap_chr(sample(10), ~ paste0(.y, ": ", .x))  
#+end_src
*** future_map 
    #+begin_src R :results output graphics :file fig_1.png :exports both 
library(furrr)
library(dplyr) # for the pipe
plan(multiprocess)
1:10 %>%
  future_map(rnorm, n = 10) %>%
  future_map_dbl(mean)      

mtcars %>%
    split(.$cyl) %>%
    future_map(~ lm(mpg ~ wt, data = .x)) %>%
    future_map_dfr(~ as.data.frame(t(as.matrix(coef(.)))))
    #+end_src

*** future_map2

    #+begin_src R :results output graphics :file fig_1.png :exports both 
x <- list(1, 10, 100)
y <- list(1, 2, 3)
z <- list(5, 50, 500)
future_map2(x, y, ~ .x + .y)    
    #+end_src

*** future_pmap

    #+begin_src R :results output graphics :file fig_1.png :exports both 
future_pmap(list(x, y, z), sum)

                                        # Vectorizing a function over multiple arguments
df <- data.frame(
    x = c("apple", "banana", "cherry"),
    pattern = c("p", "n", "h"),
    replacement = c("x", "f", "q"),
    stringsAsFactors = FALSE
)
df
future_pmap(df, gsub)
future_pmap_chr(df, gsub)      
    #+end_src

** plyr
*** rbind.fill
这个函数可以将同一数据的不同的列进行合并。
rbinds a list of data frames filling missing columns with NA.
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  plyr::rbind.fill(mtcars %>% select(mpg,wt),mtcars %>% select(wt,cyl))
#+END_SRC
*** join_all
    Recursively join a list of data frames.这个函数可以将 list 型数据转换为
    data.frame 型。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
dfs <- list(
            a = data.frame(x = 1:10, a = runif(10)),
            b = data.frame(x = 1:10, b = runif(10)),
            c = data.frame(x = 1:10, c = runif(10))
            )
       join_all(dfs)
       join_all(dfs, "x")
       #+end_src

*** mlply 
       Call a multi-argument function with values taken from columns of an data frame
       or array, and combine results into a list.

       .data,
       .fun = NULL,
       ...,
       .expand = TRUE,
       .progress = "none,
  .inform = FALSE,
  .parallel = FALSE,
  .paropts = NULL
)
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      mlply(cbind(1:4, 4:1), rep)
      mlply(cbind(1:4, 4:1), seq)
    #+end_src
*** each
Aggregate multiple functions into a single function.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      each(min,max,mean)(1:10)
                                        #>  min  max mean 
                                        #>  1.0 10.0  5.5
      each("min", "max")(1:10)
                                        #> min max 
                                        #>   1  10
    #+end_src
*** failwith
Modify a function so that it returns a default value when there is an error.
这个函数可以方便对函数进行检验。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      f <- functionq(x) if (x == 1) stop("Error!") else 1
      safef <- failwith(NULL, f)
      safef(1)
      safef(2)      
    #+end_src
*** round_any
Round to multiple of any number.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      Round to multiple of any number.round_any(135, 10)
                                        #> [1] 140
      round_any(135, 100)
                                        #> [1] 100
      round_any(135, 25)
                                        #> [1] 125
      round_any(135, 10, floor)
                                        #> [1] 130
      round_any(Sys.time() + 1:10, 5)
                                        #> Warning in as.POSIXlt.POSIXct(x, tz): unknown timezone 'CST'
                                        #>  [1] "2020-02-08 13:07:45 GMT" "2020-02-08 13:07:45 GMT"
                                        #>  [3] "2020-02-08 13:07:45 GMT" "2020-02-08 13:07:45 GMT"
                                        #>  [5] "2020-02-08 13:07:45 GMT" "2020-02-08 13:07:50 GMT"
                                        #>  [7] "2020-02-08 13:07:50 GMT" "2020-02-08 13:07:50 GMT"
                                        #>  [9] "2020-02-08 13:07:50 GMT" "2020-02-08 13:07:50 GMT"
    #+end_src
*** ddply
Split data frame, apply function, and return results in a data frame.这个函数可以对数据进行分组，然后再作施加函数计算。

    #+begin_src R ::results output graphics :file fig_1.png :exports both
      nmissing <- function(x) sum(is.na(x))
# Apply to every column in a data frame
colwise(nmissing)(baseball)
#>   id year stint team lg g ab r h X2b X3b hr rbi  sb   cs bb   so  ibb hbp
#> 1  0    0     0    0  0 0  0 0 0   0   0  0  12 250 4525  0 1305 7528 377
#>    sh   sf gidp
#> 1 960 7390 5272
# This is particularly useful in conjunction with d*ply
ddply(baseball, .(year), colwise(nmissing)) %>% head()
#>   year id stint team lg g ab r h X2b X3b hr rbi sb cs bb so ibb hbp sh sf
#> 1 1871  0     0    0  0 0  0 0 0   0   0  0   0  0  0  0  0   7   7  7  7
#> 2 1872  0     0    0  0 0  0 0 0   0   0  0   0  0  0  0  0  13  13 13 13
#> 3 1873  0     0    0  0 0  0 0 0   0   0  0   0  0  0  0  0  13  13 13 13
#> 4 1874  0     0    0  0 0  0 0 0   0   0  0   0  0  0  0  0  15  15 15 15
#> 5 1875  0     0    0  0 0  0 0 0   0   0  0   0  0  0  0  0  17  17 17 17
#> 6 1876  0     0    0  0 0  0 0 0   0   0  0   0 15 15  0  0  15  15 15 15
#>   gidp
#> 1    7
#> 2   13
#> 3   13
#> 4   15
#> 5   17
#> 6   15
    #+end_src
*** adply
Split array, apply function, and return results in a data frame.

adply(.data, .margins, .fun = NULL, ..., .expand = TRUE,
  .progress = "none", .inform = FALSE, .parallel = FALSE,
  .paropts = NULL, .id = NA)

这个函数可以方便地对每行或者每列数据进行施加函数计算。
#+begin_src R ::results output graphics :file fig_1.png :exports both
  adply(baseball, .margins = 1, nmissing) %>% head()
#+end_src
*** colwise
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      
    #+end_src

** pryr
*** otype
用来确定对象是否是 S3 对象还是 S4 对象。
#+begin_src R ::results output graphics :file fig_1.png :exports both
  df <- data.frame(x = 1:10)
  otype(df)
                                        #> [1] "S3"  
#+end_src

在 S3 中，方法属于函数，称为泛型函数，和简称泛型（generics）。S3 的方法不属于对象或类。S3 型函数可以用 UseMethod()函数查看它的源代码。
*** %<a-%
Create an active binding.Infix form of makeActiveBinding which creates an active binding between a name and an expression: every time the name is accessed the expression is recomputed.

可以生成一列随机变换的数列。
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      x %<a-% runif(10)
      x
                                        #>  [1] 0.412364424 0.299694440 0.897495063 0.045052921 0.212648676
                                        #>  [6] 0.043610815 0.711287616 0.690729571 0.001689326 0.227112587
      x
                                        #>  [1] 0.78443420 0.06685143 0.93141146 0.49956063 0.61850142 0.15722230
                                        #>  [7] 0.85773514 0.93594267 0.79835833 0.41395477
    #+end_src
*** %<d-%
Infix form of delayedAssign which creates an delayed or lazy binding, which only evaluates the expression the first time it is used.
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      x %<d-% (a + b)
      a <- 10
      b <- 100
      x
                                        #> [1] 110
    #+end_src
*** f

    #+begin_src R ::results output graphics :file fig_1.png :exports both
      f(x + y)
                                        #> function (x, y) 
                                        #> x + y
      f(x + y)(1, 10)
                                        #> [1] 11
      f(x, y = 2, x + y)
                                        #> function (x, y = 2) 
                                        #> x + y  
      f({
          y <- runif(1)
          x + y
      })
                                        #> function (x) 
                                        #> {
                                        #>     y <- runif(1)
                                        #>     x + y
                                        #> }    
#+end_src
*** make_call


    #+begin_src R ::results output graphics :file fig_1.png :exports both
      make_call("f", a = 1)
                                        #> f(a = 1)
      make_call(quote(f), a = 1)
                                        #> f(a = 1)
      make_call(quote(f()), a = 1)
                                        #> f()(a = 1)
      make_call(quote(f), a = 1, b = 2)
                                        #> f(a = 1, b = 2)
      make_call(quote(f), list(a = 1, b = 2))
                                        #> f(a = 1, b = 2)      
    #+end_src
*** fget
Find a function with specified name.
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      c <- 10
      fget("c")
                                        #> function (...)  .Primitive("c")
    #+end_src
*** find_funs

Find functions matching criteria.
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      find_funs("package:base", fun_calls, "match.fun", fixed = TRUE)
                                        #> Using environment package:base
                                        #>  [1] "apply"  "eapply" "Find"   "lapply" "Map"    "mapply" "Negate"
                                        #>  [8] "outer"  "Reduce" "sapply" "sweep"  "tapply" "vapply"
      find_funs("package:stats", fun_args, "^[A-Z]+$")
                                        #> Using environment package:stats
                                        #>  [1] "addmargins"           "aggregate.data.frame" "aggregate.ts"        
                                        #>  [4] "ave"                  "chisq.test"           "cov2cor"             
                                        #>  [7] "dendrapply"           "fisher.test"          "poisson.test"        
                                        #> [10] "SSfpl"                "SSmicmen"
    #+end_src

This is a flexible function that matches function component against a regular expression, returning the name of the function if there are any matches. fun_args and fun_calls are helper functions that make it possible to search for functions with specified argument names, or which call certain functions.

#+begin_src R ::results output graphics :file fig_1.png :exports both
fun_calls(write.csv)
#>  [1] "{"           "<-"          "match.call"  "for"         "c"          
#>  [6] "if"          "!"           "is.null"     "[["          "warning"    
#> [11] "gettextf"    "eval.parent" "$"           "&&"          "is.logical" 
#> [16] "as.name"
fun_body(write.csv)
#>  [1] "{"                                                                                                               
#>  [2] "    Call <- match.call(expand.dots = TRUE)"                                                                      
#>  [3] "    for (argname in c(\"append\", \"col.names\", \"sep\", \"dec\", \"qmethod\")) if (!is.null(Call[[argname]])) "
#>  [4] "        warning(gettextf(\"attempt to set '%s' ignored\", argname), "                                            
#>  [5] "            domain = NA)"                                                                                        
#>  [6] "    rn <- eval.parent(Call$row.names)"                                                                           
#>  [7] "    Call$append <- NULL"                                                                                         
#>  [8] "    Call$col.names <- if (is.logical(rn) && !rn) "                                                               
#>  [9] "        TRUE"                                                                                                    
#> [10] "    else NA"                                                                                                     
#> [11] "    Call$sep <- \",\""                                                                                           
#> [12] "    Call$dec <- \".\""                                                                                           
#> [13] "    Call$qmethod <- \"double\""                                                                                  
#> [14] "    Call[[1L]] <- as.name(\"write.table\")"                                                                      
#> [15] "    eval.parent(Call)"                                                                                           
#> [16] "}"  
#+end_src
*** modify_lang
#+begin_src R ::results output graphics :file fig_1.png :exports both
  
#+end_src
*** object_size
object_size works similarly to object.size, but counts more accurately and includes the size of environments. compare_size makes it easy to compare the output of object_size and object.size.
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      x <- 1:1e4
      z <- list(x, x, x)
      compare_size(z)
                                        #>   base   pryr 
                                        #> 120224  40128
      object_size(x)
                                        #> 40 kB
      object_size(z)
                                        #> 40.1 kB
      object_size(x, z)
                                        #> 40.1 kB      
    #+end_src
*** find_uses

Find all functions in that call supplied functions.

#+begin_src R ::results output graphics :file fig_1.png :exports both
 names(find_uses("package:base", "sum"))
#>  [1] "[[<-.data.frame"                   
#>  [2] "[<-.data.frame"                    
#>  [3] "all.equal.character"               
#>  [4] "all.equal.numeric"                 
#>  [5] "all.equal.raw"                     
#>  [6] "as.numeric_version"                
#>  [7] "attach"                            
#>  [8] "getDLLRegisteredRoutines.character"
#>  [9] "margin.table"                      
#> [10] "merge.data.frame"                  
#> [11] "namespaceExport"                   
#> [12] "namespaceImportMethods"            
#> [13] "path.package"                      
#> [14] "print.summary.warnings"            
#> [15] "prop.table"                        
#> [16] "rank"                              
#> [17] "registerS3methods"                 
#> [18] "save"                              
#> [19] "scale.default"                     
#> [20] "seq.Date"                          
#> [21] "seq.POSIXt"                        
#> [22] "strwrap"                           
#> [23] "summary.default"                   
#> [24] "summary.factor"                    
#> [25] "summary.table"                     
#> [26] "write.dcf" 
#+end_src
*** partial
Partial apply a function, filling in some arguments.
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      f <- partial(runif, n = rpois(1, 5))
      f
                                        #> function (...) 
                                        #> runif(n = rpois(1, 5), ...)      
    #+end_src
*** rebind
Rebind an existing name
#+begin_src R ::results output graphics :file fig_1.png :exports both
  a <- 1
  rebind("a", 2)
  a
                                        #> [1] 2
#+end_src

** tidyr
*** chop()

chop() 函数的作用和 nest() 类似，都属于嵌套函数，不同的是，nest() 会改变数据结构，而 chop() 不会。
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  df <- tibble(x = c(1, 1, 1, 2, 2, 3), y = 1:6, z = 6:1)
                                        # Note that we get one row of output for each unique combination of
                                        # non-chopped variables
df
  df %>% chop(c(y, z)) %>% str()
                                        # cf nest
  df %>% nest(data = c(y, z))
#+END_SRC

*** unchop()

unchop() 作用是将 data.frame 中有 list 型的数据转换为正常的数据。值得注意的是 keep_empty 参数，如果为 TRUE 那么将没有的数据设置为 na, 如果参数为 false, 那么自动忽略这行数据。

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  df <- tibble(x = 1:4, y = list(integer(), 1L, 1:2, 1:3))
  df
  df %>% unchop(y)
  df %>% unchop(y, keep_empty = TRUE)
#+END_SRC

*** complete()
这个函数的作用在于可以填补记录。 
Turns implicit missing values into explicit missing values.这个函数可以根据特定
的分组复制其记录,然后还可以补全缺失值。 
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics
  df <- tibble(
      group = c(1:2, 1),
      item_id = c(1:2, 2),
      item_name = c(a", "b", "b",
       value1 = 1:3,
       value2 = 4:6
       )
  df
  # A tibble: 3 x 5
  ## group item_id item_name value1 value2
  ## <dbl>   <dbl> <chr>      <int>  <int>
  ## 1     1       1 a              1      4
  ## 2     2       2 b              2      5
  ## 3     1       2 b              3      6
  df %>% complete(group, nesting(item_id, item_name))
  # A tibble: 4 x 5
  ## group item_id item_name value1 value2
  ## <dbl>   <dbl> <chr>      <int>  <int>
  ## 1     1       1 a              1      4
  ## 2     1       2 b              3      6
  ## 3     2       1 a             NA     NA
  ## 4     2       2 b              2      5
  # You can also choose to fill in missing values
  df %>% complete(group, nesting(item_id, item_name), fill = list(value1 = 0))
                                        # A tibble: 4 x 5
  ## group item_id item_name value1 value2
  ## <dbl>   <dbl> <chr>      <dbl>  <int>
  ## 1     1       1 a              1      4
  ## 2     1       2 b              3      6
  ## 3     2       1 a              0     NA
  ## 4     2       2 b              2      5
#+END_SRC
*** expand
expand() is often useful in conjunction with left_join() if you want to convert implicit missing values to explicit missing values. 
expand 经常配合 left_join 函数使用。

expand 函数是 在 distinct() 的基础上进行操作的。
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  df <- tibble(
      year   = c(2010, 2010, 2010, 2010, 2012, 2012, 2012),
      qtr    = c(   1,    2,    3,    4,    1,    2,    3),
      return = rnorm(7)
  )
  df %>% expand(year, qtr)
  df %>% expand(year = 2010:2012, qtr)
  df %>% expand(year = full_seq(year, 1), qtr)
  # A tibble: 12 x 2
  ## year   qtr
  ## <dbl> <dbl>
  ##            1  2010     1
  ## 2  2010     2
  ## 3  2010     3
  ## 4  2010     4
  ## 5  2011     1
  ## 6  2011     2
  ## 7  2011     3
  ## 8  2011     4
  ## 9  2012     1
  ## 10  2012     2
  ## 11  2012     3
  ## 12  2012     4
  df %>% complete(year = full_seq(year, 1), qtr)
                                        # A tibble: 12 x 3
  ## year   qtr return
  ## <dbl> <dbl>  <dbl>
  ##                   1  2010     1 -0.649
  ## 2  2010     2  0.961
  ## 3  2010     3 -1.34 
  ## 4  2010     4 -0.701
  ## 5  2011     1 NA    
  ## 6  2011     2 NA    
  ## 7  2011     3 NA    
  ## 8  2011     4 NA    
  ## 9  2012     1  0.486
  ## 10  2012     2 -0.195
  ## 11  2012     3  1.31 
  ## 12  2012     4 NA    
# All possible combinations of vs & cyl, even those that aren't present in the data
  expand(mtcars, vs, cyl)
                                        # A tibble: 6 x 2
  ## vs   cyl
  ## <dbl> <dbl>
  ##            1     0     4
  ## 2     0     6
  ## 3     0     8
  ## 4     1     4
  ## 5     1     6
  ## 6     1     8
# Only combinations of vs and cyl that appear in the data
  expand(mtcars, nesting(vs, cyl)) #这个函数很像mtcars %>% distinct(vs,cyl)  
#+END_SRC

*** expand_grid
这个函数和 expand 一样，只不过生成了格子形状的数据。这个函数对生成最长的数据变量进行拉伸。
Compared to "expand.grid"
- Varies the first element fastest.
- Never converts strings to factors.
- Does not add any additional attributes.
- Returns a tibble, not a data frame.
- Can expand any generalised vector, including data frames.
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  expand_grid(x = 1:3, y = 1:2)
                                        # A tibble: 6 x 2
  ## x     y
  ## <int> <int>
  ##            1     1     1
  ## 2     1     2
  ## 3     2     1
  ## 4     2     2
  ## 5     3     1
  ## 6     3     2
  expand_grid(l1 = letters, l2 = LETTERS)
                                        # Can also expand data frames
  expand_grid(df = data.frame(x = 1:2, y = c(2, 1)), z = 1:3)
                                        # A tibble: 6 x 2
  ## df$x    $y     z
  ## <int> <dbl> <int>
  ##                  1     1     2     1
  ## 2     1     2     2
  ## 3     1     2     3
  ## 4     2     1     1
  ## 5     2     1     2
  ## 6     2     1     3
                                        # And matrices
  expand_grid(x1 = matrix(1:4, nrow = 2), x2 = matrix(5:8, nrow = 2))
                                        # A tibble: 4 x 2
  ## x1[,1]  [,2] x2[,1]  [,2]
  ## <int> <int>  <int> <int>
  ##                         1      1     3      5     7
  ## 2      1     3      6     8
  ## 3      2     4      5     7
  ## 4      2     4      6     8
#+END_SRC
*** drop_na
这个函数可以删除含有缺失值的行。所以说这个函数只是针对行而言。
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
data <- data.frame(x=c(NA,1,2),y=c(1,2,NA))
data %>% head
## x  y
## 1 NA  1
## 2  1  2
## 3  2 NA
###drop_na--------------------------
data %>% drop_na(x,y) #只保留全为非空的数值行
data %>% drop_na(x) #删除 x 为 NA 的行
#+END_SRC

*** extract
这个函数可以将 data 转变为一个新的一列。Given a regular expression with capturing groups, extract() turns each group into a new column. If the groups don't match, or the input is NA, the output will be NA.
这个函数类似于 stringr 包的 str_match 函数，所不同的是这个函数处理的是 tibble 或
者 data.frame 类型的数据。

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  df <- data.frame(x = c(NA, "a-b", "a-d", "b-c", "d-e"))
  df
  df %>% tidyr::extract(x, "A")
  df %>% extract(x, c("A", "B"), "([[:alnum:]]+)-([[:alnum:]]+)")
#+END_SRC
*** unite
这个函数是 extract 的反函数。 
Convenience function to paste together multiple columns into one. unite 可以将多个变量连接起来。unite()直接使用列名即可，unite_()需要在列名两边使用引号
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
#构造了一个新的变量 unite_sepal，根据 sepal.length，Sepal.Width 两个变量进行合并
demo <- iris %>%
  unite(unite_sepal, Sepal.Length, Sepal.Width, sep="_", remove=TRUE) %>%
  unite_("unite_petal", c("Petal.Length", "Petal.Width"), sep="_", remove=TRUE)
  iris %>%
      unite(unite_sepal, Sepal.Length, Sepal.Width, sep="_", remove=TRUE) 

  df <- expand_grid(x = c("a", NA), y = c("b", NA))
  df
  df %>% unite("z", x:y, remove = FALSE) #保留所有特征 
#+END_SRC
*** fill

Fill in missing values with previous or next value.Fills missing values in selected columns using the next or previous entry. This is useful in the common output format where values are not repeated, and are only recorded when they change.
这个函数可以用固定的值填补缺失值。

fill(data, ..., .direction = c("down", "up", "downup", "updown")) #direction 可
以控制填充值方向。

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  df <- data.frame(Month = 1:12, Year = c(2000, rep(NA, 11)))
  df
  df %>% fill(Year)
#+END_SRC
*** full_seq
可以填补缺失值。This is useful if you want to fill in missing values that should have been observed but weren't. For example, full_seq(c(1, 2, 4, 6), 1) will return 1:6.
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
full_seq(c(1, 2, 4, 5, 10), 1)
  ## [1]  1  2  3  4  5  6  7  8  9 10
#+END_SRC
*** gather
gather：可以将多列原始数据进行合并，按照一定组名，这样可以更好 ggplot2

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  stocks <- tibble(
      time = as.Date("2009-01-01") + 0:9,
      X = rnorm(10, 0, 1),
      Y = rnorm(10, 0, 2),
      Z = rnorm(10, 0, 4)
  )
##这里变量的值是一个维度，把值全部拉直
head(stocks)
s <- gather(stocks, "stock", "price", -time) # 这里 stock 涉及了组，也就是 key，price 是值,value
#+END_SRC
*** spread
spread：将一列数据分割成多列，多用于 char 型数据
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
#ggplot::results output graphics,plot::results graphics 
  demo %>%
      separate(unite_sepal, c("Sepal.Length", "Sepal.Width"), sep="_") %>%
      separate_("unite_petal", c("Petal.Length", "Petal.Width"), sep="_")

stocks <- data.frame(
  time = as.Date('2009-01-01') + 0:9,
  X = rnorm(10, 0, 1),
  Y = rnorm(10, 0, 2),
  Z = rnorm(10, 0, 4)
)
stocksm <- stocks %>% gather(stock, price, -time)
stocksm %>% spread(stock, price)
stocksm %>% spread(time, price)
#+END_SRC

*** nest/unnest
nest 可以处理分组数据，特别用于分组数据的建模特别有用。
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  df <- tibble(x = c(1, 1, 1, 2, 2, 3), y = 1:6, z = 6:1)
  df %>% nest(data = c(y, z))
  df %>% nest(data = one_of("y", "z"))
  iris %>% nest(data = -Species) #这个命令用的好！
  nest_vars <- names(iris)[1:4]
nest_vars
  iris %>% nest(data = one_of(nest_vars))
  iris %>%
      nest(petal = starts_with("Petal"), sepal = starts_with("Sepal"))
  iris %>%
      nest(width = contains("Width"), length = contains("Length"))
  fish_encounters %>%
      group_by(fish) %>%
      nest()
# Nesting is often useful for creating per group models
mtcars %>%
      group_by(cyl) %>%
      nest() %>%
      mutate(models = lapply(data, function(df) lm(mpg ~ wt, data = df)))
#+END_SRC

#+begin_src R :results output graphics :file fig_1.png :exports both 
  df <- tibble(
      x = 1:3,
      y = list(
          NULL,
          tibble(a = 1, b = 2),
          tibble(a = 1:3, b = 3:1)
      )
  )
  df %>% unnest(y)
  df %>% unnest(y, keep_empty = TRUE)
  #' # You can unnest multiple columns simultaneously
  df <- tibble(
      a = list(c("a", "b"), "c"),
      b = list(1:2, 3),
      c = c(11, 22)
  )
  df %>% unnest(c(a, b))
  df %>% unnest(a) %>% unnest(b)  
#+end_src

*** pack
pack() makes df narrow by collapsing(收缩) a set of columns into a single df-column.
unpack() makes data wider by expanding df-columns back out into individual
columns.pack 可以将几个变量压缩起来，变成 x$x1,x$x2,x$x3 类似这种。unpack 反过来，将压缩的变量放缩起来。

    #+begin_src R :results output graphics :file fig_1.png :exports both 
      df <- tibble(x1 = 1:3, x2 = 4:6, x3 = 7:9, y = 1:3)
      df
      df %>% pack(x = starts_with("x"))
      df %>% pack(x = c(x1, x2, x3), y = y)      
    #+end_src

    #+begin_src R :results output graphics :file fig_1.png :exports both 
      df <- tibble(
          x = 1:3,
          y = tibble(a = 1:3, b = 3:1),
          z = tibble(X = c("a", "b", "c"), Y = runif(3), Z = c(TRUE, FALSE, NA))
      )
      df
      df %>% unpack(y)
      df %>% unpack(c(y, z))
      df %>% unpack(c(y, z), names_sep = "_") #names_sep 可以支持特殊的链接符。     
    #+end_src
*** hoist 
hoist(), unnest_longer(), and unnest_wider() provide tools for rectangling, collapsing deeply nested lists into regular columns. hoist() allows you to selectively pull components of a list-column out in to their own top-level columns, using the same syntax as purrr::pluck(). unnest_wider() turns each element of a list-column into a column, and unnest_longer() turns each element of a list-column into a row. unnest_auto() picks between unnest_wider() or unnest_longer() based heuristics described below.

unnest_wider 将每一个 list-column 中的每一个元素转换为一个列。

- unnest_wider() preserves the rows, but changes the columns.

- unnest_longer() preserves the columns, but changes the rows

- unnest() can change both rows and columns.

`hoist()` is similar to `unnest_wider()` but only plucks out selected,说白了就是
有目的性的挑选出数据。   

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  df <- tibble(
      character = c("Toothless", "Dory"),
      metadata = list(
          list(
              species = "dragon",
              color = "black",
              films = c(
                  "How to Train Your Dragon",
                  "How to Train Your Dragon 2",
                  "How to Train Your Dragon: The Hidden World"
              )
          ),
          list(
              species = "clownfish",
              color = "blue",
              films = c("Finding Nemo", "Finding Dory")
          )
      )
  )
  df

                                        # Turn all components of metadata into columns
  df %>% unnest_wider(metadata)
#+END_SRC


#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
df %>% hoist(metadata,
             species = "species",
             first_film = list("films", 1L),
             third_film = list("films", 3L)
)
#+END_SRC

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  df %>%
      unnest_wider(metadata) %>%
      unnest_longer(films)
#+END_SRC

*** unnest_wider
unnest_wider() turns each element of a list-column into a column.
#unnest_wider 将每一个 list-column 中的每一个元素转换为一个列。

- unnest_wider() preserves the rows, but changes the columns.

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  df <- tibble(
      character = c("Toothless", "Dory"),
      metadata = list(
          list(
              species = "dragon",
              color = "black",
              films = c(
                  "How to Train Your Dragon",
                  "How to Train Your Dragon 2",
                  "How to Train Your Dragon: The Hidden World"
              )
          ),
          list(
              species = "clownfish",
              color = "blue",
              films = c("Finding Nemo", "Finding Dory")
          )
      )
  )
  df
  df %>% unnest_wider(metadata)
#+END_SRC

*** unnest_longer
- unnest_longer() preserves the columns, but changes the rows

- unnest() can change both rows and columns.

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  df %>%
      unnest_wider(metadata) %>%
      unnest_longer(films)
#+END_SRC

可以通过下面的例子来展示 unnest_longer 和 unnest_wider 之间的不同。

#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
df <- tibble(
  x = 1:3,
  y = list(NULL, 1:3, 4:5)
)
df
df %>% unnest_longer(y)
# Automatically creates names if widening
df %>% unnest_wider(y)
#+END_SRC

*** unnest_auto

一个更为灵活的函数是 unnest_auto.它可以去猜 guesses whether you want `unnest_longer()` or `unnest_wider()`.
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 
  df %>% 
      unnest_auto(y)
#+END_SRC

*** replace_na
replace_na 函数可以定点将固定的变量的缺失值进行填补。

    #+begin_src R :results output graphics :file fig_1.png :exports both 
      data %>% fill(x,.direction = c("updown")) #根据最靠近下面的数值来填充插补
      data %>% replace_na()
      data <- tibble(x=c(1,2,NA),y=c("a",NA,"b"))
      ###缺失值填充--------------------------
      replace_na(data,replace = list(x=1,y="down"))
    #+end_src
*** pivoting
**** pivot_longer
这个函数和 gather 很类似。
The first argument is the dataset to reshape, relig_income.

The second argument describes which columns need to be reshaped. In this case, it’s every column apart from religion.

The *'names_to'* gives the name of the variable that will be created from the data stored in the column names, i.e. income.

The *values_to* gives the name of the variable that will be created from the data stored in the cell value, i.e. count.

      #+begin_src R :results output graphics :file fig_1.png :exports both 
        relig_income
        #This dataset contains three variables:
        #religion, stored in the rows,
        #income spread across the column names, and
        #count stored in the cell values.
        relig_income %>% colnames()
        relig_income %>% 
            pivot_longer(-religion, names_to = "income", values_to = "count")
     #+end_src

The first argument is the dataset to reshape, relig_income.

The second argument describes which columns need to be reshaped. In this case, it’s every column apart from religion.

The names_to gives the name of the variable that will be created from the data stored in the column names, i.e. income.

The values_to gives the name of the variable that will be created from the data stored in the cell value, i.e. count.

#+begin_src R :results output graphics :file fig_1.png :exports both 
  billboard  %>%
      colnames()
  billboard %>% 
      pivot_longer(
          cols = starts_with("wk"), 
          names_to = "week", 
          values_to = "rank",
          values_drop_na = TRUE
      )
#+end_src

在 pivot_longer 函数里，参数里 cols = starts_with("wk"),表示原数据有很多的以“wk”标
签的变量，也就是说将这些 wk 的变量拉长，然后丢失 NA.

#+begin_src R :results output graphics :file fig_1.png :exports both 
  billboard %>% 
      pivot_longer(
          cols = starts_with("wk"), 
          names_to = "week", 
          names_prefix = "wk",
          names_ptypes = list(week = integer()),
          values_to = "rank",
          values_drop_na = TRUE,
          )  
#+end_src

如果需要将 week 变量转换为整数，可以通过使用两个附加参数来做到这一点：
names_prefix 去除 wk 前缀，names_ptypes 指定 week 应该为整数.
#+begin_src R :results output graphics :file fig_1.png :exports both 
  who %>% head()
  who%>% colnames()
  who %>% 
      pivot_longer(
          cols = new_sp_m014:newrel_f65,
          names_to = c("diagnosis", "gender", "age"), 
          names_pattern = "new_?(.*)_(.)(.*)",
          values_to = "count"
      )  
#+end_src

可以通过在 names_to 中指定多个列名称，然后提供 names_sep 或 names_pattern 来分解这些变量。在这里，names_pattern 是最自然的选择。它具有类似的提取接口：您给它一个包含组的正则表达式（由（）定义），并将每个组放在一列中。

#+begin_src R :results output graphics :file fig_1.png :exports both 
  who %>%
      pivot_longer(
              cols = new_sp_m014:newrel_f65,
              names_to = c("diagnosis", "gender", "age"), 
              names_pattern = "new_?(.*)_(.)(.*)",
              names_ptypes = list(
                  gender = factor(levels = c("f", "m")),
                  age = factor(
                      levels = c("014", "1524", "2534", "3544", "4554", "5564", "65"), 
                      ordered = TRUE
                  )
              ),
              values_to = "count"
          )
#+end_src

names_ptypes 可以固定数据类型。 

#+begin_src R :results output graphics :file fig_1.png :exports both 
  family <- tribble(
      ~family,  ~dob_child1,  ~dob_child2, ~gender_child1, ~gender_child2,
      1L, "1998-11-26", "2000-01-29",             1L,             2L,
      2L, "1996-06-22",           NA,             2L,             NA,
      3L, "2002-07-11", "2004-04-05",             2L,             2L,
      4L, "2004-10-10", "2009-08-27",             1L,             1L,
      5L, "2000-12-05", "2005-02-28",             2L,             1L,
      )
  family <- family %>% mutate_at(vars(starts_with("dob")), parse_date)
  family
  family %>% 
      pivot_longer(
          -family, 
          names_to = c(".value", "child"), 
          names_sep = "_", 
          values_drop_na = TRUE
      )  
#+end_src

除了 names_pattern 设置模式，names_sep 也可以设置模式。

#+begin_src R :results output graphics :file fig_1.png :exports both 
  pnl <- tibble(
      x = 1:4,
      a = c(1, 1,0, 0),
      b = c(0, 1, 1, 1),
      y1 = rnorm(4),
      y2 = rnorm(4),
      z1 = rep(3, 4),
      z2 = rep(-2, 4),
      )

  pnl %>% 
      pivot_longer(
          -c(x, a, b), 
          names_to = c(".value", "time"), 
          names_pattern = "(.)(.)"
      )
#+end_src

**** pivot_wider

pivot_wider 是 pivot_longer 的逆操作。

     #+begin_src R :results output graphics :file fig_1.png :exports both 
       fish_encounters %>% 
           head()

       fish_encounters %>% 
           pivot_wider(names_from = station, values_from = seen)
     #+end_src

上面的值有缺失，所以需要进行填补缺失值

#+begin_src R :results output graphics :file fig_1.png :exports both 
  fish_encounters %>% 
      pivot_wider(
          names_from = station, 
          values_from = seen,
          values_fill = list(seen = 0)
      )  
#+end_src

上面的命令是说明用 seen=0 进行填补。

*** uncount 
Performs the opposite operation to dplyr::count(), duplicating rows according to a weighting variable (or expression).
    #+begin_src R :results output graphics :file fig_1.png :exports both 
df <- tibble(x = c("a", "b"), n = c(1, 2))
uncount(df, n)
uncount(df, 2)
# Or expressions
uncount(df, 2 / n)
    #+end_src

** magrittr
*** set_rownames()
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  library(magrittr)
  data =data.frame(x=c(1,2,3,4),y=c(2,3,4,5))
  data
  data %>% set_rownames(c("a","b","c","d"))
#+END_SRC
*** extract
相当于 base 包中的 x[,]的作用
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  iris %>%
      magrittr::extract(, 1:4) %>%
      head
#+END_SRC
*** %>%/%<>%/%T>%/%$% 
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      rnorm(200) %>%
      matrix(ncol = 2)
    #+end_src
%T>%向左操作符，其实功能和 %>% 基本是一样的，只不过它是把左边的值做为传递的值，而不是右边的值。
Pipe a value forward into a function- or call expression and return the original value instead of the result. This is useful when an expression is used for its side-effect, say plotting or printing.
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  rnorm(200) %>%
      matrix(ncol = 2) %T>%
      plot %>% # plot usually does not return anything.
      colSums
#+END_SRC
%$% 类似于 data.frame 中的$符号。
#+begin_src R :results output graphics :file fig_1.png :exports both 
data.frame(id = c(1),z = rnorm(100)) %$%
  ts.plot(z)  
#+end_src
*** TODO crossing()
暂时不会。
#+BEGIN_SRC R :results output graphics :file fig_1.png :exports both
  #ggplot::results output graphics,plot::results graphics 

#+END_SRC
** tidymodel
*** crayon 
**** %+%
两个字符型 paste,但是必须长度要相等。
The length of the two arguments must match, or one of them must be of length one. If the length of one argument is one, then the output's length will match the length of the other argument. See examples below.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      letters[1:10] %+% chr(1:10)      
    #+end_src
*** broom
*** tidy
可以标准化模型输出。

Tidy summarizes information about the components of a model. A model component might be a single term in a regression, a single hypothesis, a cluster, or a class. Exactly what tidy considers to be a model component varies cross models but is usually self-evident. If a model has several distinct types of components, you will need to specify which components to return.


    #+begin_src R :results output graphics :file fig_1.png :exports both 
      library(ggplot2)
      library(dplyr)
      mod <- lm(mpg ~ wt + qsec, data = mtcars)
      tidy(mod)
      # A tibble: 3 x 5
      ## term        estimate std.error statistic  p.value
      ## <chr>          <dbl>     <dbl>     <dbl>    <dbl>
      ## 1 (Intercept)   19.7       5.25       3.76 7.65e- 4
      ## 2 wt            -5.05      0.484    -10.4  2.52e-11
      ## 3 qsec           0.929     0.265      3.51 1.50e- 3

      glmfit <- glm(am ~ wt, mtcars, family="binomial")
      tidy(glmfit)
                                        # A tibble: 2 x 5
      ## term  estimate std.error statistic p.value
      ## <chr>    <dbl>     <dbl>     <dbl>   <dbl>
                                                ## 1 (Int…    12.0       4.51      2.67 0.00759
                                                   ## 2 wt       -4.02      1.44     -2.80 0.00509
      
    #+end_src
*** glance

Glance accepts a model object and returns a tibble::tibble() with exactly one row of model summaries. The summaries are typically goodness of fit measures, p-values for hypothesis tests on residuals, or model convergence information.

#+begin_src R :results output graphics :file fig_1.png :exports both 
library(ggplot2)
library(dplyr)
mod <- lm(mpg ~ wt + qsec, data = mtcars)
tidy(mod)
glance(mod)      
#+end_src
*** augment
augment adds columns to a dataset, containing information such as fitted values, residuals or cluster assignments. All columns added to a dataset have . prefix to prevent existing columns from being overwritten.

#+begin_src R :results output graphics :file fig_1.png :exports both 
  fit <- lm(Sepal.Width ~ Petal.Length + Petal.Width, iris)
  tidy(fit)
  augment(fit, data = iris)
#+end_src
*** infer
**** specify
specify(x, formula, response = NULL, explanatory = NULL, success = NULL)
Arguments
x	
A data frame that can be coerced into a tibble.

formula	
A formula with the response variable on the left and the explanatory on the right. Alternatively, a response and explanatory argument can be supplied.

response	
The variable name in x that will serve as the response. This is an alternative to using the formula argument.

explanatory	
The variable name in x that will serve as the explanatory variable. This is an alternative to using the formula argument.

success	
The level of response that will be considered a success, as a string. Needed for inference on one proportion, a difference in proportions, and corresponding z stats.


     #+begin_src R :results output graphics :file fig_1.png :exports both 
       # specifying for a point estimate on one variable
       gss %>%
           specify(response = age)

                                        # ...or with named arguments!
       gss %>%
           specify(response = age, explanatory = partyid)       
     #+end_src
*** rlang
**** call2
Create a call.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       library(rlang)
       args <- list(na.rm = TRUE, trim = 0)
       call2("mean", 1:10, !!!args)
       ## mean(1:10, na.rm = TRUE, trim = 0)
       call2("mean", 1:10, !!!args)
       ## base::list(1, 2)
       call2("[", quote(x), , drop = )
       ## x[, drop = ]
     #+end_src
**** is_call
This function tests if x is a call. 
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       is_call(quote(foo(bar)), "foo")
       is_call(quote(foo(bar)))  
     #+end_src
**** quo 
Quotation is a mechanism by which an expression supplied as argument is captured by a function. Instead of seeing the value of the argument, the function sees the recipe (the R code) to make that value. This is possible because R expressions are representable as regular objects in R.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       quo <- quo(letters)
       quo
       ## <quosure>
       ## expr: ^letters
       ## env:  global
     #+end_src
**** get_expr 
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       get_expr
       ## letters
     #+end_src
**** eval_tidy
     These helpers are useful to make your function work generically with quosures and raw expressions. 
     #+begin_src R :results output graphics :file fig_1.png :exports both 
eval_tidy(quo)       
## [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o"
## [16] "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z"
     #+end_src
**** seq2
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       seq2(2, 10)
                                        #> [1]  2  3  4  5  6  7  8  9 10
       seq2(10, 2)
                                        #> integer(0)
       seq(10, 2)
                                        #> [1] 10  9  8  7  6  5  4  3  2
       seq2_along(10, letters)
                                        #>  [1] 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26       
     #+end_src
**** type-predicates
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       x=c(1,2,3) 
       is_character(x)
       is_integer(x)
       is_vector(x)
       x=list(1,2,3)
       is_list(x)
     #+end_src
**** tidy-dots
***** list2
list2() is equivalent to list(...) but provides tidy dots semantics.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       name <- "Jane"
       list2(!!name := 1 + 2)
       ## $Jane
       ## [1] 3  
     #+end_src
**** vector-construcion
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       # These constructors are like a typed version of c():
       c(TRUE, FALSE)
       lgl(TRUE, FALSE)       
       dbl(!!! list(a = 1))
                                        # Lists can be spliced:
       dbl(10, !!! list(1, 2L), TRUE)
# They follow a restricted set of coercion rules:
       int(TRUE, FALSE, 20)       
     #+end_src
**** missing
na_lgl,na_int,na_dbl,na_chr,na_cpl.类似 NA_integer_ 等命令。
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       typeof(NA)
       typeof(na_lgl)
       typeof(na_int)
                                        # Note that while the base R missing symbols cannot be overwritten,
                                        # that's not the case for rlang's aliases:
       na_dbl <- NA
       typeof(na_dbl)
     #+end_src
**** quasiquotation
***** !!
The !! operator unquotes its argument. It gets evaluated immediately in the surrounding context.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       name <- "Jane"
       list2(!!name := 1 + 2)       
     #+end_src
***** !!!
The !!! operator unquotes and splices its argument. The argument should
represent a list or a vector. Each element will be embedded in the surrounding
call, i.e. each element is inserted as an argument. If the vector is named, the
names are used as argument names.
#+begin_src R :results output graphics :file fig_1.png :exports both 
  args <- list(1:3, na.rm = TRUE)
  quo(mean(!!!args))
#+end_src

**** new_list/new_logical 
These functions construct vectors of a given length, with attributes specified via dots. Except for new_list() and new_raw(), the empty vectors are filled with typed missing values.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       new_list(10)
       new_logical(10)
       ## [1] NA NA NA NA NA NA NA NA NA NA
       new_character(10)
       ## [1] NA NA NA NA NA NA NA NA NA NA       
     #+end_src

**** %|%
Replace missing values.This infix function is similar to %||% but is vectorised and provides a default value for missing elements. It is faster than using base::ifelse() and does not perform type conversions.

     #+begin_src R :results output graphics :file fig_1.png :exports both 
       c("a", "b", NA, "c") %|% "default"
       ## [1] "a"       "b"       "default" "c" 
     #+end_src

**** %||%
Default value for NULL.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
    1 %||% 2
    ## [1] 1
    NULL %||% 2
    ## [1] 2
    #+end_src

*** rsample 
**** bootstraps
A bootstrap sample is a sample that is the same size as the original data set that is made using replacement. 
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       library(purrr)
       iris2 <- iris[1:130, ]
       set.seed(13)
       resample1 <- bootstraps(iris2, times = 3)
     #+end_src
*** tibble
**** add_row
This is a convenient way to add one or more rows of data to an existing data frame. 
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       df <- tibble(x = 1:3, y = 3:1)
       add_row(df, x = 4, y = 0)
       add_row(df, x = 4, y = 0, .before = 2)
       add_row(df, x = 4:5, y = 0:-1)
     #+end_src
**** add_column
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       df <- tibble(x = 1:3, y = 3:1)
       add_column(df, z = -1:1, w = 0)       
     #+end_src
**** as_tibble
Coerce lists, matrices, and more to data frames.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       l <- list(x = 1:500, y = runif(500), z = 500:1)
       df <- as_tibble(l)
                                        # A tibble: 500 x 3
       ## x     y     z
       ## <int> <dbl> <int>
       ## 1     1 0.942   500
       ## 2     2 0.557   499
       ## 3     3 0.832   498
     #+end_src
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       m <- matrix(rnorm(50), ncol = 5)
       colnames(m) <- c("a", "b", "c", "d", "e")
       df <- as_tibble(m)
                                        # A tibble: 10 x 5
       ## a       b      c       d      e
       ## <dbl>   <dbl>  <dbl>   <dbl>  <dbl>
       ## 1  0.240  -0.0386 -1.47   0.480   0.372
       ## 2 -0.205  -0.820   0.559 -0.350  -1.01 
     #+end_src
**** enframe
Converting vectors to data frames, and vice versa.enframe() converts named atomic vectors or lists to one- or two-column data frames. For a list, the result will be a nested tibble with a column of type list. For unnamed vectors, the natural sequence is used as name column.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       enframe(c(a = 5, b = 7))
                                        # A tibble: 2 x 2
       ## name  value
       ## <chr> <dbl>
       ## 1 a       5
       ## 2 b       7
     #+end_src
**** deframe
deframe() converts two-column data frames to a named vector or list, using the first column as name and the second column as value. If the input has only one column, an unnamed vector is returned.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       deframe(enframe(1:3))
       deframe(tibble(a = 1:3))
       ## [1] 1 2 3
       deframe(tibble(a = as.list(1:3)))       
     #+end_src
**** has_rownames
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       has_rownames(mtcars)
       ## [1] TRUE
       has_rownames(iris)       
       ## [1] FALSE 
     #+end_src
**** glimpse
This is like a transposed version of print(): columns run down the page, and
data runs across. This makes it possible to see every column in a data frame. 
#+begin_src R :results output graphics :file fig_1.png :exports both 
  glimpse(mtcars)
  ## Observations: 32
  ## Variables: 11
  ## $ mpg  <dbl> 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, …
  ## $ cyl  <dbl> 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, …
  ## $ disp <dbl> 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0,…
  ## $ hp   <dbl> 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 1…
  ## $ drat <dbl> 3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, …
#+end_src
**** is_tibble 
Test if the object is a tibble.This function returns TRUE for tibbles or subclasses thereof, and FALSE for all other objects, including regular data frames.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
      is_tibble(tibble(a = 1:3)) 
     #+end_src
**** type_sum
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       obj_sum(1:10)
       ## [1] "int [10]"
       obj_sum(matrix(1:10))
       ## [1] "int[,1] [10 × 1]"       
     #+end_src
**** subsetting 
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       df <- data.frame(a = 1:3, bc = 4:6)
       tbl <- tibble(a = 1:3, bc = 4:6)
                                        # Subsetting single columns:
       df[, "a"]
       tbl[, "a"]
       tbl[, "a", drop = TRUE]
       as.data.frame(tbl)[, "a"]      
     #+end_src
**** tribble
Create tibbles using an easier to read row-by-row layout.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       tribble(
           ~colA, ~colB,
           "a",   1,
           "b",   2,
           "c",   3
       )
       tribble(
           ~x,  ~y,
           "a", 1:3,
           "b", 4:6
       )
     #+end_src
** glue

** stringr
*** 其他类型的模式
**** regex()
***** ignore_case = TRUE 

既可以匹配大写字母，也可以匹配小写字母，它总是使用当前的区域设催产
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       str_view(bananas,"banana")
       str_view(bananas,regex("banana",ignore_case = TRUE))       
     #+end_src
***** multiline = TRUE  

可以使得 ^ 和 $ 从每行的开头和末尾开始匹配，而不是从完整字符串的开头和末尾开始匹配。
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       str_extract(x,"^Line")
       ## [1] "Line"
       str_extract_all(x, regex("^Line", multiline = TRUE ))[[1]]       
       ## [1] "Line" "Line" "Line"
     #+end_src
***** comments = TRUE  

可以让你在复杂的正则表达式中加入注释和空白字符，以便更易理解。匹配时会忽略空格和 # 后面的内容。如果想要匹配一个空格，需要对其进行转义："\\"
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       phone <- regex("
       \\(? # 可选的开括号 
               (\\d{3}) # 地区编码 
               [)- ]? # 可选的闭括号、短划线或空格 
               (\\d{3}) # 另外3个数字 
               [ -]? # 可选的空格或短划线 
               (\\d{3}) # 另外3个数字
               ", comments = TRUE)
       str_match("514-791-8141", phone)
     #+end_src
***** dotall = TRUE 
可以使得 . 匹配包括 \n 在内的所有字符。
**** fixed()
fix() 函数可以按照字符串的字节形式进行精确匹配，它会忽略正则表达式中的所有特殊字
符，并在非常低的层次上进行操作。

#+begin_src R :results output graphics :file fig_1.png :exports both 
  str_detect(sentences,fixed("the"))  
#+end_src

在匹配非英语数据时，要慎用 fixed() 函数，它可能会出现问题，因为此时同一个字符经
常有多种表达方式。
**** coll() 

函数使用标准排序规则来比较字符串，这在进行不区分大小写的匹配时是非常有效的。。注意，可以在 coll() 函数中设置 locale 参数，以确定使用哪种规则来比较字符。 遗憾的是，世界各地所使用的规则是不同的！
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       i <- c("I", " İ ", "i", "ı")
       str_subset(i, coll("i", ignore_case = TRUE ))
       ## [1] "I" "i"
       str_subset(i, coll("i", ignore_case = TRUE , locale = "tr"))
       ## [1] "İ" "i"
     #+end_src
**** boundary
在介绍 str_split() 函数时，你已经知道可以使用 boundary() 函数来匹配边界。
#+begin_src R :results output graphics :file fig_1.png :exports both 
  x <- "This is a sentence." 
  str_view_all(x, boundary("word"))
#+end_src
*** str_c
字符串组合。两个字符串相连。要想组合两个字符或更多的字符串，可以使用 str_c.这个函数就相当于 paste 和 paste0.
#+begin_src R :results output graphics :file fig_1.png :exports both 
  str_c("x","y")
  str_c("x","y",sep = ",")
#+end_src

base 包中 paste0,paste 有两个函数功能与 str_c 函数相同.需要注意的是，两个函数对缺失值的处理也不相同。
#+begin_src R ::results output graphics :file fig_1.png :exports both
  paste("x","y",NA)
  ## [1] "x y NA"
  paste0("x","y",NA)
  ## [1] "xyNA"
  str_c("x","y",NA_character_)
  ## [1] NA
  str_c("x","y",NA,sep = " ")  
  ## [1] NA
#+end_src

处理缺失值的时候需要用到 str_replace_na 函数。
#+begin_src R ::results output graphics :file fig_1.png :exports both
  x <- c("abc",NA)
  str_c("|-",x,"-|")
  str_c("|-",str_replace_na(x),"-|")  
#+end_src
与 if 相结合，长度为 0 的对象会被丢弃。
#+begin_src R ::results output graphics :file fig_1.png :exports both
  name <- "Hadley"
  time_of_day <- "morning"
  birthday <- FALSE
  str_c(
      "Good ",time_of_day," ",name,
      if(birthday) " and Happy birthday",
      "."
  )  
#+end_src
要想将字符向量合并为字符串，可以使用 collapse() 函数.
#+begin_src R ::results output graphics :file fig_1.png :exports both
  str_c(c("x","y"),collapse = ", ")
#+end_src
*** str_length
字符长度
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       str_length("abc")
       ## [1] 3
     #+end_src
*** str_sub
字符串取子集。str_sub()函数中还有 start 和 end 参数，给出了子串的位置。
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       x <- c("abcdef", "ghifjk")
# The 3rd letter
       str_sub(x, 3, 3)
                                        # The 2nd to 2nd-to-last character
       str_sub(x, 2, -2)
                                        #> [1] "bcde" "hifj"
       str_sub(x, 3, 3) <- "X"
       x
                                        #> [1] "abXdef" "ghXfjk"
     #+end_src
     #+begin_src R ::results output graphics :file fig_1.png :exports both
       #负数表示从后往前数
       str_sub(x,-3,-1)
       str_sub("a",1,5)
       str_sub(x,1,1) <- str_to_lower(str_sub(x,1,1))
       x
       ## [1] "apple"  "banana" "pear"         
     #+end_src
*** str_sort
字符排序。不同语言体系有不同的字符排序方式。
#+begin_src R ::results output graphics :file fig_1.png :exports both
  str_sort(x,locale = "en")
  str_sort(x,locale = "haw")
#+end_src
*** str_order
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      str_order(letters, locale = "en")
      ## [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
    #+end_src
*** str_dup
To duplicate individual strings, you can use str_dup():
str_dup(string, times),times:Number of times to duplicate each string.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       str_dup(x, c(2, 3))
       ## [1] "abcdefabcdef"       "ghifjkghifjkghifjk"
     #+end_src
*** str_pad 
这个命令就是填补空格键，或者其他模式。
str_pad(string, width, side = c("left", "right", "both"), pad = " ")
str_pad() pads(填补) a string to a fixed length by adding extra whitespace on the left, right, or both sides.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       x <- c("abc", "defghi")
       str_pad(x, 10) # default pads on left
       #> [1] "       abc" "    defghi"       
     #+end_src
*** str_detect
模式匹配。
Control matching behaviour with modifier functions.
fixed
Compare literal bytes in the string. This is very fast, but not usually what you want for non-ASCII character sets.
coll
Compare strings respecting standard collation rules.

regex
The default. Uses ICU regular expressions.

boundary
Match boundaries between things.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       pattern <- "a.b"
       strings <- c("abb", "a.b")
       str_detect(strings, pattern)
       ## [1] TRUE TRUE
       i <- c("I", "\u0130", "i")
       i
       str_detect(i, fixed("i", TRUE))
       str_detect(i, coll("i", TRUE))
       str_detect(i, coll("i", TRUE, locale = "tr"))
     #+end_src
*** str_remove
Remove matched patterns in a string.
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      fruits <- c("one apple", "two pears", "three bananas")
      str_remove(fruits, "[aeiou]")
                                        #> [1] "ne apple"     "tw pears"     "thre bananas"
      str_remove_all(fruits, "[aeiou]")
                                        #> [1] "n ppl"    "tw prs"   "thr bnns"

      fruits <- c("o.app.le", "two pears", "three bananas")
      str_remove(fruits, "[.]")
                                        #> [1] "oapp.le"       "two pears"     "three bananas"
      str_remove_all(fruits, "[.]")
                                        #> [1] "oapple"        "two pears"     "three bananas"      
    #+end_src
*** str_subset
str_detect 函数的一种常见用法是选取出匹配某种模式的元素，还可以用 str_subset 通过
逻辑取子集。
#+begin_src R :results output graphics :file fig_1.png :exports both 
  words[str_detect(words,"x$")]
  str_subset(words,"x$")  
#+end_src
*** str_count
str_count 返回的是字符串中匹配的数量。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- c("apple","banana")
      str_count(x,"a")
    #+end_src
*** str_view
字符匹配
#+begin_src R ::results output graphics :file fig_1.png :exports both
  x <- c("Apple","Banana","Pear")
  str_view(x,"an") #最基础是精确匹配 
#+end_src
**** str_view_all
注意 str_view_all() 函数的使用。你很快就会知道，很多 stringr 函数都是成对出现的：一 个函数用于单个匹配，另一个函数用于全部匹配，后者会有后缀 _all。
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       str_view("abababa","aba")
       str_view_all("abababa","aba")          
     #+end_src
**** 匹配.
 #+begin_src R ::results output graphics :file fig_1.png :exports both
   #更复杂一些的模式是使用 .，它可以匹配任意字符（除了换行符）
   str_view(x,".a.")
                                         #\\.匹配.
   x=c("b.a","ab")
   str_view(x,"\\.")  
 #+end_src
**** 匹配\
  那么如何匹配\?如果 \ 在正则表达式中用作转义字符，那么如何匹配 \ 这个字符呢？我们还是需要去除其
  特殊意义，建立形式为 \\ 的正则表达式。要想建立这样的正则表达式，我们需要使用一个
  字符串，其中还需要对 \ 进行转义。这意味着要想匹配字符 \，我们需要输入 "\\\\
  #+begin_src R ::results output graphics :file fig_1.png :exports both
    x=c("b.a","ab","a\b")
    str_view(x,"\\\\")
  #+end_src
**** 锚点
^ 从字符串开头进行匹配
$ 从字符串末尾进行匹配

**** 匹配多个字符
\d:matches any digit.The complement, \D, matches any character that is not a decimal digit.
#+begin_src R ::results output graphics :file fig_1.png :exports both
  str_extract_all("1 + 2 = 3", "\\d",simplify = T)
  str_extract_all("1 + 2 = 3", "\\d+",simplify = T)
  str_extract_all("1 + 2 = 3", "\\D",simplify = T)
  str_extract_all("1 + 2 = 3", "\\D+",simplify = T) 
#+end_src
\s: matches any whitespace.
#+begin_src R ::results output graphics :file fig_1.png :exports both
  (text <- "Some  \t badly\n\t\tspaced \f text")
  str_replace_all(text, "\\s+"," ")
  str_extract_all(text, "\\S+",simplify = T) 
#+end_src
\p{property name} matches any character with specific unicode property, like \p{Uppercase} or \p{Diacritic}. 
#+begin_src R ::results output graphics :file fig_1.png :exports both
  (text <- c('"Double quotes"', "«Guillemet»", "“Fancy quotes”"))
  str_replace_all(text, "\\p{quotation mark}", "'")  
#+end_src
\w matches any “word” character, which includes alphabetic characters, marks and decimal numbers. The complement, \W, matches any non-word character.

#+begin_src R ::results output graphics :file fig_1.png :exports both
  str_extract_all("Don't eat that!", "\\w+")[[1]]
  #"Don"  "t"    "eat"  "that"
  str_extract_all("Don't eat that!", "\\W+")[[1]]
                                        #[1] "'" " " " " "!"
  str_split("Don't eat that!", "\\W")[[1]]
  str_split("Don't eat that!", "\\w+")[[1]]
#+end_src

\b matches word boundaries, the transition between word and non-word characters. \B matches the opposite: boundaries that have either both word or non-word characters on either side.

#+begin_src R ::results output graphics :file fig_1.png :exports both
  str_replace_all("The quick brown fox", "\\b", "_")
                                        #> [1] "_The_ _quick_ _brown_ _fox_"
  str_replace_all("The quick brown fox", "\\B", "_")
                                        #> [1] "T_h_e q_u_i_c_k b_r_o_w_n f_o_x"
#+end_src
[abc]:匹配 a,b,c
[a-z]:匹配每个在 a-z 之间的字符
[^abc]:匹配 anything 除了 a,b,c
[\^\-]:匹配^ 或 -.
There are a number of pre-built classes that you can use inside []:

[:punct:]: punctuation.
[:alpha:]: letters.
[:lower:]: lowercase letters.
[:upper:]: upperclass letters.
[:digit:]: digits.
[:xdigit:]: hex digits.
[:alnum:]: letters and numbers.
[:cntrl:]: control characters.
[:graph:]: letters, numbers, and punctuation.
[:print:]: letters, numbers, punctuation, and whitespace.
[:space:]: space characters (basically equivalent to \s).
[:blank:]: space and tab.
      #+begin_src R ::results output graphics :file fig_1.png :exports both
        str_view(x,"^a")
        str_view(x,"a$")
        str_view(x,"^b.a$") #强制正则表达式匹配一个完整字符串，可以同时设置^和$这两个锚点        
      #+end_src
| is the alternation operator, which will pick between one or more possible matches. For example, abc|def will match abc or def.
#+begin_src R ::results output graphics :file fig_1.png :exports both
  str_detect(c("abc", "def", "ghi"), "abc|def")  
#+end_src

#+begin_src R ::results output graphics :file fig_1.png :exports both
  str_extract(c("grey", "gray"), "gre|ay")
                                        #> [1] "gre" "ay"
  str_extract(c("grey", "gray"), "gr(e|a)y")
                                        #> [1] "grey" "gray"  
#+end_src

匹配多次重复字符
?:0 次或 1 次
+:1 次或多次
*:0 次或多次
#+begin_src R ::results output graphics :file fig_1.png :exports both
  x <- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"
  str_view(x,"CC?")
  str_view(x,"CC+")
  str_view(x,"CC*")
  str_view(x,"C[LX]+")  
#+end_src

需要注意这些运算符的优先级非常高，因此使用 colou?r 既可以匹配 color,也可以匹配 colour.这意味着很多时候需要使用括号，比如 bana(na)+.

你还可以精确设置匹配的次数：

- {n}:匹配 n 次
- {n,}:匹配 n 次或更多次
- {,m}:最多匹配 m 次
- {n,m}:匹配 n 到 m 次

#+begin_src R ::results output graphics :file fig_1.png :exports both
  str_view(x,"C{2}")
  str_view(x,"C{2,}")
  str_view(x,"C{2,3}")
  str_view(x,"C{2,3}?") #匹配尽量短的字符串
  str_view(x,"C[LX]+?")  
#+end_src

*** str_to_lower/str_to_upper 
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      str_to_upper(c("i"))
      str_to_lower(c("I"))
    #+end_src
*** str_to_title
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      dog <- "The quick brown dog"
      str_to_title(dog)
      ## [1] "The Quick Brown Dog"
    #+end_src
*** str_to_sentence
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      str_to_sentence("the quick brown dog")
      ## [1] "The quick brown dog"
    #+end_src
*** str_extract
Extract matching patterns from a string.

#+begin_src R :results output graphics :file fig_1.png :exports both 
  str_extract_all("1 + 2 = 3", "\\d",simplify = T)
  ## [,1] [,2] [,3]
  ## [1,] "1"  "2"  "3" 
  str_extract_all("1 + 2 = 3", "\\d+",simplify = T)
  str_extract_all("1 + 2 = 3", "\\D",simplify = T)
  ## [,1] [,2] [,3] [,4] [,5] [,6]
  ## [1,] " "  "+"  " "  " "  "="  " " 
  str_extract_all("1 + 2 = 3", "\\D+",simplify = T) 
#+end_src
*** str_match
Extract matched groups from a string.str_match()函数可以给出每个独立分组，该函数
返回的不是字符向量，而是一个矩阵，其中一列是完整匹配，后面的列是每个分组的匹配。

#+begin_src R :results output graphics :file fig_1.png :exports both 
  x <- c("<a> <b>", "<a> <>", "<a>", "", NA)
  str_match(x, "<(.*?)> <(.*?)>")  
#+end_src
*** str_which
输出匹配到字符的位置。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      fruit <- c("apple", "banana", "pear", "pinapple")
      str_which(fruit, "a")
      ## [1] 1 2 3 4 #这说明所有的字符都有“a”
      fruit <- c("apple", "hdos")
      str_which(fruit, "a",negate = TRUE)
      ## [1] 2 #这说明第2个字符没有“a”。
    #+end_src
*** str_replace
str_replace(string, pattern, replacement),str_replace_all(string, pattern, replacement).

Replace matched patterns in a string.
#+begin_src R :results output graphics :file fig_1.png :exports both 
  fruits <- c("one apple", "two pears", "three bananas")
  str_replace(fruits, "[aeiou]", "-")
#+end_src
**** str_replace_all
       #+begin_src R :results output graphics :file fig_1.png :exports both 
         x <- c("apple", "pear", "banana") 
         str_replace(x, "[aeiou]", "-")
         ## [1] "-pple"  "p-ar"   "b-nana"
         str_replace_all(x, "[aeiou]", "-")
         ## [1] "-ppl-"  "p--r"   "b-n-n-"
         (text <- "Some  \t badly\n\t\tspaced \f text")
         str_replace_all(text, "\\s+"," ")        
       #+end_src
*** str_split
str_split()函数可以将字符串拆分为多个片段。通过设置 simplify=TRUE 返回一个矩阵。
#+begin_src R :results output graphics :file fig_1.png :exports both 
  sentences %>% 
      head(5) %>% 
      str_split(" ")
  sentences %>% 
      head(5) %>% 
      str_split(" ",simplify = TRUE)
#+end_src

还可以设定拆分片段的最大数量：
#+begin_src R :results output graphics :file fig_1.png :exports both 
  fields <- c("Name: Hadley", "Country: NZ", "Age: 35") 
  fields %>% str_split(": ", n = 2, simplify = TRUE )
#+end_src
*** str_split_fixed
    
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      fruits <- c(
          "apples and oranges and pears and bananas",
          "pineapples and mangos and guavas"
      )
      str_split_fixed(fruits, " and ", 3)
      ## [,1]         [,2]      [,3]               
      ## [1,] "apples"     "oranges" "pears and bananas"
      ## [2,] "pineapples" "mangos"  "guavas" 
      str_split_fixed(fruits, " and ", 4)
      ## [,1]         [,2]      [,3]     [,4]     
      ## [1,] "apples"     "oranges" "pears"  "bananas"
      ## [2,] "pineapples" "mangos"  "guavas" ""   
    #+end_src
*** str_locate
str_locate() 和 str_locate_all() 函数可以给出每个匹配的开始位置和结束位置。当没有 其他函数能够精确地满足需求时，这两个函数特别有用。你可以使用 str_locate() 函数找 出匹配的模式，然后使用 str_sub() 函数来提取或修改匹配的内容。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      fruit <- c("apple", "banana", "pear", "pineapple")
      str_locate(fruit, "$")
      str_locate(fruit, "a")      
    #+end_src
*** str_wrap
Wrap strings into nicely formatted paragraphs.
     #+begin_src R ::results output graphics :file fig_1.png :exports both
       thanks_path <- file.path(R.home("doc"), "THANKS")
       thanks <- str_c(readLines(thanks_path), collapse = "\n")
       thanks <- word(thanks, 1, 3, fixed("\n\n"))
       cat(str_wrap(thanks), "\n")
       cat(str_wrap(thanks, width = 40), "\n")       
     #+end_src
*** str_trim
str_trim() removes whitespace from start and end of string; str_squish() also reduces repeated whitespace inside a string.
str_trim 不光能够处理空格符，还能处理\n,\t 这些转义符。
#+begin_src R ::results output graphics :file fig_1.png :exports both
  str_trim("  String with trailing and leading white space\t")
  ## [1] "String with trailing and leading white space"
  str_trim("\n\nString with trailing and leading white space\n\n")  
#+end_src
*** str_start
Detect the presence or absence of a pattern at the beginning or end of a string.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      fruit <- c("apple", "banana", "pear", "pinapple")
      str_starts(fruit, "p")
      str_starts(fruit, "p",negate = T)      
      
    #+end_src
*** str_end
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      fruit <- c("apple", "banana", "pear", "pinapple")
      str_ends(fruit, "e")
      ## [1]  TRUE FALSE FALSE  TRUE
      str_ends(fruit, "e",negate = TRUE)
    #+end_src
*** str_glue
Format and interpolate a string with glue。These functions are wrappers around
glue::glue() and glue::glue_data(), which provide a powerful and elegant syntax
for interpolating strings. These wrappers provide a small set of the full
options. Use the functions directly from glue for more control.

str_glue(..., .sep = "", .envir = parent.frame())
str_glue_data(.x, ..., .sep = "", .envir = parent.frame(),
  .na = "NA")

    #+begin_src R :results output graphics :file fig_1.png :exports both 
      name <- "Fred"
      age <- 50
      anniversary <- as.Date("1991-10-12")
      str_glue(
          "My name is {name}, ",
          "my age next year is {age + 1}, ",
          "and my anniversary is {format(anniversary, '%A, %B %d, %Y')}."
      )
                                        # single braces can be inserted by doubling them
      str_glue("My name is {name}, not {{name}}.")      
    #+end_src
*** str_glue_data

    #+begin_src R :results output graphics :file fig_1.png :exports both 
      mtcars %>% str_glue_data("{rownames(.)} has {hp} hp")      
    #+end_src

*** str_squish
 str_squish() also reduces repeated whitespace inside a string.
     #+begin_export html
     str_squish("\n\nString with excess,  trailing and leading white   space\n\n")
# [1] "String with excess, trailing and leading white space"
     #+end_export
*** word
Extract words from a sentence.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      sentences <- c("Jane saw a cat", "Jane sat down")
      word(sentences, 1)
      ## [1] "Jane" "Jane"
      word(sentences,2)
      ## [1] "saw" "sat"
      str <- 'abc.def..123.4568.999'
      word(str, 1, sep = fixed('..'))
      ## [1] "abc.def"
      word(str, 2, sep = fixed('..'))
      ## [1] "123.4568.999"
    #+end_src
*** invert_match
Invert a matrix of match locations to match the opposite of what was previously matched.
     #+begin_src R ::results output graphics :file fig_1.png :exports both
       numbers <- "1 and 2 and 4 and 456"
       num_loc <- str_locate_all(numbers, "[0-9]+")[[1]]
       str_sub(numbers, num_loc[, "start"], num_loc[, "end"])

       text_loc <- invert_match(num_loc)
       str_sub(numbers, text_loc[, "start"], text_loc[, "end"])
     #+end_src
** stringi
这个包含有更多地处理 string 格式的数据。
*** stri_extract_all_words
 #+begin_src R :results output graphics :file fig_1.png :exports both 
   stri_extract_all_words("Lorem ipsum dolor sit amet")
                                        #> [[1]]
                                        #> [1] "Lorem" "ipsum" "dolor" "sit"   "amet"
 #+end_src
*** stri_flatten
Flatten a String.




** rlang
*** vocabulary
**** symbol
Is object a symbol?
a name that represents a value or object stored in R.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       is_symbol(expr(pi))
                                        #> [1] TRUE       
     #+end_src
**** environment

我以前一直不知道环境的重要性！直到遇到了以下的情况！！

#+begin_src R ::results output graphics :file fig_1.png :exports both
  group_func <- function(.data, var) {
      list(.data %>%
           group_by(var), current = rlang::current_env(), caller = rlang::caller_env())
  }
  group_func(mtcars, var = mpg)
                                        #> Error: Column `var` is unknown  
#+end_src

从这个例子可以看出，在 group_func 函数环境中，没有 var 这个变量，所以无法识别 var,所以需要借助 rlang::enquo.

#+begin_src R ::results output graphics :file fig_1.png :exports both
 group_func <- function(.data, var) {
  var <- enquo(var)
  list(.data %>%
    group_by({
      {
        var
      }
    }), current = rlang::current_env(), caller = rlang::caller_env())
}
group_func(mtcars, mpg) %>% head()
#> [[1]]
#> # A tibble: 32 x 11
#> # Groups:   mpg [25]
#>      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
#>  * <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
#>  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
#>  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
#>  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
#>  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
#>  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
#>  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
#>  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
#>  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
#>  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
#> 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
#> # ... with 22 more rows
#> 
#> $current
#> <environment: 0x00000000131c80d8>
#> 
#> $caller
#> <environment: R_GlobalEnv> 
#+end_src


a list-like object that binds symbols (names) to objects stored in memory. Each env contains a link to a second, parent env, which creates a chain, or search path, of environments. is_environment(current_env()).
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       caller_env(n=1)
                                        #> <environment: 0x7fdf57145ce0>
       env <- env(a = 1, b = "foo")
       env$b
                                        #> [1] "foo"
       identical(env_parent(env), current_env())
                                        #> [1] TRUE

       env <- env(base_env(), a = 1, b = "foo")
       identical(env_parent(env), base_env())
                                        #> [1] TRUE

                                        # child_env() lets you specify a parent:
       child <- child_env(env, c = "bar")
       identical(env_parent(child), env)
                                        #> [1] TRUE

                                        # This child environment owns `c` but inherits `a` and `b` from `env`:
       env_has(child, c("a", "b", "c", "d"))
                                        #>     a     b     c     d 
                                        #> FALSE FALSE  TRUE FALSE
       env_has(child, c("a", "b", "c", "d"), inherit = TRUE)
                                        #>     a     b     c     d 
                                        #>  TRUE  TRUE  TRUE FALSE
       fn <- function() list(current = current_env(), caller = caller_env())
                                        # The current environment is an unique execution environment
                                        # created when `fn()` was called. The caller environment is the
                                        # global env because that's where we called `fn()`.
       fn()
                                        #> $current
                                        #> <environment: 0x7fa17bda3800>
                                        #> 
                                        #> $caller
                                        #> <environment: R_GlobalEnv>
     #+end_src
**** constant
a bare value (i.e. an atomic vector of length 1)
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       is_bare_atomic(1)
                                        #> [1] TRUE       
     #+end_src
**** call object
a vector of symbols/constants/calls that begins with a function name, possibly followed by arguments.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       is_call(expr(abs(1)))
                                        #> [1] TRUE
     #+end_src
**** code
a sequence of symbols/constants/calls that will return a result if evaluated.
Code can be:

1.evaluated immediately (standard eval)
2.quoted to use later (non-standard eval)

     #+begin_src R :results output graphics :file fig_1.png :exports both 
       is_expression(expr(pi))
                                        #> [1] TRUE       
     #+end_src
**** expression
an object that stores quoted code without evaluating it. 
#+begin_src R :results output graphics :file fig_1.png :exports both 
  is_expression(expr(a + b))
                                        #> [1] TRUE 
#+end_src
**** quosure
an object that stores both quoted code (without evaluating it) and the code's environment. is_quosure(quo(a + b)).

rlang::quo_get_env(quo) Return the environment of a quosure.
rlang::quo_set_env(quo, expr) Set the environment of a quosure.
rlang::quo_get_expr(quo) Return the expression of a quosure.

     #+begin_src R :results output graphics :file fig_1.png :exports both 
       quo <- quo(my_quosure)
       quo
                                        #> <quosure>
                                        #> expr: ^my_quosure
                                        #> env:  global
       quo_get_expr(quo)
                                        #> my_quosure
       quo_get_env(quo)
                                        #> <environment: R_GlobalEnv>
       quo <- quo_set_env(quo, empty_env())
       quo
       ## <quosure>
            ## expr: ^my_quosure
       ## env:  empty
     #+end_src

expression vector: a list of pieces of quoted code created by base R's expression and parse functions. Not to be confused with expression.
*** quoting code
**** quosures
 Quote code in one of two ways (if in doubt use a quosure):

 Quosure- An expression that has been saved with an environment (aka a closure).A quosure can be evaluated later in the stored environment to return a predictable result.

 rlang::quo(expr) Quote contents as a quosure. Also quos to quote multiple expressions. a <- 1; b <- 2; q <- quo(a + b); qs <- quos(a, b)

化解符 defusing operator expr() 和 enquo() 能够阻止 R code evaluation. When a function argument is defused, R doesn't return its value like it normally would but it returns the R expression describing how to make the value.

Defusing prevents the evaluation of R code, but you can still force evaluation inside a defused expression with the forcing operators !! and !!!.化解符虽然能够阻止 R code 的解析，但是!! 能够强制解析。

 #+begin_src R :results output graphics :file fig_1.png :exports both 
   a <- 1
   b <- 2
   q <- quo(a+b)
   q
                                         #> <quosure>
                                         #> expr: ^a + b
                                         #> env:  global
   qs <- quos(a,b)
   qs
                                         #> <list_of<quosure>>
                                         #> 
                                         #> [[1]]
                                         #> <quosure>
                                         #> expr: ^a
                                         #> env:  global
                                         #> 
                                         #> [[2]]
                                         #> <quosure>
                                         #> expr: ^b
                                         #> env:  global  
 #+end_src

 rlang::enquo(arg) Call from within a function to quote what the user passed to an argument as a quosure. Also enquos for multiple args. quote_this < - function(x) enquo(x) quote_these < - function(…) enquos(…)

 #+begin_src R :results output graphics :file fig_1.png :exports both 
   group_mean <- function(data,group_var,mean_var,varnames){
       group_var_e <- enquo(group_var)
       mean_var_e <- enquo(mean_var)
       data %>%
           group_by(!!group_var_e) %>%

     summarise(!!varnames :=mean(!!mean_var_e))
   }
   group_mean(data=mtcars,
              group_var=cyl,
              mean_var=mpg,
              varnames="mpg")
 #+end_src
 rlang::new_quosure(expr, env = caller_env()) Build a quosure from a quoted expression and an environment. new_quosure(expr(a + b), current_env()).

 #+begin_src R :results output graphics :file fig_1.png :exports both 
   new_quosure(expr(a+b),current_env())
                                         #> <quosure>
                                         #> expr: ^a + b
                                         #> env:  global  
 #+end_src

真是谁用谁知道哈！

 #+begin_src R ::results output graphics :file fig_1.png :exports both
   df1 <- enframe(1:3) %>% 
       add_column(id=c("1","1","2"))
   df1
                                        #> # A tibble: 3 x 3
                                        #>    name value id   
                                        #>   <int> <int> <chr>
                                        #> 1     1     1 1    
                                        #> 2     2     2 1    
                                        #> 3     3     3 2
   filter_fun <- function(.data,var,id1){
       var <- enquo(var)
       id1 <- enquo(id1)
       .data %>% filter(!!var==!!id1)
   }
   filter_fun(df1, id, "2")
                                        #> # A tibble: 1 x 3
                                        #>    name value id   
                                        #>   <int> <int> <chr>
                                        #> 1     3     3 2
 #+end_src

**** expression

Quoted Expression - An expression that has been saved by itself.A quoted expression can be evaluated later to return a result that will depend on the environment it is evaluated in.

rlang::expr(expr) Quote contents. Also exprs to quote multiple expressions. a <- 1; b <- 2; e <- expr(a + b); es <- exprs(a, b, a + b)

rlang::enexpr(arg) Call from within a function to quote what the user passed to
an argument. Also enexprs to quote multiple arguments. quote_that < -
function(x) enexpr(x) quote_those < - function(…) enexprs(…)

rlang::ensym(x) Call from within a function to quote what the user passed to an argument as a symbol, accepts strings. Also ensyms. quote_name < - function(name) ensym(name) quote_names < - function(…) ensyms(…).

 #+begin_src R :results output graphics :file fig_1.png :exports both 
   a <- 1
   b <- 2
   (e <- expr(a+b))
                                        #> a + b
   (es <- exprs(a,b,a+b))
                                        #> [[1]]
                                        #> a
                                        #> 
                                        #> [[2]]
                                        #> b
                                        #> 
                                        #> [[3]]
                                        #> a + b
 #+end_src

*** parsing and deparsing
parse:convert a string to a saved expression.rlang::parse_expr(x) Convert a string to an expression. Also parse_exprs, sym, parse_quo, parse_quos.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      parse_expr("a+b")
                                        #> a + b
    #+end_src

Deparse - Convert a saved expression to a string.
rlang::expr_text(expr, width = 60L, nlines = Inf) Convert expr to a string. Also quo_name. expr_text(e).
#+begin_src R :results output graphics :file fig_1.png :exports both 
  expr_label(10)
                                        #> [1] "10" 
#+end_src
*** building calls
rlang::call2(.fn, ..., .ns = NULL) Create a call from a function and a list of args. Use exec to create and then evaluate the call. (See back page for !!!) args <- list(x = 4, base = 2).

#+begin_src R :results output graphics :file fig_1.png :exports both 
  args <- list(x=4,base=2)
  call2("log",x=4,base=2)
                                        #> log(x = 4, base = 2)
  call2("log",!!!args)
                                        #> log(x = 4, base = 2)
  exec("log",x=4,base=2)
                                        #> [1] 2
  exec("log",!!!args)
                                        #> [1] 2  
#+end_src
*** evaluation
To evaluate an expression,R:

1.Looks up the symbols in the expression in the active environment (or a supplied one), followed by the environment's parents.
2.Executes the calls in the expression.
The result of an expression depends on which environment it is evaluated in.
**** quoted expression
rlang::eval_bare(expr, env = parent.frame()) Evaluate expr in env. eval_bare(e, env =.GlobalEnv).
#+begin_src R :results output graphics :file fig_1.png :exports both 
  e <- parse_expr("a+b")
  parse_expr("mean(mtcars$wt)") %>% eval_tidy()
  parse_exprs("mean(mtcars$wt); mean(mtcars$am)") %>% eval_tidy()
  parse_expr("mean(mtcars$wt)") %>% eval_bare() #如果不涉即新的数据，就可以使用eval_bare,如果需要用到数据，那么就需要用eval_tidy 进行求值
  parse_expr("mean(wt)") %>% eval_tidy(data=mtcars)
  parse_expr("mean(wt)") %>% eval_bare() #Error in mean(wt) : 找不到对象'wt'
  parse_expr("mean(wt)") %>% 
      eval_tidy(data = mtcars)
  parse_expr("mean(mtcars$wt)") %>% 
      eval_bare()
#+end_src
**** quosures
rlang::eval_tidy(expr, data = NULL, env = caller_env()) Evaluate expr in env,
using data as a data mask. Will evaluate quosures in their stored environment.
eval_tidy(q).

Data Mask - If data is non-NULL, eval_tidy inserts data into the search path before env, matching symbols to names in data.Use the pronoun .data$ to force a symbol to be matched in data, and !! (see back) to force a symbol to be matched in the environments.
#+begin_src R :results output graphics :file fig_1.png :exports both 
  parse_expr("mean(wt)") %>% 
      eval_tidy(data = mtcars)
  parse_expr("mean(mtcars$wt)") %>% 
      eval_bare()
#+end_src
*** quasiquotation(!!,!!!,:=)
rlang provides !!, !!!, and := for doing quasiquotation.

!!, !!!, and := are not functions but syntax (symbols recognized by the
functions they are passed to). Compare this to how

. is used by magrittr::%>%() . is used by stats::lm() .x is used by purrr::map(), and so on.

!!, !!!, and := are only recognized by some rlang functions and functions that use those functions (such as tidyverse functions).

!!Unquotes the symbol or call that follows. Pronounced "unquote" or "bang-
bang." a <- 1; b <- 2 expr(log(!!a + b)).

Combine !! with () to unquote a longer expression. a <- 1; b <- 2 expr(log(!!(a + b))).

!!!Unquotes a vector or list and splices the results as arguments into the
surrounding call. Pronounced "unquote splice" or "bang-bang-bang." x <- list(8,
b = 2) expr(log(!!!x)).也就是说:= 等于＝。

:= Replaces an = to allow unquoting within the name that appears on the left hand side of the =. Use with !!

**** quotation
Storing an expression without evaluate it.
#+begin_src R :results output graphics :file fig_1.png :exports both 
  (e <- expr(a+b))
                                        #> a + b  
#+end_src
**** quasiquotation
Quoting some parts of an expression while evaluating and then inserting the
results of others (unquoting others).
来个实际例子来说明!!!的魅力！
#+begin_src R :results output graphics :file fig_1.png :exports both 
  n <- expr(uno)
  tibble::tibble(!!n:=1)
                                        #> # A tibble: 1 x 1
                                        #>     uno
                                        #>   <dbl>
                                        #> 1     1
  name <- "Jane"
  list2(!!name := 1 + 2)
                                        #> $Jane
                                        #> [1] 3
  exprs(!!name := 1 + 2)
                                        #> $Jane
                                        #> 1 + 2
  library(rlang)
  library(tidyverse)
  e2 <- "vs + am ; am +vs"
  mtcars %>%
      mutate(!!!parse_exprs(e2)) %>%
      head()
                                        #>    mpg cyl disp  hp drat    wt  qsec vs am gear carb vs + am am + vs
                                        #> 1 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4       1       1
                                        #> 2 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4       1       1
                                        #> 3 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1       2       2
                                        #> 4 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1       1       1
                                        #> 5 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2       0       0
                                        #> 6 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1       1       1
#+end_src
*** programming recipes

Quoting function- A function that quotes any of its arguments internally for delayed evaluation in a chosen environment. You must take special steps to program safely with a quoting function.

- PROGRAM WITH A QUOTING FUNCTION

#+begin_src R :results output graphics :file fig_1.png :exports both 
  data_mean <- function(data,var){
      require(dplyr)
      var <- rlang::enquo(var)
      data %>% 
          summarise(mean=mean(!!var))
  } 
#+end_src

1. Capture user argument that will be quoted with rlang::enquo.
2. Unquote the user argument into the quoting function with !!.

- PASS MULTIPLE ARGUMENTS TO A QUOTING FUNCTION

#+begin_src R :results output graphics :file fig_1.png :exports both 
  group_mean <- function(data, var,group_vars) { 
      require(dplyr) 
      var <- rlang::enquo(var) 
      group_vars <- rlang::enquos(group_vars) 
      data %>% 
          group_by(!!!group_vars) %>% 
          summarise(mean = mean(!!var)) 
  }  
#+end_src

1. Capture user arguments that will be quoted with rlang::enquos.
2. Unquote splice the user arguments into the quoting function with !!!.

- PASS TO ARGUMENT NAMES OF A QUOTING FUNCTION

#+begin_src R :results output graphics :file fig_1.png :exports both 
  named_m <- function(data, var, name) {
      require(dplyr)
      var <- rlang::enquo(var)
      name <- rlang::ensym(name)
      data %>% summarise(!!name := mean(!!var)) }  
#+end_src

1. Capture user argument that will be quoted with rlang::ensym.
2. Unquote the name into the quoting function with !! and :=.

- MODIFY USER ARGUMENTS

#+begin_src R :results output graphics :file fig_1.png :exports both 
  my_do <- function(f, v, df) {
      f <- rlang::enquo(f)              #1
      v <- rlang::enquo(v)
      todo <- rlang::quo((!!f)(!!v))    #2
      rlang::eval_tidy(todo, df)        #3
  }  
#+end_src

1. Capture user arguments with rlang::enquo.
2. Unquote user arguments into a new expression or quosure to use
3. Evaluate the new expression/ quosure instead of the original argument

- APPLY AN ARGUMENT TO A DATA FRAME

#+begin_src R :results output graphics :file fig_1.png :exports both 
  subset2 <- function(df, rows){
      rows <- rlang::enquo(rows) #1
      vals <- rlang::eval_tidy(rows, data = df)
      df[vals, , drop = FALSE] #2
  }
#+end_src

1. Capture user argument with rlang::enquo.
2. Evaluate the argument with rlang::eval_tidy. Pass the data frame to data to use as a data mask.
3. Suggest in your documentation that your users use the .data and .env pronouns.

- PASS CRAN CHECK

#+begin_src R :results output graphics :file fig_1.png :exports both 
  #' @importFrom rlang .data
  mutate_y <- function(df) { dplyr::mutate(df, y = .data$a +1) }  
#+end_src
Quoted arguments in tidyverse functions can trigger an R CMD check NOTE about
undefined global variables. To avoid this:

1. Import rlang::.data to your package, perhaps with the roxygen2 tag
   @importFrom rlang .data

2. Use the .data$ pronoun in front of variable names in tidyverse functions.
*** functions
**** sym
A symbol is much more than a string, it is a reference to an R object. That’s why you have to use symbols to refer to data frame columns. Fortunately transforming strings to symbols is straightforward with the tidy eval sym() function:

说白了，sym 的处理对象就是 string 型，将 string 型的对象处理成标志 symbol,这样数据可以用来选择。

     #+begin_src R :results output graphics :file fig_1.png :exports both 
       sym("height")
                                        #> height  
     #+end_src

     #+begin_src R :results output graphics :file fig_1.png :exports both 
       grouped_mean <- function(data, group_var, summary_var) {
           group_var <- enquo(group_var)
           summary_var <- enquo(summary_var)

           data %>%
               group_by(!!group_var) %>%
               summarise(mean = mean(!!summary_var))
       }
       grouped_mean(mtcars, cyl, mpg)
                                        #> Error in eval(lhs, parent, parent): object 'mtcars' not found       
     #+end_src
     
再举一个例子说明 sym 的应用。
#+begin_src R ::results output graphics :file fig_1.png :exports both
  vars <- syms(c("height", "mass"))
                                        # Force-splicing is equivalent to supplying the elements separately
  starwars %>% select(!!!vars)
                                        #> # A tibble: 87 x 2
                                        #>    height  mass
                                        #>     <int> <dbl>
                                        #>  1    172    77
                                        #>  2    167    75
                                        #>  3     96    32
                                        #>  4    202   136
                                        #>  5    150    49
                                        #>  6    178   120
                                        #>  7    165    75
                                        #>  8     97    32
                                        #>  9    183    84
                                        #> 10    182    77
                                        #> # ... with 77 more rows
#+end_src

从上面的例子可以看出，syms 返回的是 list 型数据，而针对 list 型数据需要用!!! 来解析。
**** {{.}} (curly-curly operator) 
The curly-curly operator {{ }} for function arguments is a bit special because it forces the function argument and immediately defuses it.
#+begin_src R ::results output graphics :file fig_1.png :exports both
  mean_by <- function(data, by, var) {
      data %>%
          group_by({
              {
                  by
              }
          }) %>%
          summarise(avg = mean({
              {
                  var
              }
          }, na.rm = TRUE))
  }
                                        # The env-variables `by` and `var` are forced but defused.
                                        # The data-variables they contain are evaluated by dplyr later on
  # in data context.
  iris %>% mean_by(by = Species, var = Sepal.Width)
                                        #> # A tibble: 3 x 2
                                        #>   Species      avg
                                        #>   <fct>      <dbl>
                                        #> 1 setosa      3.43
                                        #> 2 versicolor  2.77
                                        #> 3 virginica   2.97  
#+end_src



**** ... argument
The dot-dot-dot argument is one of the nicest aspects of the R language. A function that takes ... accepts any number of arguments, named or unnamed. As a programmer you can do three things with ...:
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       materialise <- function(data, ...) {
           dots <- list(...)
           dots
       }
       materialise(mtcars, 1 + 2, important_name = letters)
                                        #> [[1]]
                                        #> [1] 3
                                        #> 
                                        #> $important_name
                                        #>  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q"
                                        #> [18] "r" "s" "t" "u" "v" "w" "x" "y" "z"       
     #+end_src
**** expr,exprs,enquo

- The defusing operator expr() is similar to quote(). Like bquote(), it allows forcing evaluation of parts of an expression.

- The plural variant exprs() is similar to alist().

- The argument-defusing operator enquo() is similar to substitute().
**** %|%
replace missing values。

#+begin_src R :results output graphics :file fig_1.png :exports both 
  c("a", "b", NA, "c") %|% "default"
                                        #> [1] "a"       "b"       "default" "c"
  c(1L, NA, 3L, NA, NA) %|% (6L:10L)
                                        #> [1]  1  7  3  9 10
#+end_src
**** exec
This function constructs and evaluates a call to .fn. It has two primary uses:

To call a function with arguments stored in a list (if the function doesn't support tidy-dots)

To call every function stored in a list (in conjunction with map()/ lapply())
     #+begin_src R ::results output graphics :file fig_1.png :exports both
       args <- list(x = c(1:10, 100, NA), na.rm = TRUE)
       exec("mean", !!!args, trim = 0.2)
                                        #> [1] 6
 
     #+end_src
**** pairlist2
Create pairlists with splicing support.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       new_function(pairlist2(x = , y = 3 * 6), quote(x * y))
                                        #> function (x, y = 18) 
                                        #> x * y
       new_function(exprs(x = 1, y = 3 * 6), quote(x * y))
                                        #> function (x = 1, y = 3 * 6) 
                                        #> x * y       
     #+end_src
**** f_rhs
Get or set formula components.
f_rhs extracts the righthand side, f_lhs extracts the lefthand side, and f_env extracts the environment. All functions throw an error if f is not a formula.
#+begin_src R ::results output graphics :file fig_1.png :exports both
  f_rhs(~ 1 + 2 + 3)
                                        #> 1 + 2 + 3
#+end_src
**** f_lhs
     #+begin_src R ::results output graphics :file fig_1.png :exports both
       f_lhs(~y)
                                        #> NULL
       f_lhs(x ~ y)
                                        #> x
     #+end_src

**** fn_body
Get or set function body.
     #+begin_src R ::results output graphics :file fig_1.png :exports both
       fn <- function() do()
       body(fn)
                                        #> do()
       fn_body(fn)
                                        #> {
                                        #>     do()
                                        #> }       
     #+end_src

**** fn_env

Return the closure environment of a function.

#+begin_src R ::results output graphics :file fig_1.png :exports both
  fn <- function() do()
  fn_env(fn)
                                        #> <environment: R_GlobalEnv>  
#+end_src


**** f_text

     #+begin_src R ::results output graphics :file fig_1.png :exports both
       f <- ~ a + b + bc
       f_text(f)
                                        #> [1] "a + b + bc"
       f_label(f)
                                        #> [1] "`a + b + bc`"

                                        # Names a quoted with ``
       f_label(~x)
                                        #> [1] "`x`"
                                        # Strings are encoded
       f_label(~"a\nb")
                                        #> [1] "\"a\\nb\""
                                        # Long expressions are collapsed
       f_label(~ foo({
           1 + 2
           print(x)
       }))
                                        #> [1] "`foo(...)`"
     #+end_src

** caret
*** confusionMatrix
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      library(caret)
      two_class_sample1 <- as.factor(sample(letters[1:2], 100, TRUE))
      two_class_sample2 <- as.factor(sample(letters[1:2], 100, TRUE))
      two_class_cm <- caret::confusionMatrix(
                                 two_class_sample1,
                                 two_class_sample2
                             )

      tidy(two_class_cm)
      tidy(two_class_cm, by_class = FALSE)      
    #+end_src
** tibble
*** enframe
enframe() converts named atomic vectors or lists to one- or two-column data frames. For a list, the result will be a nested tibble with a column of type list. For unnamed vectors, the natural sequence is used as name column. 
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      enframe(1:3)
                                        #> # A tibble: 3 x 2
                                        #>    name value
                                        #>   <int> <int>
                                        #> 1     1     1
                                        #> 2     2     2
                                        #> 3     3     3
      enframe(c(a = 5, b = 7))
                                        #> # A tibble: 2 x 2
                                        #>   name  value
                                        #>   <chr> <dbl>
                                        #> 1 a         5
                                        #> 2 b         7
      enframe(list(one = 1, two = 2:3, three = 4:6))
                                        #> # A tibble: 3 x 2
                                        #>   name  value    
                                        #>   <chr> <list>   
                                        #> 1 one   <dbl [1]>
                                        #> 2 two   <int [2]>
                                        #> 3 three <int [3]>
          #+end_src
*** deframe
deframe() converts two-column data frames to a named vector or list, using the first column as name and the second column as value. If the input has only one column, an unnamed vector is returned. 
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      deframe(enframe(1:3))
                                        #> 1 2 3 
                                        #> 1 2 3
      deframe(tibble(a = 1:3))
                                        #> [1] 1 2 3
      deframe(tibble(a = as.list(1:3)))
                                        #> [[1]]
                                        #> [1] 1
                                        #> 
                                        #> [[2]]
                                        #> [1] 2
                                        #> 
                                        #> [[3]]
                                        #> [1] 3
    #+end_src
** parallel
*** mclapply
Parallel Versions of lapply and mapply using Forking.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      mclapply(rep(4, 5), rnorm, mc.preschedule = FALSE,
               mc.set.seed = FALSE)
    #+end_src
*** mcMap
这个函数就是 parallel 版本的 Map.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      # Generate some sample data
      xs <- replicate(5, runif(10), simplify = FALSE)
      xs
      ws <- replicate(5, rpois(10, 5) + 1, simplify = FALSE)
      ws
      mcMap(weighted.mean, xs, ws)
    #+end_src
*** parSapply
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      library(parallel)
      cl <- makeCluster(getOption("cl.cores", 2))
      parSapply(cl, 1:20, get("+"), 3)      
    #+end_src
** tidyselect 
*** vars_select
该函数可以针对特定的字符串进行选择。
 #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
nms <- names(iris)
nms %>% vars_select(starts_with("Petal")) # 戼㹦挼㸹搼㸲搼㸴搼㸳挼㸳挼㸰戼㸴ѡ搼㸴昼㸱搼㸷ַ昼㹢搼㸰挼㹤挼㹡昼㹤戼㹥搼㹤
#>   Petal.Length    Petal.Width 
#> "Petal.Length"  "Petal.Width"
vars_select(nms, ends_with("Width"))
#>   Sepal.Width   Petal.Width 
#> "Sepal.Width" "Petal.Width"
vars_select(nms, contains("etal"))
#>   Petal.Length    Petal.Width 
#> "Petal.Length"  "Petal.Width"
vars_select(nms, matches(".t.")) # 搼㸵攼㸲戼㸸昼㸶match(".t.") 戼㹡搼㹣搼㸳搼㸰搼㸲攼㸲˼愼㸱愼㸳
#>   Sepal.Length    Sepal.Width   Petal.Length    Petal.Width 
#> "Sepal.Length"  "Sepal.Width" "Petal.Length"  "Petal.Width"
vars_select(nms, Petal.Length, Petal.Width)
#>   Petal.Length    Petal.Width 
#> "Petal.Length"  "Petal.Width"
vars_select(nms, everything())
#>   Sepal.Length    Sepal.Width   Petal.Length    Petal.Width        Species 
#> "Sepal.Length"  "Sepal.Width" "Petal.Length"  "Petal.Width"      "Species"
vars_select(nms, last_col())
#>   Species 
#> "Species"
vars_select(nms, last_col(offset = 2))
#>   Petal.Length 
#> "Petal.Length"
vars <- c("Petal.Length", "Petal.Width")
vars_select(nms, one_of(vars))
#>   Petal.Length    Petal.Width 
#> "Petal.Length"  "Petal.Width"
df <- as.data.frame(matrix(runif(100), nrow = 10))
df <- df[c(3, 4, 7, 1, 9, 8, 5, 2, 6, 10)]
select_vars(names(df), num_range("V", 4:6))
#> Warning: select_vars() is deprecated. 
#> Please use tidyselect::vars_select() instead
#> This warning is displayed once per session.
#>   V4   V5   V6 
                                        #> "V4" "V5" "V6"
                                        # `!` negates a selection:
vars_select(nms, !ends_with("Width"))
                                        #>   Sepal.Length   Petal.Length        Species 
                                        #> "Sepal.Length" "Petal.Length"      "Species"
                                        # `&` and `|` take the intersection or the union of two selections:
                                        # `&` and `|` take the intersection or the union of two selections:
vars_select(nms, starts_with("Petal") & ends_with("Width"))
                                        #>   Petal.Width 
                                        #> "Petal.Width"
vars_select(nms, starts_with("Petal") | ends_with("Width"))
                                        #>   Petal.Length    Petal.Width    Sepal.Width 
                                        #> "Petal.Length"  "Petal.Width"  "Sepal.Width"
# `/` takes the difference of two selections
vars_select(nms, starts_with("Petal") / ends_with("Width"))
#>   Petal.Length 
#> "Petal.Length"

# `all_of()` selects the variables in a character vector:
vars <- c("Petal.Length", "Petal.Width")
vars_select(nms, all_of(vars))
#>   Petal.Length    Petal.Width 
#> "Petal.Length"  "Petal.Width"

# Whereas `all_of()` is strict, `any_of()` allows missing
# variables.
try(vars_select(nms, all_of(c("Species", "Genres"))))
#> Error : Can't subset columns that don't exist.
#> x The column `Genres` doesn't exist.
vars_select(nms, any_of(c("Species", "Genres")))
#>   Species 
#> "Species"

# The lax variant is especially useful to make sure a variable is
# selected out:
vars_select(nms, -any_of(c("Species", "Genres")))
#>   Sepal.Length    Sepal.Width   Petal.Length    Petal.Width 
#> "Sepal.Length"  "Sepal.Width" "Petal.Length"  "Petal.Width"

# The order of selected columns is determined from the inputs
vars_select(names(mtcars), starts_with("c"), starts_with("d"))
#>    cyl   carb   disp   drat 
#>  "cyl" "carb" "disp" "drat"
vars_select(names(mtcars), one_of(c("carb", "mpg")))
#>   carb    mpg 
#> "carb"  "mpg"  
#+END_SRC

*** vars_pull
vars_pull 可以摘取固定位置上的字符。
 #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
   # You can unquote variables:
   var <- 10
   vars_pull(letters, !! var)
   vars_pull(letters, c)
 #+END_SRC

*** eval_select
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      select_var <- function(.data,var){
          expr <- rlang::enquo(var)
          pos <- tidyselect::eval_select(expr,data = .data)
          rlang::set_names(.data[pos],names(pos))
      }

      mtcars %>% select_var(c(mpg,cyl))
      
    #+end_src

*** vars_rename

  #+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
  # Rename variables preserving all existing
  vars_rename(names(iris), petal_length = Petal.Length)
  #+END_SRC
    
*** poker_vars/peek_vars 
peek_vars() returns the variables currently registered.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      poke_vars(letters)
      peek_vars()
    #+end_src

*** eval_rename
eval_select() and eval_rename() evaluate defused R code (i.e. quoted expressions) according to the special rules of the tidyselect syntax. They power functions like dplyr::select(), dplyr::rename(), or tidyr::pivot_longer().
    #+begin_src R ::results output graphics :file fig_1.png :exports both
      
    #+end_src
** forcats
*** as_factor
    相比较 baseR,as_factor 能够保留原始 string 的字符水平。
需要注意的是，character,factor,numeric 都可以转化为 factor 型。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- c("a","z","g")
      as_factor(x)
      ## [1] a z g
      ## Levels: a z g
      as.factor(x)
      ## [1] a z g
      ## Levels: a g z
      y <- c("1.1", "11", "2.2", "22")
      as_factor(y)
      ## [1] 1.1 11  2.2 22 
      ## Levels: 1.1 11 2.2 22
      as.factor(y)      
      ## [1] 1.1 11  2.2 22 
      ## Levels: 1.1 11 2.2 22
    #+end_src
*** fct_anon
Anonymise factor levels.Replaces factor levels with arbitary numeric identifiers. Neither the values nor the order of the levels are preserved.
#+begin_src R :results output graphics :file fig_1.png :exports both 
  gss_cat$relig %>% fct_count()
                                        # A tibble: 16 x 2
  ## f                           n
  ## <fct>                   <int>
  ## 1 No answer                  93
  ## 2 Don't know                 15
  gss_cat$relig %>% fct_anon() %>% fct_count()
                                        # A tibble: 16 x 2
  ## f         n
  ## <fct> <int>
             ## 1 01      224
  ## 2 02      109
  ## 3 03      689
#+end_src
*** fct_c
Concatenate factors, combining levels,This is a useful way of patching together factors from multiple sources that really should have the same levels but don't.
#+begin_src R :results output graphics :file fig_1.png :exports both 
  fa <- factor("a")
  fb <- factor("b")
  fab <- factor(c("a", "b"))
  c(fa, fb, fab) %>% str
  ## int [1:4] 1 1 1 2
  fct_c(fa, fb, fab) %>% str
  ## Factor w/ 2 levels "a","b": 1 2 1 2
#+end_src
*** fct_collapse
如果想要合并多个水平，那么可以使用 fct_recode() 函数的变体 fct_collapse() 函数。
对于每个新水平，你都可以提供一个包含原水平的向量。
Collapse factor levels into manually defined groups.Collapse factor levels into manually defined groups
#+begin_src R :results output graphics :file fig_1.png :exports both 
  partyid2 <- fct_collapse(gss_cat$partyid,
                           missing = c("No answer", "Don't know"),
                           other = "Other party",
                           rep = c("Strong republican", "Not str republican"),
                           ind = c("Ind,near rep", "Independent", "Ind,near dem"),
                           dem = c("Not str democrat", "Strong democrat")
                           )
  fct_count(partyid2)
  fct_count(gss_cat$partyid)  
#+end_src
*** fct_count
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      f <- factor(sample(letters)[rpois(1000, 10)])
      table(f)
      fct_count(f)
                                        # A tibble: 20 x 2
      ## f         n
      ## <fct> <int>
      ##            1 a         4
      ## 2 c        83
      ## 3 d        99
      ## 4 e         8
      fct_count(f, sort = TRUE)
                                        # A tibble: 20 x 2
      ## f         n
      ## <fct> <int>
      ## 1 u       129
      ## 2 m       122
      fct_count(f, sort = TRUE, prop = TRUE)
                                        # A tibble: 20 x 3
      ## f         n     p
      ## <fct> <int> <dbl>
                       ## 1 u       129 0.129
      ## 2 m       122 0.122
    #+end_src
*** fct_cross
fct_cross(.f, ..., sep = ":", keep_empty = FALSE)
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      fruit <- factor(c("apple", "kiwi", "apple", "apple"))
      colour <- factor(c("green", "green", "red", "green"))
      eaten <- c("yes", "no", "yes", "no")
      fct_cross(fruit, colour)  
      ## [1] apple:green kiwi:green  apple:red   apple:green
      ## Levels: apple:green apple:red kiwi:green
      fct_cross(fruit, colour, keep_empty = TRUE)
      ## [1] apple:green kiwi:green  apple:red   apple:green
      ## Levels: apple:green kiwi:green apple:red kiwi:red
    #+end_src
*** fct_expand
Add additional levels to a factor。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      f <- factor(sample(letters[1:3], 20, replace = TRUE))
      f
      ## [1] b b a c b b a a a b a a b a c a c a a c
      ## Levels: a b c
      fct_expand(f, "d", "e", "f")
      ## [1] b b a c b b a a a b a a b a c a c a a c
      ## Levels: a b c d e f
    #+end_src
*** fct_explicit_na
Make missing values explicit. 
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      f1 <- factor(c("a", "a", NA, NA, "a", "b", NA, "c", "a", "c", "b"))
      table(f1)
      ## f1
      ## a b c 
      ## 4 2 2 
      table(f1,useNA = "ifany")
      ## f1
      ## a    b    c <NA> 
                    ## 4    2    2    3 
      f2 <- fct_explicit_na(f1)
      table(f2)
      ## f2
      ## a         b         c (Missing) 
      ## 4         2         2         3 
    #+end_src
*** fct_inorder/fct_infreq/fct_inseq
Reorder factors levels by first appearance, frequency, or numeric order.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      f <- factor(c("b", "b", "a", "c", "c", "c"))
      f
      fct_inorder(f)
      ## [1] b b a c c c
      ## Levels: b a c
      fct_infreq(f)
      ## [1] b b a c c c
      ## Levels: c b a
      f <- factor(sample(1:10))
      fct_inseq(f)      
      ## [1] 8  9  6  5  1  2  10 7  4  3 
      ## Levels: 1 2 3 4 5 6 7 8 9 10
    #+end_src
*** fct_lump
fct_lump(f, n, prop, w = NULL, other_level = "Other",
  ties.method = c("min", "average", "first", "last", "random", "max")).

Arguments
f	
A factor (or character vector).

n, prop	
If both n and prop are missing, fct_lump lumps together the least frequent levels into "other", while ensuring that "other" is still the smallest level. It's particularly useful in conjunction with fct_inorder().

Positive n preserves the most common n values. Negative n preserves the least common -n values. It there are ties, you will get at least abs(n) values.

Positive prop preserves values that appear at least prop of the time. Negative prop preserves values that appear at most -prop of the time.

w	
An optional numeric vector giving weights for frequency of each value (not level) in f.

other_level	
Value of level used for "other" values. Always placed at end of levels.

ties.method	
A character string specifying how ties are treated. See rank() for details.

min	
Preserves values that appear at least min number of times.

Lump together least/most common factor levels into "other". 这个函数默认的是如果
其他因子 level 相加小于另一个因子水平，那么就 rename="other".

    #+begin_src R :results output graphics :file fig_1.png :exports both 
x <- factor(rep(LETTERS[1:9], times = c(40, 10, 5, 27, 1, 1, 1, 1, 1)))
x %>% table()
## .
## A  B  C  D  E  F  G  H  I 
## 40 10  5 27  1  1  1  1  1 

x %>% fct_lump() %>% table()
## .
## A     D Other 
## 40    27    20 
x %>% fct_lump() %>% fct_inorder() %>% table()
## .
## A Other     D 
## 40    20    27
                                        # Use negative values to collapse the most common
fct_lump(x, n = -3)
fct_lump(x, prop = -0.1)
    #+end_src

    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- factor(letters[rpois(100, 5)])
      x
      fct_lump_min(x, min = 10)      
    #+end_src
*** fct_match
Test for presence of levels in a factor.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      fct_match(gss_cat$marital, c("Married", "Divorced"))
      table(fct_match(gss_cat$marital, c("Married", "Divorced")))
      ## FALSE  TRUE 
      ## 7983 13500 
    #+end_src
*** fct_other
Replace levels with "other".
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- factor(rep(LETTERS[1:6], times = c(2, 2, 1, 2, 1, 1)))
      fct_other(x, keep = c("A", "B"))
      ## [1] A     A     B     B     Other Other Other Other Other
      ## Levels: A B Other
      fct_other(x, drop = c("A", "B"))      
      ## [1] Other Other Other Other C     D     D     E     F    
      ## Levels: C D E F Other
    #+end_src
*** fct_recode
Change factor levels by hand.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- factor(c("apple", "bear", "banana", "dear"))
      fct_recode(x, fruit = "apple", fruit = "banana")
      ## [1] fruit bear  fruit dear 
      ## Levels: fruit bear dear
    #+end_src
*** fct_relabel
Automatically relabel factor levels, collapse as necessary.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      gss_cat$partyid[8]
      ## [1] Ind,near dem
      gss_cat$partyid[8] %>% fct_relabel(~ gsub(",", ", ", .x))
      ## [1] Ind, near dem
    #+end_src
*** fct_relevel 
This is a generalisaton of stats::relevel() that allows you to move any number of levels to any location.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      f <- factor(c("a", "b", "c", "d"), levels = c("b", "c", "d", "a"))
      f
      ## [1] a b c d
      ## Levels: b c d a
      fct_relevel(f)
      fct_relevel(f, "a")
      ## [1] a b c d
      ## Levels: a b c d
      fct_relevel(f, "b", "a")      
      ## [1] a b c d
      ## Levels: b a c d
      # move to the third position
      fct_relevel(f, "a", after = 2)
                                        # Relevel to the end
      fct_relevel(f, "a", after = Inf)
      fct_relevel(f, "a", after = 3)
                                        # Revel with a function
      fct_relevel(f, sort)
      fct_relevel(f, sample)
      fct_relevel(f, rev)
    #+end_src
*** fct_reorder
fct_reorder() is useful for 1d displays where the factor is mapped to position; fct_reorder2() for 2d displays where the factor is mapped to a non-position aesthetic. last2() is a helper for fct_reorder2(); it finds the last value of y when sorted by x.

    #+begin_src R :results output graphics :file fig_1.png :exports both 
      boxplot(Sepal.Width ~ Species, data = iris)
      boxplot(Sepal.Width ~ fct_reorder(Species, Sepal.Width), data = iris)
      boxplot(Sepal.Width ~ fct_reorder(Species, Sepal.Width, .desc = TRUE), data = iris)
    #+end_src
*** fct_rev 
Reverse order of factor levels.This is sometimes useful when plotting a factor.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      f <- factor(c("a", "b", "c"))
      fct_rev(f)
      ## [1] a b c
      ## Levels: c b a
    #+end_src
*** fct_shift
Shift factor levels to left or right, wrapping around at end.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- factor(
          c("Mon", "Tue", "Wed"),
          levels = c("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"),
          ordered = TRUE
      )
      x
      ## [1] Mon Tue Wed
      ## Levels: Sun < Mon < Tue < Wed < Thu < Fri < Sat
      fct_shift(x)
      ## [1] Mon Tue Wed
      ## Levels: Mon < Tue < Wed < Thu < Fri < Sat < Sun
      fct_shift(x, 2)
      ## [1] Mon Tue Wed
      ## Levels: Tue < Wed < Thu < Fri < Sat < Sun < Mon
      fct_shift(x, -1)
      ## [1] Mon Tue Wed
      ## Levels: Sat < Sun < Mon < Tue < Wed < Thu < Fri
    #+end_src
*** fct_shuffle
Randomly permute factor levels.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      f <- factor(c("a", "b", "c"))
      fct_shuffle(f)
      ## [1] a b c
      ## Levels: c b a
      fct_shuffle(f)
      ## [1] a b c
      ## Levels: a c b
    #+end_src
*** fct_unify
Unify the levels in a list of factors.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      fs <- list(factor("a"), factor("b"), factor(c("a", "b")))
      fs
      ## [[1]]
      ## [1] a
      ## Levels: a

      ## [[2]]
      ## [1] b
      ## Levels: b

      ## [[3]]
      ## [1] a b
      ## Levels: a b
      fct_unify(fs)      
      ## [[1]]
      ## [1] a
      ## Levels: a b

      ## [[2]]
      ## [1] b
      ## Levels: a b

      ## [[3]]
      ## [1] a b
      ## Levels: a b
    #+end_src
*** fct_unique 
Unique values of a factor.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      f <- factor(letters[rpois(100, 10)])
      unique(f)     # in order of appearance
      ## [1] h q f n i j m e g k o l d
      ## Levels: d e f g h i j k l m n o q
      fct_unique(f) # in order of levels      
      ## [1] d e f g h i j k l m n o q
      ## Levels: d e f g h i j k l m n o q
    #+end_src
*** lvls
Low-level functions for manipulating levels.lvls_reorder leaves values as they are, but changes the order. lvls_revalue changes the values of existing levels; there must be one new level for each old level. lvls_expand expands the set of levels; the new levels must include the old levels.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      f <- factor(c("a", "b", "c"))
      lvls_reorder(f, 3:1)
      ## [1] a b c
      ## Levels: c b a
      lvls_revalue(f, c("apple", "banana", "carrot"))
      ## [1] apple  banana carrot
      ## Levels: apple banana carrot
      lvls_expand(f, c("a", "b", "c", "d"))      
      ## [1] a b c
      ## Levels: a b c d
    #+end_src
*** lvls_union
Find all levels in a list of factors.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      fs <- list(factor("a"), factor("b"), factor(c("a", "b")))
      fs
      lvls_union(fs)
      ## [1] "a" "b"
    #+end_src
** lubridate
*** 创建日期或时间
有 3 种可以创建日期或时间：
- 通过字符串创建
- 通过日期时间的各个成分创建
- 通过现有的日期时间对象创建
**** 通过字符串创建
这些函数也可以接受不带引号的数值。
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       ymd("2017-01-31")
       ## [1] "2017-01-31"
       ymd(20170131)
       ## [1] "2017-01-31"
       ymd("2017.01.31")
       [1] "2017-01-31"
       mdy("January 31st, 2017") 
       ## [1] "2017-01-31"
       dmy("31-Jan-2017")
       ## [1] "2017-01-31"
     #+end_src

ymd() 和类似的其他函数可以创建日期，要想创建日期时间型数据，可以在后面加一个下划
线，以及 h,m 和 s 之中的一个或多个字母，这样就可以解析日期时间的函数了：

#+begin_src R :results output graphics :file fig_1.png :exports both 
  ymd_hms("2017-01-31 20:11:59")
  ## [1] "2017-01-31 20:11:59 UTC"
  mdy_hm("01/31/2017 08:01")  
  ## [1] "2017-01-31 08:01:00 UTC"
#+end_src

通过添加一个时区参数，你可以将一个日期强制转换为日期时间：

#+begin_src R :results output graphics :file fig_1.png :exports both 
  ymd(20170131,tz = "UTC")
  ## [1] "2017-01-31 UTC"
#+end_src
**** 通过各个成分创建
除了单个字符串，日期时间数据的各个成分还经常分布在表格的多个列中。如果想要按照这
种表示方法来创建日期或时间，可以使用 make_date() 函数创建日期，使用
make_datetime() 函数创建日期时间。

#+begin_src R :results output graphics :file fig_1.png :exports both 
  nycflights13::flights %>% 
      select(year,month,day,hour,minute) %>% 
      str
  ## Classes ‘tbl_df’, ‘tbl’ and 'data.frame':	336776 obs. of  5 variables:
  ##                                                                 $ year  : int  2013 2013 2013 2013 2013 2013 2013 2013 2013 2013 ...
  ## $ month : int  1 1 1 1 1 1 1 1 1 1 ...
  ## $ day   : int  1 1 1 1 1 1 1 1 1 1 ...
  ## $ hour  : num  5 5 5 5 6 5 6 6 6 6 ...
  ## $ minute: num  15 29 40 45 0 58 0 0 0 0 ...
  flights %>% 
      select(year,month,day,hour,minute) %>% 
      mutate(departure=make_datetime(year,month,day,hour,minute)) %>% 
      head()

                                        # A tibble: 6 x 6
  ## year month   day  hour minute departure          
  ## <int> <int> <int> <dbl>  <dbl> <dttm>             
  ##                                     1  2013     1     1     5     15 2013-01-01 05:15:00
  ## 2  2013     1     1     5     29 2013-01-01 05:29:00
  ## 3  2013     1     1     5     40 2013-01-01 05:40:00
#+end_src
**** 通过其他类型数据创建
有时需要在日期时间型数据和日期型数据之间进行转换，这正是 as_datetime() 和
as_date() 函数的功能。
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       as_datetime(today())
       ## [1] "2020-02-06 UTC"
       as_date(now())
       ## [1] "2020-02-06"
       as_datetime(now())
       ## [1] "2020-02-06 08:13:39 UTC"
     #+end_src

有时我们会使用 "Unix 时间戳"(即 1970-01-01) 的偏移量来表示日期时间。如果偏移量单
位是秒，那么就使用 as_datetime() 函数来转换；如果偏移量单位是天，则使用 as_date()
函数来转换：

#+begin_src R :results output graphics :file fig_1.png :exports both 
  as_datetime(60*60*10)
  ## [1] "1970-01-01 10:00:00 UTC"
  as_date(365*10+2)
  ## [1] "1980-01-01"
#+end_src
*** 获取成分
如果想要提取出日期中的独立成分，可以使用以下访问器函数：year(),month(),mday()(一
个月中的第几天),yday()(一年中的第几天),wday()(一周中的第几天),hour(),minute() 和 second():

#+begin_src R :results output graphics :file fig_1.png :exports both 
  datetime <- ymd_hms("2016-07-08 12:34:56")
  year(datetime)
  ## [1] 2016
  month(datetime)
  ## [1] 7
  mday(datetime)
  ## [1] 8
  yday(datetime)
  ## [1] 190
  wday(datetime)  
  ## [1] 6
#+end_src

对于 month() 和 wday() 函数，还可以设置 label=TRUE 来返回月份名称和星期数的缩写，
还可以设置 abbr = FALSE 来返回全名。

#+begin_src R :results output graphics :file fig_1.png :exports both 
  month(datetime,label = T)
  ## [1] Jul
  ## Levels: Jan < Feb < Mar < Apr < May < Jun < Jul < Aug < Sep < Oct < Nov < Dec
  month(datetime,label = T, abbr = F)  
  ## [1] July
  ## 12 Levels: January < February < March < April < May < June < July < ... < December
#+end_src

绘制独立日期成分的另一种方法是，通过 floor_date(),round_date() 和 ceiling_date()
函数将日期舍入到临近的一个时间单位。

#+begin_src R :results output graphics :file fig_1.png :exports both 
  make_datetime_100 <- function(year, month, day, time) {make_datetime(year, month, day, time %/% 100, time %% 100) }
  flights_dt <- flights %>%
      filter(!is.na(dep_time), !is.na(arr_time)) %>%
      mutate(dep_time = make_datetime_100(year, month, day, dep_time), arr_time = make_datetime_100(year, month, day, arr_time), sched_dep_time = make_datetime_100(year, month, day, sched_dep_time), sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)) %>%
      select(origin, dest, ends_with("delay"), ends_with("time"))

  floor_date(flights_dt$dep_time[1],"week")
  ## [1] "2012-12-30 UTC"  
#+end_src
*** 设置成分
可以使用每个访问器函数来设置日期时间中的成分。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      datetime <- ymd_hms("2016-07-08 12:34:56")
      year(datetime) <- 2020
      datetime
                                        #> [1] "2020-07-08 12:34:56 UTC"
      month(datetime) <- 01
      datetime
                                        #> [1] "2020-01-08 12:34:56 UTC"
      hour(datetime) <- hour(datetime)+1
      datetime
                                        #> [1] "2020-01-08 13:34:56 UTC"
    #+end_src

除了原地修改，还可以通过 update() 函数创建一个新日期时间，这样也也可以同时设置多
个成分。

#+begin_src R :results output graphics :file fig_1.png :exports both 
  datetime <- ymd_hms("2016-07-08 12:34:56")
  update(datetime,year=2020,month=2,mday=2,hour=2)
                                        #> [1] "2020-02-02 02:34:56 UTC"  
#+end_src

如果设置的值过大，那么可以自动向后滚动：
#+begin_src R :results output graphics :file fig_1.png :exports both 
  ymd("2015-02-01") %>% 
      update(mday = 30)
                                        #> [1] "2015-03-02"
  ymd("2015-02-01") %>% 
      update(hour=400)
                                        #> [1] "2015-02-17 16:00:00 UTC"  
#+end_src
*** 时间间隔
表示时间差别的对象记录时间间隔的单位可以是秒，分钟，小时，日或周。lubridate 包提
供了总是使用秒为单位的另一种计时对象——时期。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      l_age <- today() - ymd(19880423)
      l_age
                                        #> Time difference of 11611 days
      as.duration(l_age)
                                        #> [1] "1003190400s (~31.79 years)"
      dseconds(15)
                                        #> [1] "15s"
      dminutes(10)
                                        #> [1] "600s (~10 minutes)"
      dhours(c(12,24))
                                        #> [1] "43200s (~12 hours)" "86400s (~1 days)"
      ddays(0:5)
                                        #> [1] "0s"                "86400s (~1 days)"  "172800s (~2 days)"
                                        #> [4] "259200s (~3 days)" "345600s (~4 days)" "432000s (~5 days)"
      dweeks(3)
                                        #> [1] "1814400s (~3 weeks)"
      dyears(1)
                                        #> [1] "31536000s (~52.14 weeks)"
      2*dyears(1)
                                        #> [1] "63072000s (~2 years)"
      dyears(1)+dweeks(12)+dhours(15)
                                        #> [1] "38847600s (~1.23 years)"      
    #+end_src

时期可以和日期型数据相加或相减。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      tomorrow
                                        #> [1] "2020-02-07"
      last_year <- today() - dyears(1)
      last_year
                                        #> [1] "2019-02-06"      
    #+end_src
*** 阶段

时间函数因为夏时制问题，时间之间的算法比较麻烦，需要借助阶段对象。阶段也是一种时
间间隔，但它不以秒为单位，相反，它使用“人工”时间，比如日和月。这使得他们使用起来
更加直观。

#+begin_src R :results output graphics :file fig_1.png :exports both 
  datetime <- ymd_hms("2016-07-08 12:34:56")
  datetime+days(1)
                                        #> [1] "2016-07-09 12:34:56 UTC"
  seconds(15)
                                        #> [1] "15S"
  minutes(10)
                                        #> [1] "10M 0S"
  hours(c(12,24))
                                        #> [1] "12H 0M 0S" "24H 0M 0S"
  days(7)
                                        #> [1] "7d 0H 0M 0S"
  months(1:6)
                                        #> [1] "1m 0d 0H 0M 0S" "2m 0d 0H 0M 0S" "3m 0d 0H 0M 0S" "4m 0d 0H 0M 0S"
                                        #> [5] "5m 0d 0H 0M 0S" "6m 0d 0H 0M 0S"
  weeks(3)
                                        #> [1] "21d 0H 0M 0S"
  years(1)
                                        #> [1] "1y 0m 0d 0H 0M 0S"
  10*(months(6)+days(1))
                                        #> [1] "60m 10d 0H 0M 0S"
  days(50)+hours(25)+minutes(2)
                                        #> [1] "50d 25H 2M 0S"
                                        # 闰年
  ymd("2016-01-01")+dyears(1)
                                        #> [1] "2016-12-31"
  ymd("2016-01-01")+years(1)
                                        #> [1] "2017-01-01"  
#+end_src
*** 区间
显然，dyears(1) / ddays(365) 应该返回 1,因为时期总是以秒来表示的，表示 1 年的时期就
定义为相当于 365 天的秒数。那么 应该返回什么呢？如果年份是 2015 年，那么结果就是 365， 但如

years(1) / days(1) 果年份是 年，那么结果就是 366 ！没有足够的信息让 lubridate 返回一个明确的结果。

2016 lubridate 的做法是给出一个估计值，同时给出一条警告：
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      years(1)/days(1)
                                        #> estimate only: convert to intervals for accuracy
                                        #> [1] 365.25
          #+end_src

如果需要更精确的测量方式，那么你就必须使用区间。区间是带有起点的时期，这使得其非
常精确，你可以确切地知道它的长度：

#+begin_src R :results output graphics :file fig_1.png :exports both 
  next_year <- today() + years(1)
  next_year
                                        #> [1] "2021-02-06"
  (today() %--% next_year) / ddays(1)
                                        #> [1] 366
  (today() %--% next_year) / days(1)
                                        #> [1] 366      
#+end_src
*** 时区
可以使用 Sys.timezone() 函数找出你的当前时区.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      #找出当前时区
      Sys.timezone()
                                        #> [1] "Asia/Shanghai"
                                        #查看完整的时区名称
      length(OlsonNames())
                                        #> [1] 593
      head(OlsonNames())
                                        #> [1] "Africa/Abidjan"     "Africa/Accra"       "Africa/Addis_Ababa"
                                        #> [4] "Africa/Algiers"     "Africa/Asmara"      "Africa/Asmera"
      (x1 <- ymd_hms("2015-06-01 12:00:00", tz = "America/New_York"))
                                        #> [1] "2015-06-01 12:00:00 EDT"
      (x2 <- ymd_hms("2015-06-01 18:00:00", tz = "Europe/Copenhagen"))
                                        #> [1] "2015-06-01 18:00:00 CEST"
      (x3 <- ymd_hms("2015-06-02 04:00:00", tz = "Pacific/Auckland"))
                                        #> [1] "2015-06-02 04:00:00 NZST"
      x1-x2
                                        #> Time difference of 0 secs
      x1-x3
                                        #> Time difference of 0 secs
      (x4 <- c(x1,x2,x3))
                                        #> [1] "2015-06-01 12:00:00 EDT" "2015-06-01 12:00:00 EDT"
                                        #> [3] "2015-06-01 12:00:00 EDT"
      (x4a <- with_tz(x4,tzone = "Australia/Lord_Howe"))
                                        #> [1] "2015-06-02 02:30:00 +1030" "2015-06-02 02:30:00 +1030"
                                        #> [3] "2015-06-02 02:30:00 +1030"
      x4a-x4
                                        #> Time differences in secs
                                        #> [1] 0 0 0      
    #+end_src
*** 其他函数
**** with_tz
Get date-time in a different time zone.with_tz returns a date-time as it would appear in a different time zone. 
#+begin_src R :results output graphics :file fig_1.png :exports both 
  x <- ymd_hms("2009-08-07 00:00:01", tz = "America/New_York")
  with_tz(x, "GMT")
                                        #> [1] "2009-08-07 04:00:01 GMT"  
#+end_src
**** force_tz
Replace time zone to create new date-time.force_tz returns the date-time that has the same clock time as input time, but in the new time zone. force_tzs is the parallel version of force_tz, meaning that every element from time argument is matched with the corresponding time zone in tzones argument.
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       x <- ymd_hms("2009-08-07 00:00:01", tz = "America/New_York")
       with_tz(x,"UTC")
                                        #> [1] "2009-08-07 04:00:01 UTC"
       force_tz(x, "UTC")
                                        #> [1] "2009-08-07 00:00:01 UTC"       
     #+end_src

** sparklyr
*** 复制多行数据

df_tbl %>%
  mutate(arr = explode(array(1, 1, 1))) %>%
  select(-arr)
效果如下：
| ROW1 | ROW2 |
|    1 | A    |
|    1 | A    |
|    1 | A    |
|    2 | B    |
|    2 | B    |
|    2 | B    |
|    3 | C    |
|    3 | C    |
|    3 | C    |
*** TODO 矩阵相乘 

这块还需要进一步研究。

#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
ret = invoke_static(
      sc, "utils.CalWxB", "predictLinear", 
      sdf=sdf_br_onehot_all %>% mutate(Intercept = 1.0) %>% spark_dataframe(), names(br_weights) %>% as.list, br_weights %>% as.list(), "score_lx"
    ) %>% sdf_register()
#+END_SRC

*** 添加日期

- 获取当前时区的 UNIX 时间戳：select unix_timestamp()
- 将指定时间转为 UNIX 时间戳： select unix_timestamp('2012-03-03 11:45:31');
- 将指定的实际转为贵 UNIX 时间戳：select unix_timestamp('2018-08-08 16:22:01','yyyy-MM-dd HH:mm:ss');

#+begin_src R :results output graphics :file fig_1.png :exports both 
  date_add("2016-12-29", 10) # 添加 10 条日期数据

                                        #日期处理
                                        #遇到整型日期数据 20190101 时，可以变成字符型 2019-01-01，然后再用 to_date 处理
  mutate(date=                            to_date(paste(substr(date,1,4),substr(date,5,6),substr(date,7,8),sep="-"),'yyyy-MM-dd'))
#+end_src

** readr 包

这个包功能类似于 data.table 包中的 fread/fwrite。

#+begin_src R :results output graphics :file fig_1.png :exports both 
  
#+end_src

** remedy
该包可用于在 Rmarkdown 中快速建立标题、字体改变等。
```{r}
remedy::remedy_opts$get("hotkeys") # 可以查看快捷键
```
** vctrs
*** vec_c
Combine many vectors into one vector.Combine all arguments into a new vector of common type.

    #+begin_src R :results output graphics :file fig_1.png :exports both 
      vec_c(Sys.Date(), Sys.time())
                                        #> [1] "2020-03-01 00:00:00 CST" "2020-03-01 16:41:02 CST"
      vec_c(FALSE, 1L, "x", .ptype = character())
                                        #> [1] "FALSE" "1"     "x"
      c(factor("a"), factor("b"))
                                        #> [1] 1 1
      vec_c(factor("a"), factor("b"))
                                        #> [1] a b
                                        #> Levels: a b
      vec_c(name = 1:3, .name_spec = "{outer}_{inner}")
                                        #> name_1 name_2 name_3 
                                        #>      1      2      3 
#+end_src
*** vec_bind

    #+begin_src R :results output graphics :file fig_1.png :exports both 
      vec_rbind(
          data.frame(x = 1),
          data.frame(x = FALSE)
      )
                                        #>   x
                                        #> 1 1
                                        #> 2 0
                                        # unique columns are filled with NAs
      vec_rbind(
          data.frame(x = 1),
          data.frame(y = "x")
      )
                                        #>    x    y
                                        #> 1  1 <NA>
                                        #> 2 NA    x

                                        # null inputs are ignored
      vec_rbind(
          data.frame(x = 1),
          NULL,
          data.frame(x = 2)
      )
                                        #>   x
                                        #> 1 1
                                        #> 2 2

      vec_rbind(
          1:2,
          1:3,
          1:4
      )
                                        #>   ...1 ...2 ...3 ...4
                                        #> 1    1    2   NA   NA
                                        #> 2    1    2    3   NA
                                        #> 3    1    2    3    4
      vec_cbind(
          data.frame(x = 1),
          data.frame(y = 1:3)
      )
                                        #>   x y
                                        #> 1 1 1
                                        #> 2 1 2
                                        #> 3 1 3
      
    #+end_src
*** vec_compare
可以方便地比较两个向量，Compare two vectors.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      vec_compare(1:10, 5)
                                        #>  [1] -1 -1 -1 -1  0  1  1  1  1  1
      vec_compare(c(TRUE, FALSE, NA), FALSE)
                                        #> [1]  1  0 NA
      vec_compare(runif(10), 0.5)
                                        #>  [1] -1 -1 -1  1 -1 -1 -1  1  1  1
    #+end_src
*** vec_duplicate_any/vec_duplicate_detect
vec_duplicate_any(): detects the presence of duplicated values, similar to
anyDuplicated().这个函数用于检查是否存在重复值。

vec_duplicate_detect(): returns a logical vector describing if each element of
the vector is duplicated elsewhere. Unlike duplicated(), it reports all
duplicated values, not just the second and subsequent repetitions. 这个函数用于
检查是否存在重复值。

vec_duplicate_id(): returns an integer vector giving the location of the first occurence of the value.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      vec_duplicate_any(1:10)
                                        #> [1] FALSE
      vec_duplicate_any(c(1, 1:10))
                                        #> [1] TRUE
      x <- c(10, 10, 20, 30, 30, 40)
      vec_duplicate_detect(x)
                                        #> [1]  TRUE  TRUE FALSE  TRUE  TRUE FALSE
      vec_duplicate_id(x)
                                        #> [1] 1 1 3 4 4 6
    #+end_src
*** vec_match
Find matching observations across vectors.返回观测值的位置。
vec_in() returns a logical vector based on whether needle is found in haystack. vec_match() returns an integer vector giving location of needle in haystack, or NA if it's not found.

vec_in() is equivalent to %in%; vec_match() is equivalen to match()
#+begin_src R :results output graphics :file fig_1.png :exports both 
  hadley <- strsplit("hadley", "")[[1]]
  vec_match(hadley, letters)
                                        #> [1]  8  1  4 12  5 25  
  vowels <- c("a", "e", "i", "o", "u")
  vec_in(hadley, vowels)
                                        #> [1] FALSE  TRUE FALSE FALSE  TRUE FALSE
  vec_match(c("a", "b"), c("a", "b", "a", "b"))
                                        #> [1] 1 2
#+end_src
*** vec_in
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      vec_in(hadley, vowels)
                                        #> [1] FALSE  TRUE FALSE FALSE  TRUE FALSE
    #+end_src
*** vec_equal
Test if two vectors are equal。
#+begin_src R :results output graphics :file fig_1.png :exports both 
  df <- data.frame(x = c(1, 1, 2, 1, NA), y = c(1, 2, 1, NA, NA))
  vec_equal(df, data.frame(x = 1, y = 2))
                                        #> [1] FALSE  TRUE FALSE    NA    NA
  vec_equal_na(df)
                                        #> [1] FALSE FALSE FALSE FALSE  TRUE  
#+end_src
*** vec_init
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      vec_init(1:10, 3)
                                        #> [1] NA NA NA
      vec_init(mtcars, 2)
                                        #>      mpg cyl disp hp drat wt qsec vs am gear carb
                                        #> ...1  NA  NA   NA NA   NA NA   NA NA NA   NA   NA
                                        #> ...2  NA  NA   NA NA   NA NA   NA NA NA   NA   NA
      vec_init(Sys.Date(), 5)
                                        #> [1] NA NA NA NA NA      
    #+end_src
*** vec_seq_along/vec_init_along
vec_seq_along() is equivalent to seq_along() but uses size, not length. vec_init_along() creates a vector of missing values with size matching an existing object.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      vec_seq_along(mtcars)
                                        #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
                                        #> [24] 24 25 26 27 28 29 30 31 32
      vec_init_along(head(mtcars))
                                        #>      mpg cyl disp hp drat wt qsec vs am gear carb
                                        #> ...1  NA  NA   NA NA   NA NA   NA NA NA   NA   NA
                                        #> ...2  NA  NA   NA NA   NA NA   NA NA NA   NA   NA
                                        #> ...3  NA  NA   NA NA   NA NA   NA NA NA   NA   NA
                                        #> ...4  NA  NA   NA NA   NA NA   NA NA NA   NA   NA
                                        #> ...5  NA  NA   NA NA   NA NA   NA NA NA   NA   NA
                                        #> ...6  NA  NA   NA NA   NA NA   NA NA NA   NA   NA
    #+end_src
*** vec_order
Order and sort vectors.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- round(c(runif(9), NA), 3)
      vec_order(x)
                                        #>  [1]  4  6  9  1  5  8  2  3  7 10
      vec_sort(x)
                                        #>  [1] 0.107 0.260 0.294 0.648 0.711 0.739 0.775 0.811 0.958    NA
      vec_sort(x, "desc")
                                        #>  [1]    NA 0.958 0.811 0.775 0.739 0.711 0.648 0.294 0.260 0.107

                                        # Can also handle data frames
      df <- data.frame(g = sample(2, 10, replace = TRUE), x = x)
      vec_order(df)
                                        #>  [1]  6  9  5  8  2  3  4  1  7 10
         #+end_src
*** vec_sort

    #+begin_src R :results output graphics :file fig_1.png :exports both 
 vec_sort(df)
                                        #>    g     x
                                        #> 1  1 0.260
                                        #> 2  1 0.294
                                        #> 3  1 0.711
                                        #> 4  1 0.739
                                        #> 5  1 0.775
                                        #> 6  1 0.811
                                        #> 7  2 0.107
                                        #> 8  2 0.648
                                        #> 9  2 0.958
                                        #> 10 2    NA
      vec_sort(df, "desc")
                                        #>    g     x
                                        #> 1  2    NA
                                        #> 2  2 0.958
                                        #> 3  2 0.648
                                        #> 4  2 0.107
                                        #> 5  1 0.811
                                        #> 6  1 0.775
                                        #> 7  1 0.739
                                        #> 8  1 0.711
                                        #> 9  1 0.294
                                        #> 10 1 0.260      
    #+end_src
*** vec_size
Number of observations.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      vec_size(1:100)
                                        #> [1] 100
      vec_size(mtcars)
                                        #> [1] 32
      vec_size(array(dim = c(3, 5, 10)))
                                        #> [1] 3      
    #+end_src
*** vec_slice
Get or set observations in a vector.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- sample(10)
      x
                                        #>  [1]  1  3 10  6  5  8  7  9  4  2
      vec_slice(x, 1:3)
                                        #> [1]  1  3 10      
    #+end_src
*** vec_assign
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- sample(10)
      x
                                        #>  [1]  9  6  1  3  4  8 10  5  2  7
      vec_slice(x, 1:3)
                                        #> [1] 9 6 1
      y <- vec_assign(x, 3, 500)
      y
                                        #>  [1]   9   6 500   3   4   8  10   5   2   7      
    #+end_src
*** vec_recycle/vec_recycle_common
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      vec_recycle(1:5, 5)
                                        #> [1] 1 2 3 4 5
      vec_recycle_common(1:5, 5)
                                        #> [[1]]
                                        #> [1] 1 2 3 4 5
                                        #> 
                                        #> [[2]]
                                        #> [1] 5 5 5 5 5
      vec_recycle_common(integer(), 5)
                                        #> [[1]]
                                        #> integer(0)
                                        #> 
                                        #> [[2]]
                                        #> numeric(0)      
    #+end_src
*** vec_repeat
Expand the length of a vector.This is a special case of rep() for the special case of integer times and each values, and works along size, rather than length.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      # each repeats within
      vec_repeat(1:3, each = 2)
                                        #> [1] 1 1 2 2 3 3
                                        # times repeats whole thing
      vec_repeat(1:3, times = 2)
                                        #> [1] 1 2 3 1 2 3

      df <- data.frame(x = 1:2, y = 1:2)
                                        # rep() repeats columns of data frame, and returns list:
      rep(df, each = 2)
                                        #> $x
                                        #> [1] 1 2
                                        #> 
                                        #> $x
                                        #> [1] 1 2
                                        #> 
                                        #> $y
                                        #> [1] 1 2
                                        #> 
                                        #> $y
                                        #> [1] 1 2
                                        # vec_repeat() repeats rows, and returns same data.frame
      vec_repeat(df, 2)
                                        #>   x y
                                        #> 1 1 1
                                        #> 2 1 1
                                        #> 3 2 2
                                        #> 4 2 2      
    #+end_src
*** vec_split
Split a vector into groups.This is a generalisation of split() that can split by any type of vector, not just factors. Instead of returning the keys in the character names, the are returned in a separate parallel vector.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      vec_split(mtcars$cyl, mtcars$vs)
                                        #>   key                                                  val
                                        #> 1   0 6, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 8, 6, 8
                                        #> 2   1             4, 6, 6, 4, 4, 6, 6, 4, 4, 4, 4, 4, 4, 4
      vec_split(mtcars$cyl, mtcars[c("vs", "am")])
                                        #>   key.vs key.am                                val
                                        #> 1      0      1                   6, 6, 4, 8, 6, 8
                                        #> 2      1      1                4, 4, 4, 4, 4, 4, 4
                                        #> 3      1      0                6, 6, 4, 4, 6, 6, 4
                                        #> 4      0      0 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8
    #+end_src
*** vec_unique
Find and count unique values.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      x <- rpois(100, 8)
      x
                                        #>   [1]  9  8  8 11  8  4  7  9  9  5  6  5  6  7  3  3 10 10 10  5 16 10  5
                                        #>  [24]  7  9  6  5 10  6  4  7  4  4  4  8 11  6 13 10  8 10  9  3  6  9  8
                                        #>  [47] 13 10  9  8 12  3 10  8  3 11  6  9 10 11 11  4 11  8 10  8  5  5  9
                                        #>  [70]  4 10  8  5  8  8 10 10 12  7 16  7  6 12  3  7  7 12  6  8  7 14  5
                                        #>  [93]  6  3  6 11  7 10  8 10
      vec_unique(x)
                                        #>  [1]  9  8 11  4  7  5  6  3 10 16 13 12 14
      vec_unique_loc(x)
                                        #>  [1]  1  2  4  6  7 10 11 15 17 21 38 51 91
      vec_unique_count(x)
                                        #> [1] 13      
    #+end_src


* 专题
*** 缺失值处理
**** 如何删掉缺失值？
     #+begin_src R :results output graphics :file fig_1.png :exports both 
       x <- NA
       x > 3
       class(x)
       is.na(x)
       x[!is.na(x)]
       ## list
       x <- list(a = NA, b = 1)
       x[!is.na(x)]
       ## matrix
       x <- matrix(c(1, 2, 3, NA), 2, 2)
       x[!is.na(x)]
       ## data.frame
       x <- data.frame(a = c(1, 2, 3, NA), b = c(NA, 1, 2, 3))
       x[!is.na(x)] # 过滤掉 NA 的同时也把数据类型转换为 double
       typeof(x[!is.na(x)])
     #+end_src

*** 向量化计算
对应在 purrr 包中的 map，map_*,map2 等函数。 

| func   | descriptions                      |
| apply  | 分组计算                          |
| sapply | lapply 的简化版本                 |
| tapply | 分组计算                          |
| mapply | 多参数计算                        |
| vapply | sapply safty 版本，可以设置返回值 |
| lapply | 循环迭代                          |
| rapply | lapply 的递归版本                 |
| eapply | 环境空间遍历                      |

**** apply

Returns a vector or array or list of values obtained by applying a function to
margins of an array or matrix.

apply(X, MARGIN, FUN, ...)

Arguments:

X:an array, including a matrix.

MARGIN:a vector giving the subscripts which the function will be applied over. E.g., for a matrix 1 indicates rows, 2 indicates columns, c(1, 2) indicates rows and columns. Where X has named dimnames, it can be a character vector selecting dimension names.

FUN:the function to be applied: see ‘Details’. 
apply 函数是一个把某一命令应用在目标矩阵的每一个元素上的集合运算命令.
    #+begin_src R :results output graphics :file fig_1.png :exports both 
mydata <- matrix(rnorm(30), nrow = 6)
apply(mydata, 1, mean) # 对行求均值
mydata %>%
    lapply(.,is.character)
t <- data %$%
    loanbal %>% 
lapply(.,mifimodel::is_character) %>% 
unlist()
ma <- matrix(c(1:4, 1, 6:8), nrow = 2)
ma
apply(ma, 1, table) 
    #+end_src
**** lapply    
lapply 的特殊之处在于，它的输出形式为列表（list），并且每一个运算结果（数值）都是
一个单独的列表。这就是说，如果运算结果有六个数值，lapply 就会输出六个列表，每一个
列表里为一个数值。
lapply 函数和 apply 不同的是，lapply 针对每一个元素进行 function 操作。lapply 输
出的是 list 元素。 

lapply(X, FUN, ...)
参数列表：
    X:list、data.frame 数据
    FUN: 自定义的调用函数
    …: 更多参数，可选

#+begin_src R :results output graphics :file fig_1.png :exports both 
matrix1 <- matrix(c(4,9,16,25,36,49),nc = 2)
apply(matrix1,1,sqrt)
lapply(matrix1,sqrt)
#+end_src

为啥 lapply 这么重要？因为我们在执行 lapply 的时候即可以预先对结果输出形式进行设计。比如说，合并列表做个矩阵啊（matrix）或者数据框（data frame）啊，想横着合就横着合，想竖着合就竖着合。

拿我们之前的 matrix1 举例，运行 lapply 的结果是得到了六个独立的列表，每个列表里含有一个元素。如果我们想把开平方根的结果设成矩阵，应该怎么做呢？

这就要应用到一个超神的命令 do.call()，翻译过来就是，呼唤神级运算命令。这个 do.call()命令要怎么用呢，简单说就是 do.call(结果要怎么处理，运算要怎么做)。我们可以在 R 中直观地看一下，如果我们要把运算结果按行排列（粘贴），最后得到一个大的矩阵，应该如何做：

#+begin_src R :results output graphics :file fig_1.png :exports both 
do.call(rbind,lapply(matrix1,sqrt))  
#+end_src

如果我们想做一个数据框呢？

这时就不再需要 do.call 命令了，简单的 data.frame 就可以做到：

#+begin_src R :results output graphics :file fig_1.png :exports both 
data.frame(lapply(matrix1,sqrt))
#+end_src

**** sapply
sapply 
函数是一个迭代器，它遍历一个向量中所有的元素，调用另外一个函数对向量中的每个元素
进行处理，然后返回计算结果。
可以看出 sapply 输出的是 vector 类型数据。

函数定义：

sapply(X, FUN, ..., simplify=TRUE, USE.NAMES = TRUE)

参数列表：

    X:数组、矩阵、数据框
    FUN: 自定义的调用函数
    …: 更多参数，可选
    simplify: 是否数组化，当值 array 时，输出结果按数组进行分组
    USE.NAMES: 如果 X 为字符串，TRUE 设置字符串为数据名，FALSE 不设置

#+begin_src R :results output graphics :file fig_1.png :exports both 
  a <- 1:7
  sapply(a,sqrt)
  matrix1 <- matrix(c(4,9,16,25,36,49),nc = 2)
  apply(matrix1,1,sqrt)
  sapply(matrix1,sqrt)
  sapply(matrix1,sqrt) %>%
      str
  a<-1:2
  ## 按数组分组
  sapply(a,function(x) matrix(x,2,2), simplify='array')
  ## , , 1
  ## [,1] [,2]
  ## [1,]    1    1
  ## [2,]    1    1
  ## , , 2
  ## [,1] [,2]
  ## [1,]    2    2
  ## [2,]    2    2

                                        # 默认情况，则自动合并分组
  sapply(a,function(x) matrix(x,2,2))
  ## [,1] [,2]
  ## [1,]    1    2
  ## [2,]    1    2
  ## [3,]    1    2
  ## [4,]    1    2
#+end_src

对于字符串的向量，还可以自动生成数据名。

#+begin_src R :results output graphics :file fig_1.png :exports both 
  
val<-head(letters)
                                        # 默认设置数据名
sapply(val,paste,USE.NAMES=TRUE)
  ## a   b   c   d   e   f 
  ## "a" "b" "c" "d" "e" "f" 
                                        # USE.NAMES=FALSE，则不设置数据名
sapply(val,paste,USE.NAMES=FALSE)
  ## [1] "a" "b" "c" "d" "e" "f"  
#+end_src

**** vapply
vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)

参数列表：

    X:数组、矩阵、数据框
    FUN: 自定义的调用函数
    FUN.VALUE: 定义返回值的行名 row.names
    …: 更多参数，可选

    USE.NAMES: 如果 X 为字符串，TRUE 设置字符串为数据名，FALSE 不设置
通过使用 vapply 可以直接设置返回值的行名，这样子做其实可以节省一行的代码，让代码看起来更顺畅，当然如果不愿意多记一个函数，那么也可以直接忽略它，只用 sapply 就够了。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      # 生成数据集
 x <- data.frame(cbind(x1=3, x2=c(2:1,4:5)))
                                        # 设置行名，4行分别为a,b,c,d
vapply(x,cumsum,FUN.VALUE=c('a'=0,'b'=0,'c'=0,'d'=0))
      ## x1 x2
      ## a  3  2
      ## b  6  3
      ## c  9  7
      ## d 12 12     
                                        # 当不设置时，为默认的索引值
a<-sapply(x,cumsum);a
      ## x1 x2
      ## [1,]  3  2
      ## [2,]  6  3
      ## [3,]  9  7
      ## [4,] 12 12
                                        # 手动的方式设置行名
row.names(a)<-c('a','b','c','d')
    #+end_src
**** mapply
mapply 也是 sapply 的变形函数，类似多变量的 sapply，但是参数定义有些变化。第一参数为自定义的 FUN 函数，第二个参数’…’可以接收多个数据，作为 FUN 函数的参数调用。
函数定义：
mapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE,USE.NAMES = TRUE)
参数列表：

    FUN: 自定义的调用函数
    …: 接收多个数据
    MoreArgs: 参数列表
    SIMPLIFY: 是否数组化，当值 array 时，输出结果按数组进行分组
    USE.NAMES: 如果 X 为字符串，TRUE 设置字符串为数据名，FALSE 不设置
比如，比较 3 个向量大小，按索引顺序取较大的值。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      set.seed(1)
                                        # 定义3个向量
      x<-1:10
      y<-5:-4
      z<-round(runif(10,-5,5))
                                        # 按索引顺序取较大的值。
      mapply(max,x,y,z)      

      n<-rep(4,4)
      m<-v<-c(1,10,100,1000)
                                        # 生成4组数据，按列分组
      mapply(rnorm,n,m,v)
    #+end_src
**** tapply 
tapply 用于分组的循环计算，通过 INDEX 参数可以把数据集 X 进行分组，相当于 group by 的操
作。相当于 group_map.
函数定义：

tapply(X, INDEX, FUN = NULL, ..., simplify = TRUE)

参数列表：

    X: 向量
    INDEX: 用于分组的索引
    FUN: 自定义的调用函数
    …: 接收多个数据
    simplify : 是否数组化，当值 array 时，输出结果按数组进行分组

比如，计算不同品种的鸢尾花的花瓣(iris)长度的均值。
    #+begin_src R :results output graphics :file fig_1.png :exports both 
      
    #+end_src
*** TODO:并行化运算
    #+begin_src R :results output graphics :file fig_1.png :exports both 
 library (parallel)
doit <- function(x)(x)^2+2*x
system.time(res <- lapply (1:5000000, doit))
rm(res)
gc ()
cl <- makeCluster(getOption("cl.cores",3))
system.time(res <- parLapply (cl,1:5000000,doit))
stopCluster(cl)
    #+end_src
**** future
**** foreach
**** furrr
**** dofuture
**** future.apply

*** 文件批量处理
偶尔，我们可能想要以一种重复的、标准化的、无人值守的方式执行某个 R 程序，例如，你可能
需要每个月生成一次相同的报告，这时就可以在 R 中编写程序，在批处理模式下执行它。
> R CMD BATCH options infile outfile

*** 高级编程技巧
**** missing
可以使用 missing() 函数来确定某个参数是否已经提供了。
**** stopifnot
如果你的函数的输入参数不是向量化的，那么确保检查一下输入是不是标量的，可以使用 stopifnot(),assertthat 包。
     
有时需要对重要的前提条件进行检查，当其不为真就抛出一个错误（使用 stop()函数）。

#+begin_src R ::results output graphics :file fig_1.png :exports both
  wt_mean <- function(x, w) {
      if (length(x) != length(w)) {
          stop("`x` and `w` must be the same length", call. = F)
      }
      sum(w * x) / sum(x)
  }
  wt_mean(x = c(1, 2), w = c(1, 2))
                                        #> [1] 1.666667
  wt_mean(x = c(1, 2), w = c(1))
                                        #> Error: `x` and `w` must be the same length  
#+end_src

#+begin_src R ::results output graphics :file fig_1.png :exports both
  wt_mean <- function(x, w, na.rm = F) {
      stopifnot(is.logical(na.rm), length(na.rm) == 1)
      stopifnot(length(x) == length(w))
      if (na.rm) {
          miss <- is.na(x) | is.na(w)
          x <- x[!miss]
          w <- w[!miss]
      }
      sum(w * x) / sum(x)
  }
  wt_mean(c(1, 2), c(1, NA), na.rm = T)
                                        #> [1] 1  
#+end_src


#+begin_src R ::results output graphics :file fig_1.png :exports both
       x <- 1:10
       stopifnot(is.character(x))
                                        # Error: is.character(x) is not TRUE
     #+end_src

** 3.sql 查询
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
rimpala_zjy_init()
rimpala.switch(5)
rimpala.query2save("select miid,date,max(ishit) as ishit,max(cast(porvalue as int)) as DT_Num
                                       from anti_fraud_por_detail
                                       where date between 20190901 and 20190924 and porid=44
                                       and eventId=1018
                                      group by 1,2",file=sprintf("%s/duotou.csv", modelpath))

duotou=fread(sprintf("%s/duotou.csv", modelpath))
#+END_SRC

** mifi model package
*** mf_dm_data_library 
常用数据列表。
#+BEGIN_SRC R :exports both :results graphics :file ./fig_1.png
library(mifimodel)
mf_dm_data_library() #显示dm层可用的数据列表
#+END_SRC

* 数据比对 
#+begin_src R :results output graphics :file fig_1.png :exports both 
library(tidyverse)
df2 <- data.frame(id = c(1,2),x1 = c("2001.1.2","2002.2.1"),x2 = c("测试","嘻嘻"),x3 = c(3,4))
df1 <- data.frame(id = c(1,2),x1 = c("2001.1.2","2002.2.1"),x2 = c("测试","--"),x3 = c(1,4),x4 = c(1,2))

vars_com <- function(df1,df2){
    map2_chr(bind_rows(
        df1 %>% group_by_if(is.numeric, as.character) %>% mutate(group = "V1"),
        df2 %>% group_by_if(is.numeric, as.character) %>% mutate(group = "V2")
    ) %>%
    split(.$group) %$% V1, bind_rows(
                               df1 %>% group_by_if(is.numeric, as.character) %>% mutate(group = "V1"),
                               df2 %>% group_by_if(is.numeric, as.character) %>% mutate(group = "V2")
                           ) %>%
                           split(.$group) %$% V2, setequal)
}

vars_com(df1,df2) 
#+end_src
