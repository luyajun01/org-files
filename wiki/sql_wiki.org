# -*- org-confirm-babel-evaluate: nil; -*-
#+PROPERTY: header-args :eval never-export
#+TITLE: sql wiki
#+DESCRIPTION:
#+KEYWORDS:
#+STARTUP:  content

- [[wiki:index][Index]]

- Related: [[wiki:R_WIKI][R]]

* sql_wiki                                                              :toc:
  - [[#常见错误][常见错误]]
  - [[#名词解释][名词解释]]
    - [[#外键][外键]]
    - [[#索引][索引]]
  - [[#创建数据库][创建数据库]]
  - [[#选择数据库][选择数据库]]
  - [[#数据类型][数据类型]]
    - [[#数值类型][数值类型]]
    - [[#日期和时间][日期和时间]]
    - [[#字符串][字符串]]
  - [[#创建数据表][创建数据表]]
  - [[#删除数据库][删除数据库]]
  - [[#插入数据][插入数据]]
  - [[#查询数据][查询数据]]
    - [[#分页查询][分页查询]]
    - [[#聚合查询][聚合查询]]
    - [[#多表查询][多表查询]]
    - [[#连接查询][连接查询]]
  - [[#update][update]]
  - [[#delete][delete]]
  - [[#head][head]]
  - [[#regexp][RegExp]]
  - [[#where][where]]
    - [[#like][like]]
    - [[#in][in]]
    - [[#between-and][between and]]
    - [[#unionunion-all][union/union all]]
  - [[#ordering-and-limiting][ordering and limiting]]
  - [[#averaging-and-grouping][Averaging and Grouping]]
  - [[#nested-select][nested select]]
  - [[#join][join]]
  - [[#inner_join][inner_join]]
  - [[#插入变量][插入变量]]
  - [[#summarise][summarise]]
    - [[#count][count]]
    - [[#meanvar][mean/var]]
  - [[#string-截取][string 截取]]
  - [[#练习][练习]]
    - [[#查询-01-课程比-02-课程成绩高的学生的信息及课程分数][查询" 01 "课程比" 02 "课程成绩高的学生的信息及课程分数]]
    - [[#查询同时存在-01-课程和-02-课程的情况][查询同时存在" 01 "课程和" 02 "课程的情况]]
- [[#spark_wiki][Spark_wiki]]
- [[#hive_wiki][Hive_wiki]]

** 常见错误
数据库按照数据结构来组织，存储和管理数据，实际上，数据库一共有3种模型：

1.层次模型。层次模型就是以“上下级”的层次关系来组织数据的一种方式，层次模型的数据结构看起来就像一颗树。

2.网状模型。

3.关系模型。

No Database Selected.

需要指定使用哪一个数据库。
#+begin_src sql
use sys
#+end_src

** 名词解释
*** 外键
外键：可以通过特定的指标，实现与其他表关联，这种列就称为外键。
外键并不是通过列名实现的，而是通过定义外键约束实现的：

#+begin_src sql
ALTER TABLE students
ADD CONSTRAINT fk_class_id
FOREIGN KEY (class_id)
REFERENCES classes (id);
#+end_src

其中，外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。

通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录。

由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。

要删除一个外键约束，也是通过ALTER TABLE实现的：

#+begin_src sql
ALTER TABLE students
DROP FOREIGN KEY fk_class_id;
#+end_src

*** 索引
在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。

索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。

如果要经常根据 score 列进行查询，就需要对score 列创建索引。

#+begin_src sql
ALTER TABLE students
ADD INDEX idx_score (score);
#+end_src

使用ADD INDEX idx_score (score)就创建了一个名称为idx_score，使用列score的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：

#+begin_src sql
ALTER TABLE students
ADD INDEX idx_name_score (name, score);
#+end_src



** 创建数据库

   #+begin_src sql
     create database samp_db character set gbk;
     drop database samp_db; --删除库名为samp_db
     show databases;
     use samp_db ;--选择创建的数据库samp_db
     show tables;--显示samp_db下面所有的表名字
     describe
   #+end_src

   #+begin_src sql
  CREATE DATABASE IF NOT EXISTS RUNOOB DEFAULT CHARSET utf8 COLLATE utf8_general_ci;
   #+end_src

创建数据库，该命令的作用：

 1. 如果数据库不存在则创建，存在则不创建。
 2. 创建RUNOOB数据库，并设定编码集为utf8

** 选择数据库

   #+begin_src sql
     use course; -- course是数据库名
   #+end_src

** 数据类型
*** 数值类型

| 类型         | 用途           |
| TINYINT      | 小整数值       |
| SMALLINT     | 大整数值       |
| MEDIUMINT    | 大整数值       |
| INT或INTEGER | 大整数值       |
| BIGINT       | 极大整数值     |
| FLOAT        | 单精度浮点数值 |
| DOUBLE       | 双精度浮点数值 |
| DECIMAL      | 小数值         |

*** 日期和时间

| 类型      | 用途                     |
| DATE      | 日期值                   |
| TIME      | 时间值或持续时间         |
| YEAR      | 年份值                   |
| DATETIME  | 混合日期和时间值         |
| TIMESTAMP | 混合日期和时间值，时间戳 |

*** 字符串

| 类型     | 用途         |
| CHAR     | 定长字符串   |
| VARCHAR  | 变长字符串   |
| TEXT     | 长文本数据   |
| LONGTEXT | 极大文本数据 |

char(n) 和 varchar(n) 中括号里n 代表字符的个数，并不代表字节的个数，比如CHAR(30) 就可以存储30个字符。

** 创建数据表

   创建数据表需要包括以下信息：表名，表字段名，定义每个表字段。

   创建mysql 数据表的SQL 通用语法是：


   #+begin_src sql
   create table table_name (column_name column_type);
   #+end_src

   #+begin_src sql
     CREATE TABLE STUDENT
     (SNO VARCHAR(3) NOT NULL,
     SNAME VARCHAR(4) NOT NULL,
     SSEX VARCHAR(2) NOT NULL,
     SBIRTHDAY DATETIME,
     CLASS VARCHAR(5));
   #+end_src

   #+begin_src sql
CREATE TABLE IF NOT EXISTS `runoob_tbl`(
   `runoob_id` INT UNSIGNED AUTO_INCREMENT,
   `runoob_title` VARCHAR(100) NOT NULL,
   `runoob_author` VARCHAR(40) NOT NULL,
   `submission_date` DATE,
   PRIMARY KEY ( `runoob_id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
   #+end_src

- 如果不想字段为 NULL 可以设置字段的属性为NOT NULL，在操作数据库时如果输入该字段的数据为NULL，就会报错。

- AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。

- PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。

- ENGINE 设置存储引擎，CHARSET 设置编码。

#+begin_src
insert into grade values(90,100,'A')

insert into grade values(80,89,'B')

insert into grade values(70,79,'C')

insert into grade values(60,69,'D')

insert into grade values(0,59,'E')
#+end_src

** 删除数据库
在删除数据库过程中，务必要十分谨慎，因为在执行删除命令后，所有数据将会消失。

   #+begin_src sql
     drop database samp_db; --删除库名为samp_db
   #+end_src

** 插入数据
例如，我们向students表插入一条新记录，先列举出需要插入的字段名称，然后在VALUES子句中依次写出对应字段的值：
#+begin_src sql
insert into table_name (field1, field2,...,fieldN)
                       Values
                       (value1, value2,...,valueN);
#+end_src

#+begin_src SQL
INSERT INTO students (class_id, name, gender, score) VALUES (2, '大牛', 'M', 80);
#+end_src

** 查询数据

#+begin_src sql
SELECT column_name,column_name
FROM table_name
[WHERE Clause]
[LIMIT N][ OFFSET M]
#+end_src

查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。 SELECT 命令可以读取一条或者多条记录。
你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据。你可以使用 WHERE 语句来包含任何条件。
你可以使用 LIMIT 属性来设定返回的记录数。你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。

*** 分页查询

使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。

要实现分页功能，实际上就是从结果集中显示第1~100条记录作为第1页，显示第101~200条记录作为第2页，以此类推。

因此，分页实际上就是从结果集中“截取”出第M~N条记录。 *这个查询可以通过LIMIT <M> OFFSET <N>子句实现。* 我们先把所有学生按照成绩从高到低进行排序：

#+begin_src sql
SELECT id, name, gender, score
FROM students
ORDER BY score DESC
LIMIT 3 OFFSET 0;
#+end_src

上述查询LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。

如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3：

#+begin_src sql
SELECT id, name, gender, score
FROM students
ORDER BY score DESC
LIMIT 3 OFFSET 3;
#+end_src
可见，分页查询的关键在于，首先要确定每页需要显示的结果数量pageSize（这里是3），然后根据当前页的索引pageIndex（从1开始），确定LIMIT和OFFSET应该设定的值：

LIMIT总是设定为pageSize；
OFFSET计算公式为pageSize * (pageIndex - 1)。
这样就能正确查询出第N页的记录集。

*** 聚合查询

count

#+begin_src sql
SELECT COUNT(*) FROM students;
SELECT COUNT(*) num FROM students;
#+end_src

分组

#+begin_src sql
SELECT COUNT(*) num FROM students GROUP BY class_id;
#+end_src

*** 多表查询

SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：SELECT * FROM <表1> <表2>。

例如，同时从students表和classes表的“乘积”，即查询数据，可以这么写：

#+begin_src sql
SELECT * FROM students, classes;
#+end_src

这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。

这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。

你可能还注意到了，上述查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理

要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名：

#+begin_src sql
SELECT
students.id sid,
students.name,
students.gender,
students.score,
classes.id cid,
classes.name cname
FROM students, classes;
#+end_src

注意，多表查询时，要使用表名.列名这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用表名.列名这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：

#+begin_src sql
SELECT
s.id sid,
s.name,
s.gender,
s.score,
c.id cid,
c.name cname
FROM students s, classes c;
#+end_src

*** 连接查询

#+begin_src sql
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
INNER JOIN classes c
ON s.class_id = c.id;
#+end_src

注意INNER JOIN查询的写法是：

先确定主表，仍然使用FROM <表1>的语法；
再确定需要连接的表，使用INNER JOIN <表2>的语法；
然后确定连接条件，使用ON <条件...>，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接；
可选：加上WHERE子句、ORDER BY等子句。

外连接

#+begin_src sql
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
RIGHT OUTER JOIN classes c
ON s.class_id = c.id;
#+end_src

#+begin_src sql
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
LEFT OUTER JOIN classes c
ON s.class_id = c.id;
#+end_src

#+begin_src SQL
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
FULL OUTER JOIN classes c
ON s.class_id = c.id;
#+end_src


** update
UPDATE <表名> SET 字段1=值1, 字段2=值2, ... WHERE ...;

可以用update命令更新数据库。

#+begin_src sql
update STUDENT SET SSEX = "女" where SNAME = '曾华'
#+end_src

例如，我们想更新students表id=1的记录的name和score这两个字段，先写出UPDATE students SET name='大牛', score=66，然后在WHERE子句中写出需要更新的行的筛选条件id=1：

#+begin_src sql
UPDATE students SET name='大牛', score=66 WHERE id=1;
#+end_src

最后，要特别小心的是，UPDATE语句可以没有WHERE条件，例如：

#+begin_src SQL
UPDATE students SET score=60;
#+end_src

这时，整个表的所有记录都会被更新。所以，在执行UPDATE语句时要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新。

** delete

#+begin_src sql
delete from STUDENT where  SNAME = '曾华'
#+end_src

** head
R 中 head 一般是展示 6 行数据的功能。sql 语句可以写成如下：

#+begin_src sql
  a1s <- sqldf("select * from iris limit 6")
#+end_src

R 语句

#+begin_src R :results output graphics :file fig_1.png :exports both
  iris %>%
      head()
#+end_src

** RegExp
之前学习过like %进行模糊匹配，MySQL 同样也支持其他正则表达式的匹配， MySQL中使用 REGEXP 操作符来进行正则表达式匹配。

| 模式   | 描述   |
| ^      |        |
| $      |        |
| .      | 匹配除 |
| [...]  |        |
| [^...] |        |
| p1|p2|p3   |匹配p1或p2或p3 |
|*|匹配前面的子表达一次或多次|
|+|匹配前面的子表达式一次或多次|
|{n}|匹配确定的n次 |

#+begin_src sql
select * from STUDENT where SNAME regexp '王'
#+end_src
** where
sql 语句中的 filter 是 where.
*** like

我们知道在 MySQL 中使用 SQL SELECT 命令来读取数据， 同时我们可以在 SELECT 语句中使用 WHERE 子句来获取指定的记录。
WHERE 子句中可以使用等号 = 来设定获取数据的条件，如 "runoob_author = 'RUNOOB.COM'"。
但是有时候我们需要获取 runoob_author 字段含有 "COM" 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。

#+begin_src sql
#从iris 数据集中筛选出Species 开头是"set" 的记录
  sqldf("select * from iris where Species like 'set%'")
#+end_src

#+begin_src sql
select * from STUDENT where SNAME like "匡%"
#+end_src


R 语句可以这么写

#+begin_src R :results output graphics :file fig_1.png :exports both
  library(data.table)
  iris %>%
      filter(Species %like%  'set')
#+end_src
*** in
这个 in 很熟悉的。
    #+begin_src sql
      sqldf("select * from iris where Species in ('setosa','versicolor')")
    #+end_src

R 语句

#+begin_src R :results output graphics :file fig_1.png :exports both
  iris %>%
      filter(Species %in% c('setosa','versicolor'))
#+end_src

当然还有更直接的＝语句

#+begin_src
  sqldf("select * from iris where Species = 'setosa'")
#+end_src

#+begin_src R :results output graphics :file fig_1.png :exports both
  iris %>% filter(Species == 'setosa')
#+end_src

*** between and
上面的语句是针对的是离散变量，如果变量是连续变量，那么就需要用到 between and 了。
#+begin_src sql
  sqldf("select * from mtcars where wt between 3 and 4")
#+end_src

还能进一步显示行名，
#+begin_src R :results output graphics :file fig_1.png :exports both
  sqldf("select * from mtcars where wt between 3 and 4", row.names = T)
#+end_src


R 语句为

#+begin_src R :results output graphics :file fig_1.png :exports both
  mtcars %>%
      filter(wt %>% between(3,4))
#+end_src


   #+begin_src R :results output graphics :file fig_1.png :exports both
     sqldf('select Abbr, avg("Sepal.Length")  from iris where Species in ('','') by Species')
   #+end_src

*** union/union all
数据集的合并，类似于 R 中的 rbind.

    #+begin_src R :results output graphics :file fig_1.png :exports both
      sqldf("select * from a1 union all select * from a2")
    #+end_src

必须注意 union 与 union all 之间的区别。

    #+begin_src R :results output graphics :file fig_1.png :exports both
      sqldf("select count(*) from (
      select * from iris
      union all
      select * from iris
      )")
    #+end_src

** ordering and limiting
数据排序。
order by var desc 降序排列。
   #+begin_src R :results output graphics :file fig_1.png :exports both
library(datasets)
library(tidyverse)
library(sqldf)
                                   #> Loading required package: gsubfn
                                   #> Loading required package: proto
                                   #> Loading required package: RSQLite
sqldf('select * from iris order by "Sepal.Length" desc limit 3')
                                   #>   Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
                                   #> 1          7.9         3.8          6.4         2.0 virginica
                                   #> 2          7.7         3.8          6.7         2.2 virginica
                                   #> 3          7.7         2.6          6.9         2.3 virginica
iris %>%
    arrange(desc(Sepal.Length)) %>%
    head(3)
                                   #>   Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
                                   #> 1          7.9         3.8          6.4         2.0 virginica
                                   #> 2          7.7         3.8          6.7         2.2 virginica
                                   #> 3          7.7         2.6          6.9         2.3 virginica
   #+end_src
** Averaging and Grouping
这个就属于 summarise 范畴啦。
   #+begin_src R :results output graphics :file fig_1.png :exports both
     sqldf('select Species, avg("Sepal.Length") from iris group by Species')
                                        #>      Species avg("Sepal.Length")
                                        #> 1     setosa               5.006
                                        #> 2 versicolor               5.936
                                        #> 3  virginica               6.588

     iris %>%
         select(Species, Sepal.Length) %>%
         group_by(Species) %>%
         summarise(mean(Sepal.Length))
                                        #> # A tibble: 3 x 2
                                        #>   Species    `mean(Sepal.Length)`
                                        #>   <fct>                     <dbl>
                                        #> 1 setosa                     5.01
                                        #> 2 versicolor                 5.94
                                        #> 3 virginica                  6.59
   #+end_src
** nested select
这一块暂时还没搞明白。
 For each Species, find the average Sepal Length among those rows where Sepal Length exceeds the average Sepal Length for that Species.
#+begin_src sql
  sqldf("select iris.Species '[Species]',
  avg(\"Sepal.Length\") '[Avg of SLs > avg SL]'
  from iris,
  (select Species, avg(\"Sepal.Length\") SLavg
  from iris group by Species) SLavg
  where iris.Species = SLavg.Species
  and \"Sepal.Length\" > SLavg
  group by iris.Species")
#+end_src

上面的 sql 语句等价于下面
   #+begin_src R :results output graphics :file fig_1.png :exports both
     aggregate(Sepal.Length ~ Species, iris, function(x) mean(x[x > mean(x)]))
   #+end_src

请过滤出每组记录大于该组均值的记录。
   #+begin_src sql
     Emp <- data.frame(emp = letters[1:24], salary = 1:24, dept = rep(c("A", "B", "C"), each = 8))
     sqldf("SELECT *
     FROM Emp AS e1
     WHERE salary > (SELECT avg(salary)
     FROM Emp
     WHERE dept = e1.dept)")
   #+end_src

等价于以下 R 语言

#+begin_src R :results output graphics :file fig_1.png :exports both
  Emp$ave_salary = ave(Emp$salary, Emp$dept)
  Emp %>%
      filter(salary > ave_salary)
#+end_src

** join

数据连接方式，R and SQL 不同的地方。
| R               | SQL                                                                |
| inner_join()    | SELECT * FROM x JOIN y ON x.a = y.a                                |
| left_join()     | SELECT * FROM x LEFT JOIN y ON x.a = y.a                           |
| right_join()    | SELECT * FROM x RIGHT JOIN y ON x.a = y.a                          |
| full_join()     | SELECT * FROM x FULL JOIN y ON x.a = y.a                           |
| semi_join()     | SELECT * FROM x WHERE EXISTS (SELECT 1 FROM y WHERE x.a = y.a)     |
| anti_join()     | SELECT * FROM x WHERE NOT EXISTS (SELECT 1 FROM y WHERE x.a = y.a) |
| intersect(x, y) | SELECT * FROM x INTERSECT SELECT * FROM y                          |
| union(x, y)     | SELECT * FROM x UNION SELECT * FROM y                              |
| setdiff(x, y)   | SELECT * FROM x EXCEPT SELECT * FROM y                             |
|                 |                                                                    |
   #+begin_src R :results output graphics :file fig_1.png :exports both
     Abbr <- data.frame(Species = levels(iris$Species),
                        Abbr = c("S", "Ve", "Vi"))
     sqldf('select Abbr, avg("Sepal.Length")
   from iris natural join Abbr group by Species')
                                        #>   Abbr avg("Sepal.Length")
                                        #> 1    S               5.006
                                        #> 2   Ve               5.936
                                        #> 3   Vi               6.588

     iris %>%
         inner_join(Abbr, by = "Species") %>%
         group_by(Species) %>%
         summarise(mean(Sepal.Length))
                                        #> Warning: Column `Species` joining factor and character vector, coercing
                                        #> into character vector
                                        #> # A tibble: 3 x 2
                                        #>   Species    `mean(Sepal.Length)`
                                        #>   <chr>                     <dbl>
                                        #> 1 setosa                     5.01
                                        #> 2 versicolor                 5.94
                                        #> 3 virginica                  6.59
   #+end_src

   #+begin_src R :results output graphics :file fig_1.png :exports both
SNP1x <-
  structure(list(Animal = c(194073197L, 194073197L, 194073197L,
                            194073197L, 194073197L), Marker = structure(1:5, .Label = c("P1001",
                                                                                        "P1002", "P1004", "P1005", "P1006", "P1007"), class = "factor"),
                 x = c(2L, 1L, 2L, 0L, 2L)), .Names = c("Animal", "Marker",
                                                        "x"), row.names = c("3213", "1295", "915", "2833", "1487"), class = "data.frame")

SNP4 <-
  structure(list(Animal = c(194073197L, 194073197L, 194073197L,
                            194073197L, 194073197L, 194073197L), Marker = structure(1:6, .Label = c("P1001",
                                                                                                    "P1002", "P1004", "P1005", "P1006", "P1007"), class = "factor"),
                 Y = c(0.021088, 0.021088, 0.021088, 0.021088, 0.021088, 0.021088
                 )), .Names = c("Animal", "Marker", "Y"), class = "data.frame", row.names = c("3213",
                                                                                              "1295", "915", "2833", "1487", "1885"))
sqldf("select * from SNP4 left join SNP1x using (Animal, Marker) limit 5")
#>      Animal Marker       Y x
#> 1 194073197  P1001 0.02109 2
#> 2 194073197  P1002 0.02109 1
#> 3 194073197  P1004 0.02109 2
#> 4 194073197  P1005 0.02109 0
#> 5 194073197  P1006 0.02109 2
   #+end_src

** inner_join
在 flights 数据集中，对 year,group 进行分组，筛选出大于均值 dep_time 的记录。
   #+begin_src R :results output graphics :file fig_1.png :exports both
     flights %>%
         group_by(year,month) %>%
         select(dep_time) %>%
         inner_join(flights %>%
                    group_by(year,month) %>%
                    summarise(mean(dep_time))) %>%
         filter(dep_time > `mean(dep_time)`)
   #+end_src

   #+begin_src sql
     <SQL>
     SELECT *
     FROM (SELECT `LHS`.`year` AS `year`, `LHS`.`month` AS `month`, `LHS`.`dep_time` AS `dep_time`, `RHS`.`mean(dep_time)` AS `mean(dep_time)`
     FROM (SELECT `year`, `month`, `dep_time`
     FROM `nycflights13::flights`) AS `LHS`
     INNER JOIN (SELECT `year`, `month`, AVG(`dep_time`) AS `mean(dep_time)`
     FROM `nycflights13::flights`
     GROUP BY `year`, `month`) AS `RHS`
     ON (`LHS`.`year` = `RHS`.`year` AND `LHS`.`month` = `RHS`.`month`)
     )
     WHERE (`dep_time` > `mean(dep_time)`)
   #+end_src

查询所有学生的 sname，cno，degree 列

   #+begin_src sql
          select SNAME,CNO,DEGREE from (select SNAME, SNO from STUDENT) as A
     inner join (select SNO, CNO, DEGREE from  SCORE) as B
     on A.SNO = B.SNO
   #+end_src

   #+begin_src sql
     select SNO,CNAME,DEGREE from
     (select CNO, CNAME from COURSE) AS A
     inner join (select * from SCORE) AS B
     on A.CNO = B.CNO
   #+end_src

   #+begin_src sql
     select SNAME, CNO, DEGREE from (
     select  SNAME,SNO from STUDENT
     ) as A
     join (select * from SCORE) as B
     on A.SNO = B.SNO
   #+end_src

** 插入变量
用$ 可以插入变量。

   #+begin_src R :results output graphics :file fig_1.png :exports both
     minSL <- 7
     limit <- 3
     species <- "virginica"
     fn$sqldf("select * from iris where \"Sepal.Length\" > $minSL and species = '$species' limit $limit")
                                        #>   Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
                                        #> 1          7.1         3.0          5.9         2.1 virginica
                                        #> 2          7.6         3.0          6.6         2.1 virginica
                                        #> 3          7.3         2.9          6.3         1.8 virginica
   #+end_src

** summarise
*** count
计数
select count(class) as ct from STUDENT where class = "abc"
#+begin_src R :results output graphics :file fig_1.png :exports both
sqldf("select count(*) from iris")
#+end_src

*** mean/var
   #+begin_src R :results output graphics :file fig_1.png :exports both
     sqldf("select avg(demand) mean, variance(demand) var from BOD")
      #>    mean   var
                                        #> 1 14.83 21.44
   #+end_src

   #+begin_src sql
     select SNAME, DEGREE from
     (select SNO,SNAME,CLASS from STUDENT) as A
     join (select * from SCORE) as B
     on A.SNO = B.SNO where CLASS = "95033"
   #+end_src

   #+begin_src R :results output graphics :file fig_1.png :exports both
     flights %>%
         group_by(year,month) %>%
         summarise(mean(dep_time)) %>%
         show_query()
   #+end_src

上面 dplyr 语句 sql 写法是：
   #+begin_src
    <SQL>
SELECT `year`, `month`, AVG(`dep_time`) AS `mean(dep_time)`
FROM `nycflights13::flights`
GROUP BY `year`, `month`
   #+end_src
** string 截取
从左截取字符串。

#+begin_src sql
select left(SBIRTHDAY, 4) from STUDENT where SNO = "108"
#+end_src
** 练习
*** 查询" 01 "课程比" 02 "课程成绩高的学生的信息及课程分数


*** 查询同时存在" 01 "课程和" 02 "课程的情况

#+begin_src sql

#+end_src





* Spark_wiki
* Hive_wiki
Hive 是 Hadoop 家族中一款数据仓库产品，Hive 最大的特点就是提供了类 SQL 的语法，封装了底层的 MapReduce 过程，让有 SQL 基础的业务人员，也可以直接利用 Hadoop 进行大数据的操作。就是这一个点，解决了原数据分析人员对于大数据分析的瓶颈。

Hive 是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。Hive 定义了简单的类 SQL 查询语言，称为 HQL，它允许熟悉 SQL 的用户查询数据。同时，这个语言也允许熟悉 MapReduce 开发者的开发自定义的 mapper 和 reducer 来处理内建的 mapper 和 reducer 无法完成的复杂的分析工作。
