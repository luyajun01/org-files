# -*- org-confirm-babel-evaluate: nil; -*-
#+PROPERTY: header-args :eval never-export
+TITLE: java_wiki
+DESCRIPTION:
#+KEYWORDS:
#+STARTUP:  content

* 标识符
java 所有的组成部分都需要名字。类名，变量名以及方法名都被称为标识符。所有的标识符都应该以字母（A-Z 或者a-z），美元符（$），或者下划线（—）开始。标识符需要名字。

* 修饰符

2类修饰符：

访问控制修饰符：default,public,protected,private

非访问控制修饰符：final,abstract,static,synchronized

* 变量
java 中的变量类型主要有以下几种：

局部变量、类变量（静态变量）、成员变量（非静态变量）

* 数组

数组是存储在堆上的对象，可以保存多个同类型变量，在后面的章节中，我们将会学到如何声明，构造以及初始化一个数组。

* 枚举

枚举限制变量只能预先设定好值。使用枚举可以减少代码中的bug.

例如，我们为果汁店设计一个程序，它将限制果汁为小杯，中杯，大杯，这就意味着它不允许顾客点除了这三种尺寸外的果汁。










** hello world

   #+begin_src java
   public class HelloWorld {
    public static void main(String[] args) {
        // write your code here
        System.out.println("hello world!");
    }
}
   #+end_src
String args[] 与 String[] args 都可以执行，但推荐使用 String[] args，这样可以避免歧义和误读.为什么是 String[] args，这个 args 是干嘛的？String[] args 可以看出来它是一个数组。

* Scala_wiki
Scala 与 java 最大的区别是：scala 语句末尾的分号；是可选的。

对象 - 对象有属性和行为。例如：一只狗的状属性有：颜色，名字，行为有：叫、跑、吃等。对象是一个类的实例。

类 - 类是对象的抽象，而对象是类的具体实例。

方法 - 方法描述的基本的行为，一个类可以包含多个方法。

字段 - 每个对象都有它唯一的实例变量集合，即字段。对象的属性通过给字段赋值来创建。

#+begin_src scala
object HelloWorld {
def main(args: Array<String>) :Unit = {
println("Hello,World!")
}
}
#+end_src

基本语法
Scala 基本语法需要注意以下几点：

*区分大小写* -  Scala是大小写敏感的，这意味着标识Hello 和 hello在Scala中会有不同的含义。

*类名* - 对于所有的类名的第一个字母要大写。

如果需要使用几个单词来构成一个类的名称，每个单词的第一个字母要大写。

示例：class MyFirstScalaClass

方法名称 - 所有的方法名称的第一个字母用小写。
如果若干单词被用于构成方法的名称，则每个单词的第一个字母应大写。

示例：def myMethodName()

*程序文件名* - 程序文件的名称应该与对象名称完全匹配(新版本不需要了，但建议保留这种习惯)。
保存文件时，应该保存它使用的对象名称（记住Scala是区分大小写），并追加".scala"为文件扩展名。 （如果文件名和对象名称不匹配，程序将无法编译）。

示例: 假设"HelloWorld"是对象的名称。那么该文件应保存为'HelloWorld.scala"

def main(args: Array[String]) - Scala程序从main()方法开始处理，这是每一个Scala程序的强制程序入口部分。

* 数据类型

Byte	8位有符号补码整数。数值区间为 -128 到 127
Short	16位有符号补码整数。数值区间为 -32768 到 32767
Int	32位有符号补码整数。数值区间为 -2147483648 到 2147483647
Long	64位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807
Float	32 位, IEEE 754 标准的单精度浮点数
Double	64 位 IEEE 754 标准的双精度浮点数
Char	16位无符号Unicode字符, 区间值为 U+0000 到 U+FFFF
String	字符序列
Boolean	true或false
Unit	表示无值，和其他语言中void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成()。
Null	null 或空引用
Nothing	Nothing类型在Scala的类层级的最底端；它是任何其他类型的子类型。

** any
Any	Any是所有其他类的超类。

Any是所有类型的超类型，也称为顶级类 型。它定义了一些通用的方法如equals、hashCode和toString。Any有两个直接子类：AnyVal和AnyRef。

AnyVal代表值类型。有9个预定义的非空的值类型分别是：Double、Float、Long、Int、Short、Byte、Char、Unit和Boolean。Unit是不带任何意义的值类型，它仅有一个实例可以像这样声明：()。所有的函数必须有返回，所以说有时候Unit也是有用的返回类型。

AnyRef代表引用类型。所有非值类型都被定义为引用类型。在Scala中，每个用户自定义的类型都是AnyRef的子类型。如果Scala被应用在Java的运行环境中，AnyRef相当于java.lang.Object。

AnyRef	AnyRef类是Scala里所有引用类(reference class)的基类

https://docs.scala-lang.org/resources/images/tour/unified-types-diagram.svg

#+begin_src scala
object helloworld {
  def main(args: Array[String]): Unit = {
    val list:List[Any] = List(
      "a string",
      732,
      'c',
      true,
      () => "an anoymous function returing a string"
    )
    list.foreach(element => println(element))
  }
}
#+end_src

这里定义了一个类型List<Any>的变量list。这个列表里由多种类型进行初始化，但是它们都是scala.Any的实例，所以可以把它们加入到列表中。

#+begin_src scala
object helloworld {
  def main(args: Array[String]): Unit = {
    val alice = new Person("Alice",25)
    val bob = new Person("Bob",32)
    val charlie = new Person("Charlie",32)
 for (person <- List(alice, bob, charlie)){
   person match {
     case Person("Alice", 25) => println("Hi Alice")
     case Person("Bob",32) => println("Hi Bob!")
     case Person(name, age) =>
       println("Age: " + age + "year,name:" + name + "?")
   }
 }
  }
  case class Person(name: String, age: Int)
}
#+end_src


** list
#+begin_src scala
val list = List("apple","banana",1,2)
val list2 = "apple" :: "banana" :: 1 :: 2 :: Nil
#+end_src

*** count
计算长度为1 的string 元素的个数。

#+begin_src scala
onetwothree.count(s => s.length == 1)
#+end_src

*** drop
返回去掉前2个元素的列表
#+begin_src scala
onetwothree.drop(2)
#+end_src

*** dropRight
返回去掉后2个元素的列表
#+begin_src scala
onetwothree.dropRight(2)
#+end_src

*** exist
判断是否有值为“1”。
#+begin_src scala
onetwothree.exists(s => s == "1")
#+end_src

*** filter
返回长度为1 的组成新的列表
#+begin_src scala
onetwothree.filter(s => s.length == 1)
#+end_src

*** forall
判断是否列表里所有元素都以“1” 结尾。
#+begin_src scala
onetwothree.forall(s => s.endsWith("1"))
#+end_src

*** foreach
对列表每个字符串都执行print 语句。
#+begin_src scala
onetwothree.foreach(s => print(s))
#+end_src

*** head
返回列表第一个元素
#+begin_src scala
onetwothree.head
#+end_src

*** init
返回列表除最后一个元素外的其他元素列表
#+begin_src scala
onetwothree.init
#+end_src

*** isEmpty
判断列表是否为空
#+begin_src scala
onetwothree.isEmpty
#+end_src

*** last
返回列表列表最后一个元素
#+begin_src scala
onetwothree.last
#+end_src

*** length
返回列表的元素数量
#+begin_src scala
onetwothree.length
#+end_src

*** map
每个string 元素都加一个“y”

#+begin_src scala
onetwothree.map(s=>s+"y")
#+end_src

*** mkString
列表元素组成的字符串。
#+begin_src scala
onetwothree.mkString(", ")
#+end_src

*** toString
其他数据格式转变成 string.

#+begin_src scala
def getSquareString(input: Double): String = {
  val square = input * input
  square.toString
}
println(getSquareString(2.5)) // 6.25
#+end_src

*** remove

#+begin_src scala

#+end_src

*** reverse

#+begin_src scala
onetwothree.reverse
#+end_src

*** sort

*** tail
返回列表中除第一个元素之外的列表。

#+begin_src scala
onetwothree.tail
#+end_src

** tuple

#+begin_src scala
val pair = (99, "asd")
pair._1
pair._2

var jetset = Set("boe", "add")
jetset += "lear"

#+end_src

*** contains

#+begin_src scala
var jetset = Set("boe", "add")
jetset += "lear"
jetset.contains("add")
#+end_src

和python 类似，set 也是不可更改的对象，如果需要更改，那么需要加入引用

#+begin_src scala
import scala.collection.mutable.Set
val movieSet = Set("Hitch","Poltergeist")
movieSet += "Shrek"
#+end_src

** 代码块
blocks

Scala可以通过将表达式用{ }括起来，从而组合表达式。我们称其为代码块。注意，代码块中 最后一个表达式的结果 才是整个块的结果：

#+begin_src scala
println({
  val x = 1 + 1
  x + 1
}) // 3
#+end_src

* val,var
使用var 可以重新定义保存变量，而val 不可以。
scala 可以自动根据变量的值来自动推断变量的类型。

* lazy
惰性赋值。这样做的好处就是节约内存。

#+begin_src scala
lazy val/var 变量名 = 表达式
#+end_src

* match
match 对应 Java 里的 switch，但是写在选择器表达式之后。即： 选择器 match {备选项}。
match 表达式通过以代码编写的先后次序尝试每个模式来完成计算，只要发现有一个匹配的case，剩下的case不会继续匹配。

#+begin_src scala
object helloworld {
  def main(args: Array[String]): Unit = {
   println(matchTest(3))
  }
  def matchTest(x: Int):String = x match {
    case 1 => "one"
    case 2 => "two"
    case _ => "many"
  }
}
#+end_src

* 转义符

转义字符	Unicode	描述
\b	\u0008	退格(BS) ，将当前位置移到前一列
\t	\u0009	水平制表(HT) （跳到下一个TAB位置）
\n	\u000a	换行(LF) ，将当前位置移到下一行开头
\f	\u000c	换页(FF)，将当前位置移到下页开头
\r	\u000d	回车(CR) ，将当前位置移到本行开头
\"	\u0022	代表一个双引号(")字符
\'	\u0027	代表一个单引号（'）字符
\\	\u005c	代表一个反斜线字符 '\'

* 访问修饰符
Scala 访问修饰符基本和Java的一样，分别有：private，protected，public。

如果没有指定访问修饰符，默认情况下，Scala 对象的访问级别都是 public。

Scala 中的 private 限定符，比 Java 更严格，在嵌套类情况下，外层类甚至不能访问被嵌套类的私有成员。

* 运算符
#+begin_src scala
object HelloWorld {
  def main(args: Array[String]) {
    var a = 10;
    var b = 20;
    var c = 25;
    var d = 25;
    println("a + b = " + (a + b) );
    println("a - b = " + (a - b) );
    println("a * b = " + (a * b) );
    println("b / a = " + (b / a) );
    println("b % a = " + (b % a) );
    println("c % a = " + (c % a) );

  }
}
#+end_src

* 字符串
** 插值表达式
可以有效避免大量字符串的拼接。

#+begin_src scala
val/var 变量名 = s"${变量／表达式}字符串"
#+end_src

特点就是在定义字符串之前添加s,在字符串中，可以使用${} 来引用变量或者编写表达式.

#+begin_src scala
val name = "lu"
val age = 30
val sex = "male"
val info = s"name = ${name}, age = ${age}, sex = ${sex}"
#val info: String = name = lu, age = 30, sex = male
#+end_src

用三个引号去定义一个字符串。
#+begin_src scala
val sql = """
select * from table
"""
#+end_src

* 关系运算符

#+begin_src scala
object HelloWorld {
  def main(args: Array[String]) {
    val a = true
    val b = false

    println("a && b = " + (a && b))
    println("a || b = " + (a || b))
    println("!(a && b) = " + !(a && b))

  }
}
#+end_src

* if

#+begin_src scala
object HelloWorld {
  def main(args: Array[String]) {
    val x = 10
    if (x < 20) println("x < 20")
  }
}
#+end_src

#+begin_src scala
object HelloWorld {
  def main(args: Array[String]) {
    val x = 30

    if (x < 20) {
      println("x 小于 20")
    }else{
      println("x 大于 20")
    }
  }
}
#+end_src

#+begin_src scala
object helloworld {
  def main(args: Array[String]): Unit = {
    var x = 30;
    if (x == 10) {
      println("X 的值为10");
    } else if (x == 20) {
      println("X 的值为20");
    } else if (x == 30) {
      println("X 的值为30");
    } else {
      println("无法判断 X 的值");
    }
  }
}
#+end_src

* for

#+begin_src scala
for (i <- 1 to 4)
   println("iteration" + i)
#+end_src

如果不想包括被枚举的range 的上边界，还可以用until 替代 to.
#+begin_src scala
for (i <- 1 until 4)
    println("iteration" + i)
#+end_src

** filter
for 中可以添加过滤器（filter），即if 子句。

#+begin_src scala
def main(args: Array[String]): Unit = {
  for (i <- 1 to 4 if i % 2 == 0)
    println("iteration" + i)
}
#+end_src

过滤器还可以超过一个，if 语句必须用分号分隔。

#+begin_src scala
for(
file <- filesHere
if file.isFile;
if file.getName.endsWith(".scala")
) println(file)
#+end_src

** 多层嵌套

可以加入多个<- 子句，可以得到嵌套的“循环”。

#+begin_src scala
for(
file <- filesHere
if file.isFile;
line <- fileLines(file)
if file.getName.endsWith(".scala")
) println(file)
#+end_src

* 方法
方法的表现和行为和函数非常类似，但是它们之间有一些关键的差别。

方法定义由一个 def 关键字开始，紧接着是可选的参数列表，一个冒号 : 和方法的返回类型，一个等于号 = ，最后是方法的主体。

#+begin_src scala
def functionName ([参数列表]) : [return type] = {
   function body
   return [expr]
}

def add(a:Int, b:Int) : Int = a+b
println(add(1,2))
#+end_src

方法可以接受多个参数列表。

#+begin_src scala
def addThenMultiply(x:Int, y:Int)(multiplier:Int):Int = (x+y) *multiplier
println(addThenMultiply(1,2)(3))
#+end_src

上面的代码也可以这么写

#+begin_src scala
def addThenMultiply(x:Int, y:Int,multiplier:Int):Int = (x+y) *multiplier
println(addThenMultiply(1,2,3))
#+end_src

或者没有参数列表。

#+begin_src scala
def name:String = System.getProperty("user.name")
println("Hello," + name+"!");
#+end_src

scala 有方法与函数，二者在语义上的区别很小。Scala 方法是类的一部分，而函数是一个对象可以赋值给一个变量。换句话来说在类中定义的函数既是方法。

scala 中使用val 语句可以定义函数，def 语句定义方法。方法也可以有多行的表达式。
#+begin_src sql
object helloworld{
def main(args: Array[String]): Unit = {
println("Returned Value:" + addInt(5,7));
}
def addInt(a:Int, b:Int) : Int = {
var sum:Int = 0
sum = a+b
return sum
}
}
#+end_src

函数可作为一个参数传入到方法中，而方法不行。

- 定义一个方法
#+begin_src SQL
def m2(f:(Int, Int) => Int) = f(2, 6)
#+end_src

- 定义一个函数

#+begin_src sql
val f2 = (x:Int, y:Int) => x - y
#+end_src

- 将函数作为参数传入到方法中

#+begin_src sql
m2(f2)
#+end_src

#+begin_src sql
//定义一个方法
def m1(f:(Int, Int) => Int) : Int = {
f(2,6)
}
//定义一个函数f1,参数是两个Int类型，返回值是一个Int类型
val f1 = (x:Int,y:Int) => x + y
//再定义一个函数f2
val f2 = (m:Int, n:Int) => m * n

//main方法
def main(args: Array[String]): Unit = {
//调用m1方法，并传入f1函数
val r1 = m1(f1)

println(r1);

//调用m1方法，并传入f2函数
var r2 = m1(f2)
println(r2)
}
#+end_src

在scala 中无法直接操作方法，如果要操作方法，必须先将其转换成函数。有两种方法可以将方法转换成函数。

#+begin_src scala
val f1 = m _
#+end_src

一个方法可以采用多个参数列表：

#+begin_src scala
def addThenMultiply(x: Int, y: Int)(multiplier: Int): Int = (x + y) * multiplier
println(addThenMultiply(1, 2)(3)) // 9
// 这个方法实现了两个参数相加后，再与第三个参数相乘。
#+end_src


** 匿名函数
可以用Scala定义匿名函数（没有名称的函数），比如下面这个例子的函数将返回一个给定的整数+1后的结果。
#+begin_src scala
val addone = (x: Int) => x + 1
println(addone(1))
#+end_src

一个函数可以有多个参数，也可以没有参数
#+begin_src scala
val addone = (x:Int,y:Int) => x + y
println(addone(1,2))
#+end_src

#+begin_src scala
val addone = () => 42
println(addone())
#+end_src

** 捕获异常
捕获异常的语法，选择catch 子句这种语法的原因是为了与scala 很重要的部分模式匹配保持一致。

* 变量定义
scala 有2种变量，val 和 var,val 类似于java 里的final 变量，一旦初始化了，val 就不能再被赋值。相反，var 如同java 里面的非final 变量，可以在它的生命周期被多次赋值。

* 函数定义
函数是带有参数的表达式。可以定义一个匿名函数，返回一个给定整数加一的结果。

#+begin_src scala
(x:Int)=>x+1
#+end_src

=> 的左边是参数列表，右边是一个包含参数的表达式。你也可以给函数命名。

#+begin_src scala
val addone = (x:Int)=> x+1
println(addone(1))
#+end_src

函数可带有多个参数

#+begin_src scala
val add = (x:Int,y:Int) => x+y
println(add(1,2))
#+end_src

或者不带参数

#+begin_src scala
val gettheanswer = () => 43
println(gettheanswer())
#+end_src

#+begin_src scala
def max2(x:Int, y:Int) = if (x>y) x else y
    println(max2(3,5))

def greet() = println("Hello, world!")
    Println(greet)
#+end_src

* Array
使用类型参数化实例可以通过把一个或更多类型指定到基础类型后的括号里来实现。下面例子中，greetStrings 的类型是 Array[String] (字符串数组)，并且由于创建数组的值参数为3，因此其初始长度为3.

#+begin_src scala
object helloworld {
  def main(args: Array[String]): Unit = {
val greetingStrings = new Array[String](3)

greetingStrings(0) = "Hello"
greetingStrings(1) = ","
greetingStrings(2) = "world!\n"

for (i <- 0 to 2)
  print(greetingStrings(i))
  }
}
#+end_src

在上面 for 表达式的第一行代码说明了scala 的另一个基本规则：方法若只有一个参数，调用的时候就可以省略点及括号。本例中的to 实际上是仅带一个 Int 参数的方法。代码0 to 2 被转换成方法调用 （0）.to(2).

用括号传递给变量一个或多个值参数时，scala 会把它转换成对apply 方法的调用。于是 greetingStrings(i) 转换成 greetingStrings.apply(i).

#+begin_src scala
val rec = Array("ba:bas(1)", "ba2:bsd")
#+end_src

* 创建列表（List）

列表类中定义了 ：：： 方法实现叠加功能。
#+begin_src scala
 val oneTwo = List(1, 2)
 val threeFour = List(3, 4)
 val oneTwoThreeFour = oneTwo ::: threeFour
 println("" + oneTwo + " and " + threeFour + " were not mutated.")
 println("Thus, " + oneTwoThreeFour + " is a new List.")
#+end_src

列表类最常用的操作符或许是“：：”，发音为“cons”，它可以把新元素组合到现有列表的最前端，然后返回作为执行结果的新列表。

#+begin_src scala
val twoThree = List(2,3)
val oneTwoThree = 1 :: twoThree
println(oneTwoThree)
#+end_src

值得注意的是，scala 的list 类中，没有提供append 操作，而是使用 ：： 做前缀。

#+begin_src scala
    val list1 = "will" :: List("fill")
    println(list1)
#+end_src

不知道为啥下面程序会报错！

#+begin_src scala
val list1 = "will" :: "fill"
println(list1)
#+end_src

** exist

判断字符是否存在“fill” 字符。

#+begin_src scala
val list1 = "will" :: List("fill")
val a = list1.exists(s => s == "fill")
println(a)
#+end_src

* tuple
在scala 里，和列表一样，元组也是不可变的，在python 里，array 是可变的。与列表不同，元组可以包含不同类型的元素。例如，列表只能写成 List[Int] 或 List[String], 但元组可以同时拥有 Int 和 String.

#+begin_src scala
val pair = (99, "Luftballons")
println(pair._1) #返回第一个元素
println(pair._2) #返回第二个元素

val ingredient = ("sugar", 25):Tuple2[String, Int]
println(ingredient._1)
println(ingredient._2)
#+end_src

scala 元组也支持解构。

#+begin_src scala
val ingredient = ("sugar", 25):Tuple2[String, Int]
println(ingredient._1)
println(ingredient._2)
val (name, quantity) = ingredient
println(name)
println(quantity)
#+end_src

元组结构也可用于模式匹配。

#+begin_src scala
val planetDistanceFromSun = List(("Mercury", 57.9), ("Venus", 108.2), ("Earth", 149.6 ), ("Mars", 227.9), ("Jupiter", 778.3))

    planetDistanceFromSun.foreach{ tuple => {

      tuple match {

        case ("Mercury", distance) => println(s"Mercury is $distance millions km far from Sun")

        case p if(p._1 == "Venus") => println(s"Venus is ${p._2} millions km far from Sun")

        case p if(p._1 == "Earth") => println(s"Blue planet is ${p._2} millions km far from Sun")

        case _ => println("Too far....")
      }
    }
    }
#+end_src

或者，在‘for’ 表达式中

#+begin_src scala
 val numpairs = List((2,5),(3,-7),(20,56))
    for ((a,b) <- numpairs){
     println(a*b)
    }


import scala.util.matching.Regex
import scala.collection.mutable.Map
object helloworld {
  def main(args: Array[String]): Unit = {
    val treasureMap = Map(
      1 -> "I",2 -> "II"
    )
    println(treasureMap(1))
  }
}
#+end_src

* set

#+begin_src scala
val fruits = Set("orange","peach","apple","banana")
#+end_src


#+begin_src scala
 var jetSet = Set("Boeing", "Airbus")
    jetSet += "Lear"
    println(jetSet)
    println(jetSet.contains("Cessna")) #False
#+end_src

这里的map 很像是case_when.

#+begin_src scala
  val romanNumeral = Map(
      1 -> "I", 2 -> "II"
    )
    println(romanNumeral(1))
#+end_src

* Map

map 作为高阶函数是指使用其他函数作为参数，或者返回一个函数作为结果的函数。在scala 中函数是一等公民，所以允许定义高阶函数。我们约定，使用函数值作为参数，或者返回值为函数值的“函数” 和 "方法",均称为“高阶函数”。

这个其实和python 中的map 函数是一致的。

#+begin_src scala
val salaries = Seq(2000,700,4900)
val doublesalary = (x:Int) => x*2
val newsalary = salaries.map(doublesalary)
println(newsalary)
#+end_src

上面的code 等价于

#+begin_src scala
val salaries = Seq(2000,700,4900)
val doublesalary = (x:Int) => x*2
val newsalary = salaries.map(x => x * 2)
println(newsalary)
#+end_src
既然Scala编译器已经知道了参数的类型（一个单独的Int），你可以只给出函数的右半部分，不过需要使用_代替参数名（在上一个例子中是x）

所以，更一般的写法是

#+begin_src scala
val salaries = Seq(2000,700,4900)
val doublesalary = (x:Int) => x*2
val newsalary = salaries.map(_ * 2)
println(newsalary)
#+end_src

#+begin_src scala
val treasureMap = Map[Int, String]()
treasureMap += (1 -> "Go to island")
println(treasureMap(1))
#+end_src

代码中首先引用了可变的Map, 然后定义了treasuremap, 并初始化为以整数为键和以字符串为值的可变Map, 因为没有向工厂方法传递任何值，所以Map 为空，之后用->和+= 向Map 里添加键值对。

还有一种方式就是

#+begin_src scala
val romanNumeral = Map(
    1 -> "I", 2 -> "II"
  )
println(romanNumeral(1))
#+end_src

* 嵌套方法
在Scala中可以嵌套定义方法。例如以下对象提供了一个factorial方法来计算给定数值的阶乘：

#+begin_src scala
  def main(args: Array[String]): Unit = {
def factorial(x:Int):Int = {
  def fact(x:Int, accumulator:Int):Int = {
    if(x<=1) accumulator
    else fact(x-1,x*accumulator)
  }
  fact(x,1)
}
    println("factorial of 2:" + factorial(2))
    println("factorial of 3:" + factorial(3))
  }
#+end_src





* new
scala 里使用new 实例化对象，在实例化过程中，可以用值和类型使对象参数化。

#+begin_src scala
val big = new java.math.BigInteger("12345")
#+end_src

#+begin_src scala
  val greetStrings = new Array[String](3)
  greetStrings(0) = "hello"
  greetStrings(1) = ","
  greetStrings(2) = "world!\n"
  for (i <- 0 to 2)
    print(greetStrings(i))
}
#+end_src

* :::

列表类定义了“：：：” 方法实现叠加功能。

#+begin_src scala
object helloworld{
  def main(args: Array[String]): Unit = {
    val onetwo = List(1,2)
    val threefour = List(3,4)
    val ottf = onetwo:::threefour
    println(ottf)
  }
}
#+end_src

因为 Nil 是空列表的简写，所以可以使用cons 操作符把所有元素都串起来，并以nil 作结尾来定义新列表。

#+begin_src scala
val onetwothree = 1::2::3::Nil
#+end_src

* 分号
scala 程序里，语句末尾的分号通常是可选的。如果一行包含多条语句时，分号则是必须的。

#+begin_src scala
val s = "hello"; println(s)
#+end_src

* 常用的函数
** show
数据概要展示，相当于head。
#+begin_src scala
val textFile = spark.read.textFile("README.md")
textFile.show()
#+end_src

** filter

#+begin_src scala
val x = List.range(1,10)
val evens = x.filter(_ % 2 == 0)

val list2 = "apple" :: "banana" :: 1 :: 2 :: Nil
val strings = list2.filter{
      case s:String => true
      case _ => false
}
#+end_src

#+begin_src scala
val list = List(4,2,6,8,1,2)
val list2 = "apple" :: "banana" :: 1 :: 2 :: Nil
val list_filter = list.filter(x => x % 2 == 0)
#+end_src

可以多次filter.

#+begin_src scala
val list_str=List("Nice","To","Meet","You")
val x=list_str.filter(x => x.startsWith("N"))//List(Nice)
var y=list_str.filter(x => x.contains("o"))//List(To, You)
var z=list_str.filter(x => x.length()>3)//List(Nice, Meet)
var z=list_str.filter(x => x.length()>3).filter(x=> x.contains("N")) //List(Nice)filter可以用于多次过滤
#+end_src

** filterNot

#+begin_src scala
val x = List.range(1,10)
val evens = x.filterNot(_ % 2 == 0)
#+end_src

** takeWhile

#+begin_src scala
val s1 = List(1,2,3,4,10,20,30,40,5,6,7,8,50,60,70,80)
val r1 = s1.takeWhile( _ < 10)
#+end_src

fiter取所有的满足条件的元素； takeWhile取出从第一个开始满足条件的元素，直到遇到不满足条件的元素。

** Map

#+begin_src scala

#+end_src

** count

#+begin_src scala
val textFile = spark.read.textFile("README.md")
textFile.count()
textFile.first()
#+end_src
** seq

#+begin_src scala
val df = Seq((2, 3), (3, 4), (4, 5), (5, 6), (3, 7), (1, 7)).toDF("col1","col2")
df.show()
#+end_src
** toDF

#+begin_src scala
val df = Seq((2, 3), (3, 4), (4, 5), (5, 6), (3, 7), (1, 7)).toDF("col1","col2")
df.show()
#+end_src
** range

#+begin_src scala
val x = List.range(1,10)
#+end_src
** startsWith

#+begin_src scala
val fruits = Set("orange","peach","apple","banana")
val x = fruits.filter(_.startsWith("a"))
#+end_src
** length

#+begin_src scala
val fruits = Set("orange","peach","apple","banana")
val x = fruits.filter(_.length>5)
#+end_src

* 类
类是对象的蓝图，一旦定义了类，就可以用关键字 new 根据类的蓝图创建对象，比方说，有如下的类定义：

#+begin_src scala
class ChecksumAccumulator{
  //此处为类定义
}
#+end_src

例子：
#+begin_src scala
class Greeter(prefix:String, suffix:String){
      def greet(name:String):Unit =
        println(prefix + name + suffix)
    }
val greeter = new Greeter("Hello","!")
greeter.greet("Scala developer")
#+end_src
greet方法的返回类型是Unit，表明没有什么有意义的需要返回。它有点像Java和C语言中的void。（不同点在于每个Scala表达式都必须有值，事实上有个Unit类型的单例值，写作()，它不携带任何信息）

你可以使用 new 关键字创建一个类的实例。

#+begin_src scala
val greeter = new Greeter("Hello","!")
greeter.greet("Scala developer")
#+end_src

接下来就能创建ChecksumAccumulator 对象：

new ChecksumAccumulator

类定义里，可以放置字段和方法，这些被笼统地称为 *成员* 。

#+begin_src scala
class ChecksumAccumulator{
  val sum = 0
}
val acc = new ChecksumAccumulator
val csa = new ChecksumAccumulator
println(acc.sum)
#+end_src

Scala 程序里，语句末尾的分号通常是可选的。愿意可以加，若一行里仅有一个语句也可以不加。不过，如果一行包含多条语句时，分号则是必须的。

** private
尽管acc 是val, 但是仍可以修改acc 指向的对象，val 类型对象对acc 的限制仅在于不可以把它们再次赋值为其他对象。

保持对象健壮性的重要方法之一就是保证对象的状态，第一步就是通过把字段变为私有的（private）以阻止外界直接对它的访问。

#+begin_src scala
object helloworld{
  def main(args: Array[String]): Unit = {
    class checksumaccumulator{
    private var sum = 0
    }
    val acc = new checksumaccumulator
    acc.sum = 5 //编译不过，因为sum 是私有的
    println(acc.sum)
  }
}
#+end_src

** case 类
Scala具有一种特殊的类，称为“case类”。默认情况下，case类的实例是不可变的，并且它们通过值进行比较（不同于类，其实例通过引用进行比较）。

#+begin_src scala
case class Point(x: Int, y: Int)
val point = Point(1, 2)
val anotherPoint = Point(1, 2)
val yetAnotherPoint = Point(2, 2)
#+end_src

注意到可以不用new 关键字来实例化样例类,并且它们的值可以进行比较。
#+begin_src scala
object helloworld {
  def main(args: Array[String]): Unit = {
    case class Point(x: Int, y: Int)
    val point = Point(1, 2)
    val anotherPoint = Point(1, 2)
    val yetAnotherPoint = Point(2, 2)
    if (point == anotherPoint) {
      println(point + " and " + anotherPoint + " are the same.")
    } else {
      println(point + " and " + anotherPoint + " are different.")
    } // Point(1,2) and Point(1,2) are the same.

    if (point == yetAnotherPoint) {
      println(point + " and " + yetAnotherPoint + " are the same.")
    } else {
      println(point + " and " + yetAnotherPoint + " are different.")
    } // Point(1,2) and Point(2,2) are different.
  }
}
#+end_src

** traits
scala trait(特征) 相当于 java 的接口，实际上它比接口还功能强大。

与接口不同的是，它还可以定义属性和方法的实现。

一般情况下scala 的类只能继承单一父类，但是如果是 trait 的话就可以继承多个，从结果来看就是实现了多重继承。

特性是包含某些字段和方法的抽象数据类型。在scala 继承中，一个类只能扩展另一个类，但是可以扩展多个特征。可以使用trait 定义特征：

#+begin_src scala
trait Greeter {
  def greet(name: String): Unit
}
#+end_src

** 闭包
闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。
闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数。

#+begin_src scala
object helloworld {
  def main(args: Array[String]): Unit = {
//    val pattern = new Regex("(S|s)cala")
//    val str = "Scala is Scalable and cool"
//   println((pattern findFirstIn str).mkString(","))
  println("muliplier(2) value = " + multiplier(2));
  }
//  def addInt(a:Int,b:Int):Int={
//    var sum = 0
//    sum = a + b
//    return sum
//  }
  val factor = 3
  val multiplier = (i:Int) => i * factor
}
#+end_src

** 主方法
主方法是一个程序的入口点。JVM要求一个名为main的主方法，接受一个字符串数组的参数。
通过使用对象，你可以如下所示来定义一个主方法。

#+begin_src scala
object Main {
  def main(args: Array[String]): Unit =
    println("Hello, Scala developer!")
}
#+end_src

* 对象
对象是他们自己定义的单实例，可以把它看作它自己的类的单例。

可以使用object 关键字定义对象。

#+begin_src scala
object IdFactory {
  private var counter = 0
  def create(): Int = {
    counter += 1
    counter
  }
}
#+end_src

* singleton 对象
scala 比 java 更为面向对象的特点之一是scala 不能定义静态成员，而是代之以定义单例对象（singleton object）。除了用object 关键字替换了 class 关键字以外，单例对象的定义看上去与类定义一致。

* Scala 程序
想要编写能够独立运行的scala 程序，就必须创建有main 方法（仅带一个参数 Array[String], 且结果类型为Unit）的单例对象。任何拥有合适签名的 main 方法的单例对象都可以用来作为程序的入口点。

* spark
** 配置intelliJ idea
scala 的版本要适配spark 版本。

#+begin_src scala
val textFile = spark.read.textFile("README.md")
#+end_src
** read data

#+begin_src scala
val df = spark.read.json("resources/simple_zipcodes.json")
df.show()
#+end_src

#+begin_src scala
 val test = spark.sparkContext
      .textFile("resources/simple_zipcodes.txt")
      .map(_.split(":"))
      .toDF()
#+end_src

#+begin_src scala
val df = spark.read
       .option("header", "true")
       .option("delimiter", ",")
       .option("inferSchema", "false")
       .load("src\\main\\resources\\people.csv")
#+end_src

** show
展现数据。
#+begin_src scala
val df = spark.read.json("resources/simple_zipcodes.json")
df.show()
df.select("City").show()
#+end_src
** printSchema
展现数据类型。
#+begin_src scala
val df = spark.read.json("resources/simple_zipcodes.json")
df.show()
df.printSchema()
#+end_src

** select
选择数据列，这点和 R 一样。

#+begin_src scala
val df = spark.read.json("resources/simple_zipcodes.json")
df.select("City").show()
#+end_src

那么，如何选择多列？

#+begin_src scala
val df = spark.read.json("resources/simple_zipcodes.json")
df.select("City","Zipcode"+1).show()
#+end_src

还能实现mutate 功能！

** filter

#+begin_src scala

#+end_src

** groupby

#+begin_src scala
val df = spark.read.json("resources/simple_zipcodes.json")
df.groupBy("State").count().show()
#+end_src

** sql queries
The sql function on a SparkSession enables applications to run SQL queries programmatically and returns the result as a DataFrame.
#+begin_src scala
df.createOrReplaceTempView("table")
val sqlDF = spark.sql("select * from table where State = 'FL'")
#+end_src

** map
map 和python 一样！

#+begin_src scala
val primitiveDS = Seq(1, 2, 3).toDS()
primitiveDS.map(_ + 1).show()
#+end_src
